/* ================================================================
   CGV ACCOUNT TOOLS  â€”  2025-07-10
   Tambahan:
     â€¢ Auto-random profile (city, address, marital, genre)
     â€¢ Auto-verify SMS setelah register, dengan opsi /cancel
     â€¢ Fixed mainMenu() recursion bug
     â€¢ Auto Order Feature - order tiket film otomatis
   ================================================================ */

import fetch from 'node-fetch';
import chalk from 'chalk';
import delay from 'delay';
import fs from 'fs/promises';
import fs1 from 'fs';
import inquirer from 'inquirer';
import { FormData } from 'formdata-node';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
dotenv.config();
import * as mailTm from './mailTm.js';
import crypto from 'crypto';
import { faker } from '@faker-js/faker';
faker.locale = 'id_ID';   // pakai lokal Indonesia


/* ======  A. DEBUG UTILITIES  ================================== */
const DEBUG = process.env.DEBUG === '1';            // export DEBUG=1 node cgv.js
function dbg(...args) { 
  if (DEBUG) console.log(chalk.gray('ğŸ” [DEBUG]'), ...args); 
}

// Enhanced logging utilities for better output
const log = {
  success: (msg, ...args) => console.log(chalk.green('âœ…'), chalk.green.bold(msg), ...args),
  error: (msg, ...args) => console.log(chalk.red('âŒ'), chalk.red.bold(msg), ...args),
  warning: (msg, ...args) => console.log(chalk.yellow('âš ï¸ '), chalk.yellow.bold(msg), ...args),
  info: (msg, ...args) => console.log(chalk.blue('â„¹ï¸ '), chalk.blue.bold(msg), ...args),
  process: (msg, ...args) => console.log(chalk.cyan('âš¡'), chalk.cyan.bold(msg), ...args),
  step: (step, total, msg, ...args) => console.log(
    chalk.magenta(`[${step}/${total}]`), 
    chalk.white.bold(msg), 
    ...args
  ),
  section: (title) => {
    console.log();
    console.log(chalk.cyan('â•'.repeat(60)));
    console.log(chalk.cyan.bold(`  ${title.toUpperCase()}`));
    console.log(chalk.cyan('â•'.repeat(60)));
  },
  separator: () => console.log(chalk.gray('â”€'.repeat(60))),
  header: (title, subtitle = '') => {
    console.log();
    console.log(chalk.cyan('â•”' + 'â•'.repeat(58) + 'â•—'));
    console.log(chalk.cyan('â•‘') + chalk.white.bold(title.padStart(29 + title.length/2).padEnd(58)) + chalk.cyan('â•‘'));
    if (subtitle) {
      console.log(chalk.cyan('â•‘') + chalk.gray(subtitle.padStart(29 + subtitle.length/2).padEnd(58)) + chalk.cyan('â•‘'));
    }
    console.log(chalk.cyan('â•š' + 'â•'.repeat(58) + 'â•'));
    console.log();
  }
};

/** Membungkus fetch agar:
 *  - mencetak URL + status
 *  - menangkap body (teks) satu kali
 *  - selalu me-return objek { status_code, ... }
 */
async function fetchJson(url, opts = {}) {
  dbg('ğŸŒ', opts.method || 'GET', url.replace(/https?:\/\/[^\/]+/, ''));
  const res  = await fetch(url, opts);
  const text = await res.text();
  dbg('ğŸ“¥', `Status: ${res.status}`, text.slice(0, 150) + (text.length > 150 ? '...' : ''));
  try {
    const j = JSON.parse(text);
    if (!j.status_code) j.status_code = res.status;   // selaraskan skema lama
    return j;
  } catch (e) {
    return { status_code: res.status, raw: text };
  }
}
// â”€â”€ Random Device ID â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateDeviceId() {
  return (
    'android-' +
    crypto.randomBytes(8).toString('hex')   // 16 hex char
  );
}

// â”€â”€ Random User-Agent (pilihan ringan) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const UA_POOL = [
  // OkHttp variants (Android native apps)
  'okhttp/4.10.0',
  'okhttp/4.9.3',
  'okhttp/4.9.1',
  'okhttp/4.11.0',
  'okhttp/4.8.2',
  'okhttp/4.12.0',
  'okhttp/3.14.9',
  'okhttp/3.12.13',
  
  // CGV App variants
  'CGV/5.4.2 (Linux;Android 10; SM-G975F)',
  'CGV/5.5.1 (Linux;Android 12; Pixel 6)',
  'CGV/5.6.0 (Linux;Android 13; SM-G998B)',
  'CGV/5.3.8 (Linux;Android 11; Redmi Note 10)',
  'CGV/5.7.2 (Linux;Android 14; OnePlus 11)',
  
  // Chrome Mobile variants
  'Mozilla/5.0 (Linux; Android 13; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36',
  'Mozilla/5.0 (Linux; Android 12; SM-G998B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Mobile Safari/537.36',
  'Mozilla/5.0 (Linux; Android 11; Redmi Note 10 Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Mobile Safari/537.36',
  'Mozilla/5.0 (Linux; Android 14; OnePlus 11) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Mobile Safari/537.36',
  'Mozilla/5.0 (Linux; Android 10; SM-A515F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Mobile Safari/537.36',
  'Mozilla/5.0 (Linux; Android 12; Pixel 6 Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36',
  
  // Samsung Internet
  'Mozilla/5.0 (Linux; Android 13; SM-S918B) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/23.0 Chrome/115.0.0.0 Mobile Safari/537.36',
  'Mozilla/5.0 (Linux; Android 12; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/22.0 Chrome/114.0.0.0 Mobile Safari/537.36',
  
  // Edge Mobile
  'Mozilla/5.0 (Linux; Android 13; Pixel 7 Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36 EdgA/120.0.2210.61',
  'Mozilla/5.0 (Linux; Android 11; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Mobile Safari/537.36 EdgA/118.0.2088.69',
  
  // Firefox Mobile
  'Mozilla/5.0 (Mobile; rv:109.0) Gecko/109.0 Firefox/121.0',
  'Mozilla/5.0 (Android 13; Mobile; rv:109.0) Gecko/109.0 Firefox/120.0',
  
  // Opera Mobile
  'Mozilla/5.0 (Linux; Android 12; SM-G998B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Mobile Safari/537.36 OPR/80.0.4170.61',
  
  // Webview variants
  'Mozilla/5.0 (Linux; Android 13; SM-S918B wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/120.0.6099.43 Mobile Safari/537.36',
  'Mozilla/5.0 (Linux; Android 12; Pixel 6 wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/119.0.6045.66 Mobile Safari/537.36'
];
function getRandomUA() {
  return UA_POOL[Math.floor(Math.random() * UA_POOL.length)];
}

// â”€â”€ Random Accept-Language (opsional) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getRandomLang() {
  const langs = [
    // Indonesian variants
    'id-ID,id;q=0.9,en-US;q=0.8',
    'id-ID,id;q=0.9,en;q=0.8,en-US;q=0.7',
    'id-ID;q=0.9,id;q=0.8,en-US;q=0.7,en;q=0.6',
    'id,en;q=0.9',
    'id,en-US;q=0.9,en;q=0.8',
    'id-ID,en-US;q=0.8,en;q=0.7',
    
    // English variants
    'en-US,en;q=0.8',
    'en-US,en;q=0.9',
    'en-GB,en;q=0.8,id;q=0.6',
    'en-GB,en;q=0.9,id-ID;q=0.8,id;q=0.7',
    'en,id-ID;q=0.9,id;q=0.8',
    
    // Mixed variants
    'id-ID,en-US;q=0.9,en;q=0.8,zh-CN;q=0.7',
    'en-US,id-ID;q=0.9,en;q=0.8,ja;q=0.7',
    'id-ID,en-GB;q=0.9,en;q=0.8,ms;q=0.7'
  ];
  return langs[Math.floor(Math.random() * langs.length)];
}

// â”€â”€ Random Accept Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getRandomAccept() {
  const accepts = [
    'application/json, text/plain, */*',
    'application/json, text/javascript, */*; q=0.01',
    'application/json, application/xml, text/plain, text/html, *.*',
    '*/*',
    'application/json',
    'application/json, */*',
    'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
    'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
  ];
  return accepts[Math.floor(Math.random() * accepts.length)];
}

// â”€â”€ Random Accept-Encoding â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getRandomEncoding() {
  const encodings = [
    'gzip',
    'gzip, deflate',
    'gzip, deflate, br',
    'gzip, deflate, br, zstd',
    'identity',
    'gzip, identity',
    'deflate, gzip'
  ];
  return encodings[Math.floor(Math.random() * encodings.length)];
}

// â”€â”€ Random Connection Type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getRandomConnection() {
  const connections = [
    'Keep-Alive',
    'keep-alive',
    'close',
    'upgrade'
  ];
  return connections[Math.floor(Math.random() * connections.length)];
}

// â”€â”€ Random Cache Control â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getRandomCacheControl() {
  const cacheControls = [
    'no-cache',
    'no-store',
    'max-age=0',
    'no-cache, no-store, must-revalidate',
    'public, max-age=3600',
    'private, max-age=600',
    undefined // sometimes no cache control
  ];
  const selected = cacheControls[Math.floor(Math.random() * cacheControls.length)];
  return selected;
}

// â”€â”€ Random Additional Headers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getRandomAdditionalHeaders() {
  const headers = {};
  
  // Random DNT (Do Not Track)
  if (Math.random() < 0.3) headers['DNT'] = Math.random() < 0.5 ? '1' : '0';
  
  // Random Upgrade-Insecure-Requests
  if (Math.random() < 0.4) headers['Upgrade-Insecure-Requests'] = '1';
  
  // Random Sec-Fetch headers (for browsers)
  if (Math.random() < 0.5) {
    headers['Sec-Fetch-Site'] = ['same-origin', 'cross-site', 'same-site'][Math.floor(Math.random() * 3)];
    headers['Sec-Fetch-Mode'] = ['cors', 'navigate', 'no-cors', 'same-origin'][Math.floor(Math.random() * 4)];
    headers['Sec-Fetch-Dest'] = ['empty', 'document', 'script', 'style'][Math.floor(Math.random() * 4)];
  }
  
  // Random X-Requested-With (for AJAX)
  if (Math.random() < 0.3) headers['X-Requested-With'] = 'XMLHttpRequest';
  
  return headers;
}

// â”€â”€ Generate Complete Random Headers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateRandomHeaders(baseHeaders = {}) {
  const ua = getRandomUA();
  const lang = getRandomLang();
  const accept = getRandomAccept();
  const encoding = getRandomEncoding();
  const connection = getRandomConnection();
  const cacheControl = getRandomCacheControl();
  const additional = getRandomAdditionalHeaders();
  
  const headers = {
    'User-Agent': ua,
    'Accept-Language': lang,
    'Accept': accept,
    'Accept-Encoding': encoding,
    'Connection': connection,
    ...baseHeaders,
    ...additional
  };
  
  // Add cache control if generated
  if (cacheControl) {
    headers['Cache-Control'] = cacheControl;
  }
  
  
  return headers;
}
/* ---------- ENV CHECK ---------- */
const SET_NAME     = process.env.SET_NAME;
const SET_PASSWORD = process.env.SET_PASSWORD;   // masih dipakai untuk REGISTER
const SET_PIN      = process.env.SET_PIN;
const EMAIL_PREFIX = process.env.EMAIL_PREFIX;
if (!SET_NAME || !SET_PASSWORD || !SET_PIN || !EMAIL_PREFIX) {
  console.error('âŒ ERROR: set SET_NAME, SET_PASSWORD, SET_PIN, EMAIL_PREFIX di .env');
  process.exit(1);
}

/* ---------- DEFAULT PASSWORDS FOR AUTO LOGIN (data.txt) ---------- */
const DEFAULT_PASSWORDS = Array.from(new Set(
  (process.env.DEFAULT_PASSWORDS || `${SET_PASSWORD},Iqra0704,Cgv123456`)
    .split(',')
    .map(s => s.trim())
    .filter(Boolean)
));

/* ---------- PAYMENT GATEWAY SETTINGS ---------- */
const MIDTRANS_GOPAY_API_URL = process.env.MIDTRANS_GOPAY_API_URL || 'https://api.midtrans.com/v2/gopay';

/* Heuristik deteksi â€œsalah passwordâ€ */
function looksWrongPassword(res) {
  const msg = (res?.message || '').toLowerCase();
  if (res?.status_code === 401) return true;
  return /(wrong|invalid|incorrect|mismatch|not match|salah)/.test(msg)
      && /(password|pass|credential|kata sandi|sandi)/.test(msg);
}

/* NEW: deteksi rate-limited (429) */
function looksRateLimited(res) {
  const sc  = res?.status_code;
  const msg = String(res?.message || '').toLowerCase();
  return sc === 429 || /too many|rate limit|throttl/.test(msg);
}

/* NEW: global cooldown setelah 429 */
let RATE_LIMIT_LOCK_UNTIL = 0; // timestamp (ms)
function msUntil(ts) {
  const d = ts - Date.now();
  return d > 0 ? d : 0;
}


/* Login dengan smart-retry + 429 cooldown:
   - Wrong password â†’ langsung ganti password berikutnya
   - 429 (rate limit) â†’ cooldown 60â€“90 dtk, ulang password YANG SAMA (retry tidak dihitung)
   - Error lain â†’ backoff ringan
   - usedPwd DIKEMBALIKAN apa adanya (TANPA mask)
*/
async function loginWithSmartRetry(email, passwords = DEFAULT_PASSWORDS, maxRetry = 3) {
  // Hormati global cooldown jika masih aktif
  const waitGlobal = msUntil(RATE_LIMIT_LOCK_UNTIL);
  if (waitGlobal > 0) {
    log.warning(`Global cooldown ${Math.round(waitGlobal/1000)}s â€” waiting before ${email}...`);
    await delay(waitGlobal);
  }

  // Normalisasi & unik (tetap urutan)
  const pwds = Array.from(new Set(
    (Array.isArray(passwords) ? passwords : [passwords])
      .map(p => String(p || '').trim())
      .filter(Boolean)
  ));

  let last = null;

  for (const pwd of pwds) {
    for (let i = 1; i <= maxRetry; i++) {
      const res = await getLoginAccount(email, pwd);
      last = res;

      // sukses
      if (res?.status_code === 200 && res?.token) {
        return { ok: true, res, usedPwd: pwd }; // â† TIDAK DI-MASK
      }

      // salah password â†’ lanjut ke kandidat berikutnya
      if (looksWrongPassword(res)) break;

      // rate limited â†’ cooldown & ulang password sama (attempt tidak dihitung)
      if (looksRateLimited(res)) {
        const waitMs =
          (typeof res?.retry_after_ms === 'number' && res.retry_after_ms > 0)
            ? res.retry_after_ms
            : 60000 + Math.floor(Math.random() * 30000); // 60â€“90s

        RATE_LIMIT_LOCK_UNTIL = Math.max(RATE_LIMIT_LOCK_UNTIL, Date.now() + waitMs);
        log.warning(`Rate limited - cooldown ${Math.round(waitMs/1000)}s, retrying same password...`);
        await delay(waitMs);
        i--;                 // jangan hitung attempt ini
        continue;            // ulangi password yang sama
      }

      // error lain â†’ backoff ringan (exponential)
      await delay(800 * i);
    }
  }

  return { ok: false, res: last };
}




// ambil daftar email yg sudah ada di account.json
async function readExistingEmailsFromAccountJson() {
  try {
    const raw = await fs.readFile('account.json','utf-8');
    const j = JSON.parse(raw);
    const set = new Set();
    (j.items || []).forEach(it => { if (it.email) set.add(String(it.email).trim()); });
    return set;
  } catch {
    return new Set();
  }
}




//================================================================
// ğŸ¬ AUTO ORDER (CGV) â€” City Input + Bearer-first + Nice Tables
// - Input nama kota (bebas) â†’ auto match lokasi (fuzzy/substring)
// - Pakai bearer dari account.json (fallback login jika tersedia)
// - Tabel Playing & Upcoming terpisah, rapi, id-ID number format
// - Self-contained (fallback modules & helpers) â€” aman copy-paste
// - NEW: pilih tanggal & jadwal â†’ seat map â†’ pilih kursi â†’ book
// - NEW: opsi lanjut pembayaran / cancel, dengan log detail ke log.json
// - NEW: voucher flow (auto-detect by movie name, B1G1 validator,
//        try-all dengan delay & manual pick), raw HTTP logs â†’ log.json
// - NEW (update): Auto-pay default DANA (E-WALLET). Enter = pakai
//   DANA otomatis; ketik "y" untuk pilih metode lain.
// - NEW (update): Implement payment-partners/select & pay.
// - NEW (monitor): Setelah init payment, monitoring status aktif
//   langsung detik itu (rapid polling 1s selama ~20s pertama), lalu
//   interval normal. Tetap ada prompt tiap 60 detik untuk cancel/lanjut.
// - NEW (DANA): Hanya tampilkan link **Checkout (DANA)** dan otomatis
//   dibuka di browser (pakai 'open' atau fallback OS). Tidak menampilkan
//   nomor DANA atau URL input-telepon/prefill. Jika gagal auto-buka,
//   user diminta buka manual.
// - NEW (VA): Saat pilih Bank Transfer, kirim bank_id & tampilkan
//   breakdown (sub_total, fee, total) + data VA (bank & no. VA).
// - NEW (UI): Account selection dengan table, cinema table, movie filter,
//   seat input manual, enhanced date input, monitoring dengan detail
// - UPDATE (summary): Tampilkan "RINGKASAN LENGKAP PESANAN"
//   sebelum dan sesudah monitoring, dengan status yang menyesuaikan.
// ================================================================
async function autoOrder(options = {}) {
  const {
    baseURL = 'https://v2-api.cgv.id',
    accountJsonPath = 'account.json',
    logJsonPath = 'log.json'
  } = options;

    // === SALE CHANNEL (App Only coupons need this on body) ===
  // 05 = App (CGV mobile app). Server tetap minta field ini di body,
  // meskipun token kamu punya claim channel_code.
  const APP_CHANNEL = {
    channel_code: '05',
    sale_channel_code: '05'
  };

  // ---------- DANA PHONE OVERRIDE (opsional, tidak ditampilkan) ----------
  const DANA_PHONE_OVERRIDE = '082296813933'; // tidak ditampilkan/di-log

  // ---------- FALLBACK MODULES ----------
const chalk = (globalThis.chalk && globalThis.chalk.green) ? globalThis.chalk : (await import('chalk')).default;
const fs = (globalThis.fs && globalThis.fs.readFile) ? globalThis.fs : (await import('fs/promises'));
const inquirer = (globalThis.inquirer && globalThis.inquirer.prompt) ? globalThis.inquirer : (await import('inquirer')).default;
const path = (await import('path')).default;  // ğŸ‘ˆ TAMBAHKAN INI



  let fetchRef = globalThis.fetch;
  if (!fetchRef) { try { fetchRef = (await import('node-fetch')).default; } catch {} }
  const fetch = fetchRef;

  // === Proxy runtime (untuk FETCH saja; Puppeteer TIDAK diproxy)
  const PROXY_LIST = (process.env.PROXY_LIST || '')
    ? process.env.PROXY_LIST.split(',').map(s => s.trim()).filter(Boolean)
    : ['JSbXD9LqK1En8Fe5:8ClzkSozENdY3JRZ_country-id@geo.iproyal.com:12321'];

  let PROXY_DISABLED   = false;      // true => direct
  let RUNTIME_PROXY_URL = null;      // kalau user input manual

  const maskProxy = (u) => {
    try {
      const url = new URL(u.startsWith('http') ? u : `http://${u}`);
      const host = url.hostname;
      const port = url.port ? `:${url.port}` : '';
      return `${url.protocol}//***:***@${host}${port}`;
    } catch { return u; }
  };

  let rrIndex = 0;
  const nextProxyUrl = () => {
    if (!PROXY_LIST.length) return null;
    const raw = PROXY_LIST[rrIndex++ % PROXY_LIST.length];
    return raw.startsWith('http') ? raw : `http://${raw}`;
  };

  // Agents per-sesi (fetch)
  let sessionNodeAgent   = null; // untuk node-fetch
  let sessionUndiciAgent = null; // untuk global fetch (undici)
  let sessionProxyUrl    = null;

  let HttpsProxyAgentCtor = null;
  async function ensureAgentModules(){
    if (!HttpsProxyAgentCtor) {
      try { HttpsProxyAgentCtor = (await import('https-proxy-agent')).HttpsProxyAgent; } catch {}
    }
  }

  async function makeProxyAgents(url) {
    if (!url) return { node: null, undici: null };
    await ensureAgentModules();
    let node = null, undiciAgent = null;
    try { if (HttpsProxyAgentCtor) node = new HttpsProxyAgentCtor(url); } catch {}
    try {
      const undici = await import('undici');
      undiciAgent = new undici.ProxyAgent(url);
    } catch {}
    return { node, undici: undiciAgent };
  }

  async function promptProxyAtStartup() {
    // Read USE_PROXY from .env
    const USE_PROXY = String(process.env.USE_PROXY || 'false').toLowerCase() === 'true';

    // If USE_PROXY=false, skip proxy prompt
    if (!USE_PROXY) {
      PROXY_DISABLED = true;
      RUNTIME_PROXY_URL = null;
      return;
    }

    // If USE_PROXY=true, check if PROXY_LIST is valid
    if (PROXY_LIST && PROXY_LIST.length > 0) {
      // Valid PROXY_LIST, use it automatically
      PROXY_DISABLED = false;
      RUNTIME_PROXY_URL = null;
      log.info(`ğŸŒ Proxy enabled: menggunakan ${PROXY_LIST.length} proxy dari PROXY_LIST`);
      return;
    }

    // PROXY_LIST is empty or invalid, prompt user to input custom proxy
    log.warning('âš ï¸  USE_PROXY=true tapi PROXY_LIST kosong atau tidak valid!');
    const { url } = await inquirer.prompt([{
      type: 'input',
      name: 'url',
      message: 'ğŸŒ Masukkan Proxy URL (contoh: http://user:pass@host:port):',
      validate: v => /^https?:\/\//i.test(String(v).trim()) ? true : 'Harus diawali http:// atau https://',
      filter: v => String(v || '').trim()
    }]);
    PROXY_DISABLED = false;
    RUNTIME_PROXY_URL = url;
  }

  async function initSessionAgentIfNeeded() {
    if (PROXY_DISABLED) {
      sessionNodeAgent = null;
      sessionUndiciAgent = null;
      sessionProxyUrl = null;
      try { console.log('[PROXY] mode: OFF (DIRECT)'); } catch {}
      return;
    }
    if (sessionNodeAgent || sessionUndiciAgent) return;

    const url = RUNTIME_PROXY_URL || nextProxyUrl();
    sessionProxyUrl = url || null;

    const { node, undici } = await makeProxyAgents(url);
    sessionNodeAgent   = node;
    sessionUndiciAgent = undici;

    if (sessionNodeAgent || sessionUndiciAgent) {
      try { console.log(`[PROXY] mode: ON â†’ ${maskProxy(sessionProxyUrl)}`); } catch {}
    } else {
      try { console.log('[PROXY] mode: OFF (DIRECT) â€” no proxy configured'); } catch {}
    }
  }

  // Tambahkan opsi ini ke setiap fetch call kita
  function proxyFetchOpts() {
    if (sessionUndiciAgent) return { dispatcher: sessionUndiciAgent }; // undici (global fetch)
    if (sessionNodeAgent)   return { agent: sessionNodeAgent };        // node-fetch
    return {};
  }

  // (opsional) utk kompatibilitas legacy
  function getRandomProxy() {
    return sessionNodeAgent || undefined;
  }

  let CliTable;
  try { CliTable = (await import('cli-table3')).default; }
  catch {
    CliTable = class PoorTable {
      constructor(opts = {}) {
        this.rows = [];
        this.head = Array.isArray(opts.head) ? opts.head : [];
        this.options = opts || {};
      }
      push(r){ this.rows.push(r); }
      toString(){
        const allRows = [...(this.head.length ? [this.head] : []), ...this.rows];
        if (allRows.length === 0) return '';
        const colCount = Math.max(...allRows.map(r => (Array.isArray(r) ? r.length : 0)));
        const widths = new Array(colCount).fill(0).map((_, i) =>
          Math.max(...allRows.map(r => String((r || [])[i] ?? '').length))
        );
        const line = (L,M,R)=>L+widths.map(w=>'â”€'.repeat(w+2)).join(M)+R;
        const fmt = (r)=>'â”‚ '+new Array(colCount).fill('').map((_,i)=>String((r||[])[i]??'').padEnd(widths[i])).join(' â”‚ ')+' â”‚';
        const out = [];
        out.push(line('â”Œ','â”¬','â”'));
        if (this.head.length){ out.push(fmt(this.head)); out.push(line('â”œ','â”¼','â”¤')); }
        this.rows.forEach((r,i)=>{ out.push(fmt(r)); out.push(line(i===this.rows.length-1?'â””':'â”œ','â”¼',i===this.rows.length-1?'â”˜':'â”¤')); });
        return out.join('\n');
      }
    };
  }

  // ---------- LOGGING (Console + File) ----------
  const stripAnsi = (s)=>String(s||'').replace(
    // eslint-disable-next-line no-control-regex
    /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,''
  );

  async function appendJsonLog(obj) {
    try {
      const ts = new Date().toISOString();
      await fs.appendFile(logJsonPath, JSON.stringify({ ts, ...obj }) + '\n', 'utf-8'); // JSONL
    } catch {}
  }

  const log = {
    header: (title, sub='')=>{
      const w = 58;
      const center = (s)=> {
        const pad = Math.max(0, Math.floor((w - s.length) / 2));
        return 'â”‚  ' + ' '.repeat(pad) + s + ' '.repeat(Math.max(0, w - s.length - pad)) + '  â”‚';
      };
      const a = 'â•”' + 'â•'.repeat(w+4) + 'â•—';
      const b = center(title);
      const c = sub ? center(sub) : '';
      const d = 'â•š' + 'â•'.repeat(w+4) + 'â•';
      console.log(chalk.cyan(a)); console.log(chalk.cyan(b)); if (sub) console.log(chalk.cyan(c)); console.log(chalk.cyan(d));
    },
    section: (s)=> { const L1 = '\n' + 'â•'.repeat(58); const L2 = '  ' + s; const L3 = 'â•'.repeat(58); console.log(L1); console.log(L2); console.log(L3); },
    process: (s)=> { console.log(chalk.yellow('âš¡ ' + s)); },
    info: (s)=> { console.log(chalk.white('â„¹ï¸  ' + s)); },
    success: (s)=> { console.log(chalk.green('âœ… ' + s)); },
    warning: (s)=> { console.log(chalk.yellow('âš ï¸  ' + s)); },
    error: (s)=> { console.log(chalk.red('âŒ ' + s)); },
    http: (method, url, status, note='')=>{
      const line = `HTTP ${method} ${url} â†’ ${status}${note?` | ${note}`:''}`;
      console.log(chalk.gray(line));
    }
  };

// ---------- HELPERS ----------
if (typeof globalThis.delay !== 'function') {
  globalThis.delay = (ms)=> new Promise(r=>setTimeout(r, ms));
}

// === Wrapper satu pintu ===
async function launchBrowser({ label = 'Automation', ...launchOpts } = {}) {
  await waitForSameBrowserFree({ label });
  const puppeteer = (await import('puppeteer')).default;
  return puppeteer.launch(launchOpts);
}


// === [NEW] Guard: tunggu hanya browser YANG SAMA dengan yang akan dipakai Puppeteer ===
const SKIP_BROWSER_GUARD = String(process.env.SKIP_BROWSER_GUARD || '') === '1';
const BROWSER_WAIT_TIMEOUT_MS = Number(process.env.BROWSER_WAIT_TIMEOUT_MS || 0); // 0 = tanpa timeout
const BROWSER_GUARD_EXECUTABLE = String(process.env.BROWSER_GUARD_EXECUTABLE || '').trim().toLowerCase(); // override m

async function listProcessNamesLower() {
  try {
    const psList = (await import('ps-list')).default;
    const items = await psList();
    return items.map(p => String(p.name || '').toLowerCase()).filter(Boolean);
  } catch {}
  const { exec } = await import('child_process');
  const platform = process.platform;
  const cmd = (platform === 'win32')
    ? 'powershell -Command "Get-Process | Select-Object -ExpandProperty ProcessName"'
    : 'ps -A -o comm=';
  return await new Promise(resolve => {
    exec(cmd, { windowsHide: true }, (err, stdout='') => {
      if (err) {
        if (platform === 'win32') {
          exec('tasklist /FO CSV', { windowsHide: true }, (_e, out='') => {
            const names = out.split(/\r?\n/).slice(1).map(line => {
              const m = line.match(/^"([^"]+)"/); return m ? m[1] : '';
            });
            resolve(names.map(s => s.toLowerCase()).filter(Boolean));
          });
          return;
        }
        return resolve([]);
      }
      resolve(stdout.split(/\r?\n/).map(s => s.trim().toLowerCase()).filter(Boolean));
    });
  });
}

async function derivePptrBrowserBaseName() {
  if (BROWSER_GUARD_EXECUTABLE) return BROWSER_GUARD_EXECUTABLE;
  try {
    const puppeteer = (await import('puppeteer')).default;
    if (typeof puppeteer.executablePath === 'function') {
      const p = puppeteer.executablePath() || '';
      const base = String(p).split(/[\\/]/).pop().toLowerCase();
      if (base) return base;
    }
  } catch {}
  if (process.platform === 'win32') return 'chrome.exe';
  if (process.platform === 'darwin') return 'google chrome';
  return 'chrome';
}

function expandAliases(base) {
  const s = String(base || '').toLowerCase();
  const set = new Set([s]);
  if (/chrome/.test(s))   { set.add('chrome').add('chrome.exe'); }
  if (/chromium/.test(s)) { set.add('chromium').add('chromium-browser').add('chromium.exe'); }
  if (/msedge|edge/.test(s)) { set.add('msedge').add('msedge.exe').add('microsoft edge'); }
  return Array.from(set);
}

async function waitForSameBrowserFree({ label='Movie Ticket', pollMs=1500, timeoutMs=BROWSER_WAIT_TIMEOUT_MS } = {}) {
  if (SKIP_BROWSER_GUARD) return true;
  const base = await derivePptrBrowserBaseName();
  const targets = expandAliases(base);
  const start = Date.now();
  let dots = 0;
  while (true) {
    const names = await listProcessNamesLower();
    const running = names.filter(n => targets.some(t => n === t || n.endsWith('/' + t)));
    if (running.length === 0) { process.stdout.write('\r'); return true; }
    const dotStr = '.'.repeat((dots++ % 3) + 1);
    const msg = `â³ Menunggu ${label} â€” tutup ${targets[0]} terlebih dahulu ${dotStr}   `;
    process.stdout.write('\r' + msg);
    if (timeoutMs && (Date.now() - start) > timeoutMs) {
      process.stdout.write('\n');
      console.log(chalk.yellow('â³ Timeout menunggu browser yang sama. Melanjutkan.'));
      return false;
    }
    await delay(pollMs);
  }
}


// ---------- TELEGRAM CONFIG ----------
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID;

// ---------- QR CODE UTILS ----------
const QRCode = await import('qrcode');
const QRTerminal = await import('qrcode-terminal');
const axios = (await import('axios')).default;
const Jimp = (await import('jimp')).Jimp;
const QrCodeReader = (await import('qrcode-reader')).default;

async function decodeQRFromMidtrans(qrCodeUrl) {
  try {
    // 1. Fetch PNG dari Midtrans dengan validasi content-type
    console.log(chalk.cyan('âš¡ Mengambil QR image dari Midtrans...'));
    const response = await axios.get(qrCodeUrl, {
      responseType: 'arraybuffer',
      timeout: 25000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'image/png,image/*;q=0.9,*/*;q=0.8',
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      }
    });

    // Validate content-type (seperti script yang berhasil)
    const contentType = response.headers['content-type'] || '';
    console.log(chalk.gray(`â„¹ï¸  Content-Type: ${contentType}`));

    if (!contentType.includes('image')) {
      throw new Error('Midtrans tidak return image (mungkin HTML/JSON error)');
    }

    // Validate response data
    if (!response.data || response.data.length < 100) {
      throw new Error('Invalid or empty image data received');
    }

    // Convert to Buffer (penting untuk compatibility)
    const buffer = Buffer.from(response.data);

    // Wait to ensure image is fully loaded
    await delay(500);

    // 2. Load image dengan Jimp
    console.log(chalk.cyan('âš¡ Memproses QR image...'));

    // 3. Try multiple preprocessing strategies (seperti script yang berhasil)
    const preprocessStrategies = [
      { name: 'greyscale+contrast', fn: (img) => img.greyscale().contrast(1) }, // Strategy yang berhasil
      { name: 'original', fn: null },
      { name: 'greyscale', fn: (img) => img.greyscale() },
      { name: 'greyscale+high-contrast', fn: (img) => img.greyscale().contrast(0.8) },
      { name: 'contrast+brightness', fn: (img) => img.contrast(0.5).brightness(0.1) },
      { name: 'high-contrast', fn: (img) => img.contrast(0.7) },
      { name: 'normalized', fn: (img) => img.normalize() },
      { name: 'normalized+contrast', fn: (img) => img.normalize().contrast(0.5) },
      { name: 'brightness', fn: (img) => img.brightness(0.2) },
      { name: 'invert', fn: (img) => img.invert() }
    ];

    console.log(chalk.cyan('âš¡ Mencoba decode QR dengan multiple strategies...'));

    for (const strategy of preprocessStrategies) {
      try {
        // Re-read image untuk setiap strategy (fresh copy)
        const img = await Jimp.read(buffer);

        // Apply preprocessing (mutate langsung seperti script yang berhasil)
        if (strategy.fn) {
          strategy.fn(img);
        }

        const { bitmap } = img;
        const qr = new QrCodeReader();

        const result = await Promise.race([
          new Promise((resolve) => {
            qr.callback = (err, value) => {
              if (err) {
                // Silent fail (terlalu verbose)
                resolve(null);
                return;
              }
              if (!value || !value.result) {
                // Silent fail (terlalu verbose)
                resolve(null);
                return;
              }
              resolve(value.result);
            };

            try {
              qr.decode(bitmap);
            } catch (decodeErr) {
              // Silent fail (terlalu verbose)
              resolve(null);
            }
          }),
          new Promise((resolve) => setTimeout(() => {
            // Timeout (tidak perlu log karena terlalu verbose)
            resolve(null);
          }, 5000))
        ]);

        if (result) {
          console.log(chalk.green(`âœ… QR decoded berhasil dengan strategy: ${strategy.name}`));
          return result;
        }
      } catch (strategyErr) {
        // Silent fail (terlalu verbose)
        continue;
      }
    }

    // Semua strategies gagal dari memory buffer
    // ğŸ†• FALLBACK: Download ke file lokal dan decode dari file
    console.log(chalk.yellow('âš ï¸ Decode dari memory gagal, mencoba download ke file...'));

    try {
      const fs = require('fs');
      const os = require('os');
      const path = require('path');

      // Generate temp filename
      const tempDir = os.tmpdir();
      const tempFile = path.join(tempDir, `qr_${Date.now()}.png`);

      // Save buffer to file
      console.log(chalk.cyan(`âš¡ Menyimpan QR ke: ${tempFile}`));
      fs.writeFileSync(tempFile, buffer);

      // Decode dari file (lebih reliable)
      console.log(chalk.cyan('âš¡ Decode QR dari file...'));

      for (const strategy of preprocessStrategies) {
        try {
          // Read dari file
          const img = await Jimp.read(tempFile);

          // Apply preprocessing
          if (strategy.fn) {
            strategy.fn(img);
          }

          const { bitmap } = img;
          const qr = new QrCodeReader();

          const result = await Promise.race([
            new Promise((resolve) => {
              qr.callback = (err, value) => {
                if (err) {
                  resolve(null);
                  return;
                }
                if (!value || !value.result) {
                  resolve(null);
                  return;
                }
                resolve(value.result);
              };

              try {
                qr.decode(bitmap);
              } catch (decodeErr) {
                resolve(null);
              }
            }),
            new Promise((resolve) => setTimeout(() => resolve(null), 5000))
          ]);

          if (result) {
            console.log(chalk.green(`âœ… QR decoded dari file dengan strategy: ${strategy.name}`));
            // Cleanup file
            try {
              fs.unlinkSync(tempFile);
              console.log(chalk.gray('ğŸ—‘ï¸  Temp file cleaned up'));
            } catch (cleanupErr) {
              console.log(chalk.gray(`âš ï¸ Gagal hapus temp file: ${cleanupErr.message}`));
            }
            return result;
          }
        } catch (strategyErr) {
          continue;
        }
      }

      // Cleanup file jika semua gagal
      try {
        fs.unlinkSync(tempFile);
        console.log(chalk.gray('ğŸ—‘ï¸  Temp file cleaned up (no decode success)'));
      } catch (cleanupErr) {
        console.log(chalk.gray(`âš ï¸ Gagal hapus temp file: ${cleanupErr.message}`));
      }

    } catch (fileErr) {
      console.log(chalk.yellow(`âš ï¸ Fallback file decode gagal: ${fileErr.message}`));
    }

    // Jika semua gagal (memory + file)
    return { error: 'decode_failed', retriable: true };

  } catch (err) {
    console.log(chalk.yellow(`âš ï¸ Gagal fetch/decode QR dari Midtrans: ${err.message}`));
    console.log(chalk.yellow('â„¹ï¸  Skip QR decode, gunakan link Midtrans saja.'));
    return { error: err.message, retriable: true }; // Bisa retry (network issue)
  }
}

async function generateQRCodeImage(qrString) {
  try {
    // Generate QR code as data URL (base64)
    const qrDataUrl = await QRCode.default.toDataURL(qrString, {
      errorCorrectionLevel: 'M',
      type: 'image/png',
      width: 600,
      margin: 2,
      color: {
        dark: '#000000',
        light: '#FFFFFF'
      }
    });
    return qrDataUrl;
  } catch (err) {
    console.log(chalk.yellow(`âš ï¸ Gagal generate QR image: ${err.message}`));
    return null;
  }
}

function displayQRInTerminal(qrString) {
  try {
    console.log('\n' + chalk.cyan('â•'.repeat(60)));
    console.log(chalk.cyan.bold('  ğŸ“± SCAN QR CODE GOPAY (MIDTRANS) DI BAWAH INI'));
    console.log(chalk.cyan('â•'.repeat(60)) + '\n');
    QRTerminal.default.generate(qrString, { small: true });
    console.log('\n' + chalk.cyan('â•'.repeat(60)));
    console.log(chalk.yellow('ğŸ’¡ Scan QR Code di atas untuk membayar'));
    console.log(chalk.cyan('â•'.repeat(60)));
  } catch (err) {
    console.log(chalk.yellow(`âš ï¸ Gagal tampilkan QR di terminal: ${err.message}`));
  }
}

async function sendTelegramQRCode(qrDataUrl, caption = '') {
  try {
    if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) {
      console.log(chalk.yellow('âš ï¸ Telegram credentials missing'));
      return null;
    }

    if (!qrDataUrl) {
      console.log(chalk.yellow('âš ï¸ QR data URL is empty'));
      return null;
    }

    console.log(chalk.cyan('ğŸ“¤ Mengirim QR Code ke Telegram...'));

    // Convert data URL to buffer
    const base64Data = qrDataUrl.replace(/^data:image\/\w+;base64,/, '');
    const buffer = Buffer.from(base64Data, 'base64');

    console.log(chalk.gray(`   Buffer size: ${(buffer.length / 1024).toFixed(2)} KB`));

    const FormData = (await import('form-data')).default;
    const form = new FormData();
    form.append('chat_id', TELEGRAM_CHAT_ID);
    form.append('photo', buffer, { filename: 'gopay-qr.png' });
    if (caption) {
      form.append('caption', caption);
      form.append('parse_mode', 'HTML');
    }

    const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;

    // Use axios instead of fetch for better compatibility with form-data
    const response = await axios.post(url, form, {
      headers: form.getHeaders()
    });

    if (response.data && response.data.ok) {
      console.log(chalk.green('âœ… QR Code berhasil dikirim ke Telegram!'));
      return response.data.result?.message_id || null;
    } else {
      console.log(chalk.red(`âŒ Telegram response not OK: ${response.data?.description || 'Unknown'}`));
      return null;
    }
  } catch (e) {
    console.log(chalk.red(`âŒ Telegram QR error: ${e.message}`));
    if (e.response) {
      console.log(chalk.gray(`   Status: ${e.response.status}`));
      console.log(chalk.gray(`   Detail: ${e.response.data?.description || 'No details'}`));
    }
    return null;
  }
}

// ---------- TELEGRAM PAYMENT SUMMARY UTILS ----------

function tgSafe(val) {
  if (val == null) return '-';
  return String(val);
}

async function sendTelegramPaymentSummary({
  order,
  movie,
  dateYmd,
  schedule,
  seats,
  methodLabel,
  checkoutUrl,
  voucherName = null,
  voucherCode = null,
  discountAmount = 0
}) {
  try {
    if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) return null;
    if (!order) return null;

    const seatLabels = Array.isArray(seats) ? seats.map(s => (s.label || s)).join(', ') : '-';
    const tgl = `${dateYmd.slice(6,8)}/${dateYmd.slice(4,6)}/${dateYmd.slice(0,4)}`;
    const jam = schedule?.start_time || '';
    const total = typeof toRp === 'function' ? toRp(order.total_amount || 0) : String(order.total_amount || 0);
    const subtotal = typeof toRp === 'function' ? toRp(order.sub_total_amount || 0) : String(order.sub_total_amount || 0);
    const fee = typeof toRp === 'function' ? toRp(order.convenience_fee || 0) : String(order.convenience_fee || 0);

    const vaNumber = order.virtual_account_bank_number || order.payment_code || '';
    const vaBank = order.virtual_account_bank_name || '';

    let text = '';
    text += 'ğŸ¬ <b>CGV Auto Order â€” Payment Init</b>\n\n';
    text += `<b>Film</b>: ${tgSafe(movie?.name || order.movie_name || '-')}\n`;
    text += `<b>Tanggal</b>: ${tgl} ${jam}\n`;
    text += `<b>Kursi</b>: ${seatLabels}\n`;
    text += `<b>Metode</b>: ${tgSafe(methodLabel || 'Payment')}\n\n`;
    text += `<b>Order ID</b>: ${tgSafe(order.id || order.sales_id || '-')}\n`;
    text += `<b>Booking</b>: ${tgSafe(order.booking_code || '-')}\n\n`;
    text += `<b>Subtotal</b>: ${subtotal}\n`;
    if (voucherName || voucherCode) {
      const vName = voucherName || voucherCode || '-';
      const vDisc = typeof toRp === 'function' ? toRp(discountAmount || 0) : String(discountAmount || 0);
      text += `<b>Voucher</b>: ${tgSafe(vName)}\n`;
      text += `<b>Diskon</b>: -${vDisc}\n`;
    }
    if (order.convenience_fee) text += `<b>Admin Fee</b>: ${fee}\n`;
    text += `<b>Total</b>: ${total}\n`;
    text += `<b>Expire</b>: ${tgSafe(order.expired_date || '-')}\n`;

    if (vaNumber) {
      text += `\n<b>VA Bank</b>: ${tgSafe(vaBank || 'Virtual Account')}\n`;
      text += `<b>VA Number</b>: <code>${vaNumber}</code>\n`;
    }

    if (checkoutUrl) {
      text += `\n<a href="${checkoutUrl}">ğŸ”— Link Pembayaran</a>\n`;
    }

    text += '\nğŸ“Š Status akan dimonitor otomatis oleh bot';

    const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        chat_id: TELEGRAM_CHAT_ID,
        text,
        parse_mode: 'HTML',
        disable_web_page_preview: false
      })
    });
    const json = await res.json().catch(() => null);
    if (!res.ok || !json?.ok) {
      if (typeof log !== 'undefined' && log.warning) {
        log.warning(`Telegram send failed: ${json?.description || res.statusText}`);
      }
      return null;
    }
    return json.result?.message_id || null;
  } catch (e) {
    if (typeof log !== 'undefined' && log.warning) {
      log.warning(`Telegram send error: ${e.message}`);
    }
    return null;
  }
}

async function deleteTelegramPaymentMessage(messageId) {
  try {
    if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID || !messageId) return;
    const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/deleteMessage`;
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        chat_id: TELEGRAM_CHAT_ID,
        message_id: messageId
      })
    });
    // nggak apa-apa kalau gagal, ga usah nge-throw
    await res.json().catch(() => null);
  } catch (e) {
    if (typeof log !== 'undefined' && log.warning) {
      log.warning(`Telegram delete error: ${e.message}`);
    }
  }
}



// Kirim screenshot tiket MOVIE (PNG) ke Telegram sebagai photo
async function sendTelegramTicketScreenshot({
  filePath,
  bookingCode,
  passKey,
  salesId,
  accountName,     // opsional
  accountEmail,    // opsional
  accountPassword, // opsional
  account          // opsional: object akun penuh (selectedAccount)
}, options = {}) {
  const { sendToTelegram = false } = options; // ğŸ”§ konfigurasi kirim Telegram

  try {
    const safe = (v) => String(v ?? '').trim();

    // ğŸ” Ambil info akun dari parameter atau object `account`
    const accountObj =
      account && typeof account === 'object'
        ? account
        : null;

    let nameSafe = '';
    let emailSafe = '';
    let passwordSafe = '';

    if (typeof accountName === 'string' && accountName.trim()) {
      nameSafe = safe(accountName);
    } else if (accountObj) {
      const n = accountObj.name || accountObj.fullName || accountObj.customer_name;
      if (n) nameSafe = safe(n);
    }

    if (typeof accountEmail === 'string' && accountEmail.trim()) {
      emailSafe = safe(accountEmail);
    } else if (accountObj) {
      const e =
        accountObj.email ||
        accountObj.email_id ||
        accountObj.username ||
        accountObj.userId ||
        accountObj.loginEmail;
      if (e) emailSafe = safe(e);
    }

    if (typeof accountPassword === 'string' && accountPassword.trim()) {
      passwordSafe = safe(accountPassword);
    } else if (accountObj) {
      const p =
        accountObj.password ||
        accountObj.pass ||
        accountObj.loginPassword ||
        accountObj.pin;
      if (p) passwordSafe = safe(p);
    }

    // ğŸ¬ Caption rapi (Markdown)
    const captionLines = [];

    // âœ… HEADER
    captionLines.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    captionLines.push('ğŸ¬ *MOVIE TICKET*');
    captionLines.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    captionLines.push('');

    // ğŸŸï¸ INFO TIKET
    if (bookingCode || passKey || salesId) {
      captionLines.push('ğŸŸï¸ *INFO TIKET*');
      captionLines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      if (bookingCode) captionLines.push(`Booking ID : \`${bookingCode}\``);
      if (passKey)     captionLines.push(`Pass Key   : \`${passKey}\``);
      if (salesId)     captionLines.push(`Sales ID   : \`${salesId}\``);
      captionLines.push('');
    }

    // ğŸ‘¤ Info akun CGV (kalau ada)
    if (nameSafe || emailSafe || passwordSafe) {
      captionLines.push('ğŸ‘¤ *AKUN CGV*');
      captionLines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      if (nameSafe)     captionLines.push(`Nama     : ${nameSafe}`);
      if (emailSafe)    captionLines.push(`Email    : ${emailSafe}`);
      if (passwordSafe) captionLines.push(`Password : ${passwordSafe}`);
      captionLines.push('');
    }

    // âœ… FOOTER
    captionLines.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    captionLines.push('âœ… Scan barcode di pintu masuk');
    captionLines.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

    const textCaption = captionLines.filter(Boolean).join('\n');

    // ğŸ”§ Kalau dimatikan, jangan kirim ke Telegram
    if (!sendToTelegram) {
      console.log(chalk.yellow('ğŸ“µ sendTelegramTicketScreenshot: sendToTelegram = false, skip kirim ke Telegram.'));
      return {
        success        : false,
        skipped        : true,
        reason         : 'sendToTelegram=false',
        filePath,
        bookingCode,
        passKey,
        salesId,
        accountName    : nameSafe || null,
        accountEmail   : emailSafe || null,
        accountPassword: passwordSafe || null
      };
    }

    // --- baru kirim ke Telegram kalau sendToTelegram = true ---

    const fsMod = (globalThis.fs && globalThis.fs.readFile)
      ? globalThis.fs
      : (await import('fs/promises'));
    const buffer = await fsMod.readFile(filePath);
    const path = (await import('path')).default;
    const fileName = path.basename(filePath);

    // Pakai FormData & Blob bawaan Node 18+ (undici)
    const { FormData, Blob } = globalThis;

    const form = new FormData();
    form.append('chat_id', TELEGRAM_CHAT_ID);
    form.append('caption', textCaption);
    form.append('parse_mode', 'Markdown'); // booking/passkey numeric â†’ aman
    form.append('photo', new Blob([buffer], { type: 'image/png' }), fileName);

    const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;
    const res = await fetch(url, { method: 'POST', body: form });

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      console.log(chalk.yellow(`âš ï¸ Telegram sendPhoto failed: ${res.status} ${text}`));
      throw new Error(`Telegram HTTP ${res.status}`);
    }

    console.log(chalk.green('ğŸ“² Telegram sendPhoto success (movie ticket screenshot).'));
    return {
      success        : true,
      telegram       : true,
      filePath,
      bookingCode,
      passKey,
      salesId
    };
  } catch (err) {
    console.log(chalk.yellow(`âš ï¸ sendTelegramTicketScreenshot error: ${err.message}`));
    throw err;
  }
}





async function loginAndScreenshotTicket({
  salesId,
  email,
  password,
  bookingCode,
  passKey,
  outDir = 'orders',
  headless = true,
  sendToTelegram = false,   // ğŸ”§ NEW: ON/OFF kirim ke Telegram
  accountEmail,
  accountPassword,
  accountName,
  movieTitle,
  cinemaName,
  seatsLabel,
  showDate,
  showTime
}) {
  if (!salesId || !email || !password) {
    throw new Error('salesId/email/password wajib diisi');
  }

  // âŒ DULU: nunggu instance browser lain
  // await waitForSameBrowserFree({ label: 'Movie Ticket' });
  // âœ… SEKARANG: langsung jalan tanpa gate

  const puppeteer = (await import('puppeteer')).default;
  const fs = (globalThis.fs && globalThis.fs.writeFile)
    ? globalThis.fs
    : (await import('fs/promises'));
  const path = (globalThis.path && globalThis.path.join)
    ? globalThis.path
    : (await import('path')).default;

  let browser = null;
  let page = null;

  try {
    console.log(chalk.gray('ğŸš€ Launching Puppeteer browser...'));
    
    browser = await puppeteer.launch({
      headless,
      defaultViewport: null,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-blink-features=AutomationControlled',
        '--disable-features=VizDisplayCompositor',
        '--disable-web-security',
        '--no-first-run',
        '--no-default-browser-check',
        '--disable-extensions'
      ]
    });

    // Direct newPage() tanpa incognito context (compatibility fix)
    page = await browser.newPage();
    console.log(chalk.gray('âœ… Browser page created successfully'));

    // Set mobile viewport dan user agent
    console.log(chalk.gray('ğŸ“± Setting up mobile device emulation...'));
    await page.setUserAgent(
      'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) ' +
      'AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 ' +
      'Mobile/15E148 Safari/604.1'
    );
    await page.setViewport({
      width: 390, 
      height: 844, 
      deviceScaleFactor: 3, 
      isMobile: true, 
      hasTouch: true
    });
    console.log(chalk.gray('âœ… Mobile viewport configured: 390x844'));

    // Override webdriver detection
    console.log(chalk.gray('ğŸ”’ Setting up bot detection bypass...'));
    await page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, 'webdriver', {
        get: () => undefined,
      });
      try {
        delete navigator.__proto__.webdriver;
      } catch {}
    });
    console.log(chalk.gray('âœ… Anti-bot detection configured'));

    const detailUrl =
      `https://m.cgv.id/membership/detail_transaction/${encodeURIComponent(String(salesId))}`;
    console.log(chalk.gray(`ğŸŒ Navigating to: ${detailUrl}`));
    
    const startNavTime = Date.now();
    await page.goto(detailUrl, { 
      waitUntil: ['domcontentloaded'], 
      timeout: 60000 
    });
    const navTime = Date.now() - startNavTime;
    console.log(chalk.gray(`âœ… Navigation completed in ${navTime}ms`));

    // Check current URL for debugging
    const currentUrl = page.url();
    console.log(chalk.gray(`ğŸ“ Current URL: ${currentUrl}`));

    // Check login hints (buat debug aja)
    console.log(chalk.gray('ğŸ” Checking login hints...'));
    const loginCheck = await page.evaluate(() => {
      const hasEmailField = !!document.querySelector('#email, input[type="email"], input[placeholder*="email" i]');
      const hasPasswordField = !!document.querySelector('#password, input[type="password"], input[name="password"]');
      const hasLoginButton = !!document.querySelector('button[disabled]');
      const url = location.href;
      const title = document.title || '';
      const bodyText = document.body ? document.body.innerText.substring(0, 500) : '';
      
      return {
        hasEmailField,
        hasPasswordField,
        hasLoginButton,
        url,
        title,
        bodyText
      };
    });
    
    console.log(chalk.gray(`ğŸ“Š Login hints:`));
    console.log(chalk.gray(`   - Email field: ${loginCheck.hasEmailField ? 'âœ…' : 'âŒ'}`));
    console.log(chalk.gray(`   - Password field: ${loginCheck.hasPasswordField ? 'âœ…' : 'âŒ'}`));
    console.log(chalk.gray(`   - Login button: ${loginCheck.hasLoginButton ? 'âœ…' : 'âŒ'}`));
    console.log(chalk.gray(`   - Page title: "${loginCheck.title}"`));
    console.log(chalk.gray(`   - URL: ${loginCheck.url}`));

    console.log(chalk.gray('ğŸ¯ Login mode: FORCE LOGIN (selalu coba login dengan email & password, abaikan hint di atas)'));

    // ==== RETRY LOGIN SAMPAI 3x (FORCE LOGIN) ====
    let loginSuccess = false;

    const emailSelectors = ['#email', 'input[type="email"]', 'input[name="email"]', 'input[placeholder*="email" i]'];
    const passwordSelectors = ['#password', 'input[type="password"]', 'input[name="password"]'];

    for (let loginAttempt = 1; loginAttempt <= 3; loginAttempt++) {
      console.log(chalk.gray(`ğŸ” Login attempt #${loginAttempt}/3 ...`));
    
      console.log(chalk.gray('â³ Waiting for login form elements (fast)...'));

      try {
        await Promise.race(
          emailSelectors.map(sel => page.waitForSelector(sel, { timeout: 8000 }))
        );
        console.log(chalk.gray('âœ… Email field detected (maybe login page).'));
      } catch (selectorError) {
        console.log(chalk.yellow(`âš ï¸ Email field fast-wait timeout: ${selectorError.message}`));
      }

      try {
        await Promise.race(
          passwordSelectors.map(sel => page.waitForSelector(sel, { timeout: 8000 }))
        );
        console.log(chalk.gray('âœ… Password field detected (maybe login page).'));
      } catch (selectorError) {
        console.log(chalk.yellow(`âš ï¸ Password field fast-wait timeout: ${selectorError.message}`));
      }

      async function pickExistingSelector(selectors) {
        for (const sel of selectors) {
          const el = await page.$(sel);
          if (el) return sel;
        }
        return null;
      }

      const emailSel = await pickExistingSelector(emailSelectors);
      const passSel  = await pickExistingSelector(passwordSelectors);

      // Clear dan isi form dengan delay realistis
      console.log(chalk.gray('ğŸ§¹ Clearing existing form values...'));
      await page.evaluate((emailSel, passSel) => {
        const clear = sel => {
          if (!sel) return;
          const el = document.querySelector(sel);
          if (el) el.value = '';
        };
        clear(emailSel);
        clear(passSel);
      }, emailSel, passSel);

      if (emailSel) {
        console.log(chalk.gray(`ğŸ“§ Mengisi email (${emailSel}): ${email}`));
        await page.focus(emailSel);
        await page.keyboard.down('Control'); await page.keyboard.press('A'); await page.keyboard.up('Control');
        await page.keyboard.press('Backspace');
        await page.type(emailSel, String(email), { delay: 50 });
        console.log(chalk.gray('âœ… Email filled'));
      } else {
        console.log(chalk.yellow('âš ï¸ Tidak menemukan field email untuk diisi (mungkin sudah login).'));
      }
      
      if (passSel) {
        console.log(chalk.gray(`ğŸ”‘ Mengisi password (${passSel})...`));
        await page.focus(passSel);
        await page.keyboard.down('Control'); await page.keyboard.press('A'); await page.keyboard.up('Control');
        await page.keyboard.press('Backspace');
        await page.type(passSel, String(password), { delay: 50 });
        console.log(chalk.gray('âœ… Password filled'));
      } else {
        console.log(chalk.yellow('âš ï¸ Tidak menemukan field password untuk diisi (mungkin sudah login).'));
      }
      
      // Trigger validation events
      console.log(chalk.gray('ğŸ”„ Triggering form validation events...'));
      await page.evaluate((emailSel, passSel) => {
        const fire = sel => {
          if (!sel) return;
          const el = document.querySelector(sel);
          if (el) {
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
            el.dispatchEvent(new Event('blur', { bubbles: true }));
          }
        };
        fire(emailSel);
        fire(passSel);
      }, emailSel, passSel);
      console.log(chalk.gray('âœ… Validation events triggered'));

      console.log(chalk.gray('â³ Waiting for form validation...'));
      await delay(400);
      
      console.log(chalk.gray('ğŸ”˜ Mencari dan mengklik tombol login...'));
      
      const loginClickResult = await page.evaluate(() => {
        let loginBtn = null;
        let strategy = '';
        
        const buttons = Array.from(document.querySelectorAll('button'));
        loginBtn = buttons.find(b => /login|masuk/i.test(b.textContent || b.innerText || ''));
        if (loginBtn) strategy = 'text-based';
        
        if (!loginBtn) {
          loginBtn = document.querySelector('button[disabled], .btn.disabled');
          if (loginBtn) strategy = 'disabled-button';
        }
        
        if (!loginBtn) {
          loginBtn = document.querySelector('button[type="submit"], .btn-primary');
          if (loginBtn) strategy = 'submit-button';
        }
        
        if (!loginBtn) {
          loginBtn = document.querySelector('.btn-login, .login-btn, .btn-outline-primary');
          if (loginBtn) strategy = 'class-based';
        }
        
        if (loginBtn) {
          loginBtn.removeAttribute('disabled');
          loginBtn.classList.remove('disabled');
          loginBtn.disabled = false;
          
          const buttonText = loginBtn.textContent || loginBtn.innerText || 'No text';
          loginBtn.click();
          return { success: true, strategy, buttonText };
        }
        return { success: false, strategy: 'none', buttonText: 'Not found' };
      });

      console.log(chalk.gray(`ğŸ“Š Login button click result:`));
      console.log(chalk.gray(`   - Success: ${loginClickResult.success ? 'âœ…' : 'âŒ'}`));
      console.log(chalk.gray(`   - Strategy: ${loginClickResult.strategy}`));
      console.log(chalk.gray(`   - Button text: "${loginClickResult.buttonText}"`));

      if (!loginClickResult.success) {
        console.log(chalk.yellow('âš ï¸ Login button tidak ditemukan, mencoba submit form (Enter)...'));
        try {
          await page.keyboard.press('Enter');
          console.log(chalk.gray('âœ… Enter key pressed as fallback'));
        } catch {}
      }

      console.log(chalk.gray('â³ Menunggu login berhasil / redirect...'));
      const loginWaitStart = Date.now();
      
      await Promise.race([
        page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 60000 }).catch(async () => {
          try { 
            await page.waitForNavigation({ waitUntil: 'networkidle0', timeout: 30000 }); 
          } catch {}
          console.log(chalk.gray('âš ï¸ Navigation timeout during login'));
        }),
        page.waitForFunction(() => !location.href.includes('login'), { timeout: 60000 }).catch(() => {
          console.log(chalk.gray('âš ï¸ Login redirect timeout (maybe already logged).'));
        }),
        delay(8000)
      ]);

      const loginWaitTime = Date.now() - loginWaitStart;
      console.log(chalk.gray(`â±ï¸ Login wait completed in ${loginWaitTime}ms`));

      const postLoginUrl = page.url();
      console.log(chalk.gray(`ğŸ“ Post-login URL: ${postLoginUrl}`));

      const stillOnLogin = /\/login/i.test(postLoginUrl);

      if (!stillOnLogin) {
        console.log(chalk.green('âœ… Login/session dianggap OK (bukan di halaman login lagi)'));
        loginSuccess = true;
      } else {
        console.log(chalk.yellow('âš ï¸ Masih di halaman login, kemungkinan gagal (jaringan / kredensial).'));
      }

      if (loginSuccess) {
        break;
      } else if (loginAttempt < 3) {
        console.log(chalk.yellow('ğŸ”„ Reload login/detail & retry login...'));
        const retryStart = Date.now();
        await page.goto(detailUrl, { 
          waitUntil: ['domcontentloaded'], 
          timeout: 60000 
        });
        const retryTime = Date.now() - retryStart;
        console.log(chalk.gray(`âœ… Reload login/detail done in ${retryTime}ms`));
      } else {
        console.log(chalk.red('âŒ Login gagal setelah 3 percobaan, lanjut dengan kondisi saat ini (mungkin session sudah ada).'));
      }
    } // end for loginAttempt

    // Pastikan di halaman detail transaksi
    const postLoginUrlFinal = page.url();
    if (!/\/membership\/detail_transaction\/\d+/i.test(postLoginUrlFinal)) {
      console.log(chalk.gray('ğŸ”„ Navigasi ke halaman detail transaksi setelah login...'));
      const redirectStart = Date.now();
      await page.goto(detailUrl, { 
        waitUntil: ['domcontentloaded', 'networkidle2'], 
        timeout: 60000 
      });
      const redirectTime = Date.now() - redirectStart;
      console.log(chalk.gray(`âœ… Redirect completed in ${redirectTime}ms`));
    } else {
      console.log(chalk.gray('âœ… Sudah berada di halaman detail transaksi (ticket page).'));
    }

    console.log(chalk.gray('ğŸ” Menunggu halaman detail transaksi dimuat...'));
    
    let pageContent = null;
    let enhancedDetection = null;

    for (let attempt = 1; attempt <= 3; attempt++) {
      console.log(chalk.gray(`ğŸ” Ticket page load attempt #${attempt}/3...`));

      pageContent = await page.evaluate((bk, pk) => {
        const bodyText = document.body ? document.body.innerText : '';
        const lower = bodyText.toLowerCase();
        const hasBooking = bk && bodyText.includes(bk);
        const hasPasskey = pk && bodyText.includes(pk);
        const hasBookingWord = lower.includes('booking');
        const hasPassWord = lower.includes('pass');
        
        return {
          bodyLength: bodyText.length,
          hasBooking,
          hasPasskey,
          hasBookingWord,
          hasPassWord,
          title: document.title || '',
          firstWords: bodyText.substring(0, 200)
        };
      }, String(bookingCode || ''), String(passKey || ''));

      console.log(chalk.gray(`ğŸ“Š Page content analysis:`));
      console.log(chalk.gray(`   - Body text length: ${pageContent.bodyLength} chars`));
      console.log(chalk.gray(`   - Has booking code: ${pageContent.hasBooking ? 'âœ…' : 'âŒ'}`));
      console.log(chalk.gray(`   - Has passkey: ${pageContent.hasPasskey ? 'âœ…' : 'âŒ'}`));
      console.log(chalk.gray(`   - Has "booking" word: ${pageContent.hasBookingWord ? 'âœ…' : 'âŒ'}`));
      console.log(chalk.gray(`   - Has "pass" word: ${pageContent.hasPassWord ? 'âœ…' : 'âŒ'}`));
      console.log(chalk.gray(`   - Page title: "${pageContent.title}"`));
      
      try {
        await page.waitForFunction(
          (bk, pk) => {
            const bodyText = document.body ? document.body.innerText : '';
            const lower = bodyText.toLowerCase();
            const hasBooking = bk && bodyText.includes(bk);
            const hasPass = pk && bodyText.includes(pk);
            return hasBooking || hasPass || lower.includes('booking') || lower.includes('pass');
          },
          { timeout: 15000 },
          String(bookingCode || ''), 
          String(passKey || '')
        );
        console.log(chalk.gray('âœ… Booking/passkey content detected / keyword muncul'));
      } catch {
        console.log(chalk.yellow('âš ï¸ Timeout waiting for booking/passkey keyword.'));
      }

      console.log(chalk.gray('ğŸ” Enhanced element detection for movie ticket...'));
      
      enhancedDetection = await page.evaluate(() => {
        const results = {
          bookingIdElement: null,
          passkeyElement: null,
          salesIdElement: null,
          barcodeElement: null,
          allElementsFound: false
        };
        
        const allNodes = Array.from(document.querySelectorAll('*'));

        const bookingElements = allNodes.filter(el => 
          el.textContent && el.textContent.toUpperCase().includes('BOOKING ID')
        );
        if (bookingElements.length > 0) {
          results.bookingIdElement = {
            found: true,
            text: bookingElements[0].textContent.trim(),
            className: bookingElements[0].className,
            tagName: bookingElements[0].tagName
          };
        }
        
        const passkeyElements = allNodes.filter(el =>
          el.textContent && (
            el.textContent.toUpperCase().includes('PASSKEY') || 
            el.textContent.toUpperCase().includes('PASS KEY')
          )
        );
        if (passkeyElements.length > 0) {
          results.passkeyElement = {
            found: true,
            text: passkeyElements[0].textContent.trim(),
            className: passkeyElements[0].className,
            tagName: passkeyElements[0].tagName
          };
        }
        
        const salesElements = allNodes.filter(el =>
          el.textContent && el.textContent.toUpperCase().includes('SALES ID')
        );
        if (salesElements.length > 0) {
          results.salesIdElement = {
            found: true,
            text: salesElements[0].textContent.trim(),
            className: salesElements[0].className,
            tagName: salesElements[0].tagName
          };
        }
        
        const barcodeImages = Array.from(document.querySelectorAll('img')).filter(img => {
          const alt = (img.alt || '').toLowerCase();
          const src = img.src || '';
          return alt.includes('barcode') || alt.includes('qr') || src.startsWith('data:image');
        });
        if (barcodeImages.length > 0) {
          results.barcodeElement = {
            found: true,
            alt: barcodeImages[0].alt,
            src: barcodeImages[0].src.substring(0, 50) + '...',
            width: barcodeImages[0].width,
            height: barcodeImages[0].height
          };
        }
        
        results.allElementsFound = !!(
          results.bookingIdElement && 
          results.passkeyElement && 
          results.salesIdElement && 
          results.barcodeElement
        );
        
        return results;
      });

      console.log(chalk.gray('ğŸ“Š Enhanced detection results:'));
      console.log(chalk.gray(`   ğŸŸï¸  Booking ID: ${enhancedDetection.bookingIdElement ? 'âœ… Found' : 'âŒ Not found'}`));
      if (enhancedDetection.bookingIdElement) {
        console.log(chalk.gray(`       Text: "${enhancedDetection.bookingIdElement.text}"`));
      }
      
      console.log(chalk.gray(`   ğŸ”‘ Passkey: ${enhancedDetection.passkeyElement ? 'âœ… Found' : 'âŒ Not found'}`));
      if (enhancedDetection.passkeyElement) {
        console.log(chalk.gray(`       Text: "${enhancedDetection.passkeyElement.text}"`));
      }
      
      console.log(chalk.gray(`   ğŸ†” Sales ID: ${enhancedDetection.salesIdElement ? 'âœ… Found' : 'âŒ Not found'}`));
      if (enhancedDetection.salesIdElement) {
        console.log(chalk.gray(`       Text: "${enhancedDetection.salesIdElement.text}"`));
      }
      
      console.log(chalk.gray(`   ğŸ“± Barcode: ${enhancedDetection.barcodeElement ? 'âœ… Found' : 'âŒ Not found'}`));
      if (enhancedDetection.barcodeElement) {
        console.log(chalk.gray(`       Alt: "${enhancedDetection.barcodeElement.alt}"`));
      }
      
      const completeness = enhancedDetection.allElementsFound ? 'âœ… COMPLETE' : 'âš ï¸ PARTIAL';
      console.log(chalk.gray(`   ğŸ¯ Ticket completeness: ${completeness}`));

      const looksGood = enhancedDetection.allElementsFound || pageContent.bodyLength > 200;
      if (looksGood) {
        console.log(chalk.green('âœ… Ticket page looks complete, lanjut screenshot.'));
        break;
      }

      if (attempt < 3) {
        console.log(chalk.yellow('âš ï¸ Ticket page belum lengkap (mungkin jaringan). Reload & coba lagi...'));
        await page.goto(detailUrl, { 
          waitUntil: ['domcontentloaded', 'networkidle2'], 
          timeout: 60000 
        });
        await delay(2000);
      } else {
        console.log(chalk.yellow('âš ï¸ Gagal dapat halaman tiket yang lengkap setelah 3 percobaan, lanjut pakai yang ada.'));
      }
    }

    await appendJsonLog({
      event: 'movie_enhanced_element_detection',
      sales_id: salesId,
      detection_results: enhancedDetection
    });

// Helper: clean string untuk nama file (hapus karakter ilegal, tapi PERTAHANKAN SPASI)
const safeFilename = (s, maxLen = 50) => {
  return String(s || '')
    .replace(/[<>:"\/\\|?*]/g, '')  // Hapus Windows illegal chars
    .substring(0, maxLen);
};

// Format jam: 1830-2020 â†’ 18.30-20.20
const formatTime = (timeStr) => {
  if (!timeStr) return 'NoTime';
  // Handle format: 18:30-20:20 atau 1830-2020
  return timeStr
    .replace(/:/g, '')  // Hapus colon dulu
    .replace(/(\d{2})(\d{2})-(\d{2})(\d{2})/, '$1.$2-$3.$4')  // 1830-2020 â†’ 18.30-20.20
    .replace(/(\d{2})(\d{2})/, '$1.$2');  // fallback untuk single time
};

// Format seats: "F1" â†’ "[F1]", "B5-B6" â†’ "[B5-B6]", "" â†’ "[NoSeats]"
const formatSeats = (seatsStr) => {
  if (!seatsStr || seatsStr.trim() === '') return '[NoSeats]';
  return `[${seatsStr}]`;
};

// Prepare data untuk nama file
const cinemaSafe = safeFilename(cinemaName || 'Cinema', 30);
const movieSafe = safeFilename(movieTitle || 'Movie', 40);
const showTimeSafe = formatTime(showTime || showDate || '');
const seatsSafe = formatSeats(seatsLabel);
const bookingSafe = safeFilename(bookingCode || 'booking', 15);
const passkeySafe = safeFilename(passKey || 'passkey', 10);

// Format nama file yang rapi: Cinema_Movie_[Time]_[Seats]_Booking_Passkey.png
const outName = `${cinemaSafe}_${movieSafe}_[${showTimeSafe}]_${seatsSafe}_${bookingSafe}_${passkeySafe}.png`;




    
    console.log(chalk.gray(`ğŸ“ Creating output directory: ${outDir}`));
    await fs.mkdir(outDir, { recursive: true });
    const outPath = path.join(outDir, outName);
    console.log(chalk.gray(`ğŸ’¾ Output path: ${outPath}`));
    console.log(chalk.gray(`ğŸ’¾ Menyimpan screenshot: ${outName}`));

    console.log(chalk.gray('ğŸ“œ Scrolling to top for full page screenshot...'));
    await page.evaluate(() => window.scrollTo(0, 0));
    await delay(2000);
    console.log(chalk.gray('âœ… Scroll to top completed'));

    console.log(chalk.gray('ğŸ“± Taking full mobile page screenshot...'));
    
    await page.screenshot({ 
      path: outPath, 
      type: 'png', 
      fullPage: true
    });
    
    console.log(chalk.gray('âœ… Full page screenshot completed'));

    try {
      const stats = await fs.stat(outPath);
      console.log(chalk.green(`ğŸ“¸ Screenshot tersimpan: ${outPath} (${Math.round(stats.size/1024)}KB)`));
      console.log(chalk.cyan('ğŸ¯ Screenshot mencakup: Header + Poster + Info + Booking ID + PassKey + Barcode + Sales ID'));
    } catch (statError) {
      console.log(chalk.yellow(`âš ï¸ Could not verify screenshot file: ${statError.message}`));
    }

    // ğŸ§¹ TUTUP BROWSER CEPAT SETELAH SCREENSHOT
    try {
      if (page) {
        console.log(chalk.gray('ğŸ§¹ Closing page (after screenshot)...'));
        await page.close();
        page = null;
        console.log(chalk.gray('ğŸ“± Page closed'));
      }
    } catch {}
    try { 
      if (browser) {
        console.log(chalk.gray('ğŸ§¹ Closing browser (after screenshot)...'));
        await browser.close();
        browser = null;
        console.log(chalk.gray('ğŸš€ Browser closed'));
      }
    } catch {}

    // ğŸ“² Optional: kirim screenshot ke Telegram
    if (sendToTelegram && typeof sendTelegramTicketScreenshot === 'function') {
      try {
        console.log(chalk.gray('ğŸ“² Sending ticket screenshot to Telegram...'));

        const emailForTg = accountEmail || email;
        const passForTg  = accountPassword || password;

        await sendTelegramTicketScreenshot({
          filePath: outPath,
          bookingCode,
          passKey,
          salesId,
          type: 'movie',
          accountName: accountName,
          accountEmail: emailForTg,
          accountPassword: passForTg
          // movie info bisa dikirim lewat fungsi lain / text ticket
        });


        console.log(chalk.green('ğŸ¬ğŸ“± Ticket screenshot sent to Telegram!'));
      } catch (tgErr) {
        console.log(chalk.yellow(`âš ï¸ Gagal kirim screenshot ke Telegram: ${tgErr.message}`));
      }
    } else {
      console.log(chalk.gray(`ğŸ“µ Skip kirim Telegram (sendToTelegram=${sendToTelegram})`));
    }
    
    await appendJsonLog({
      event: 'mobile_screenshot_saved',
      file: outPath,
      url: currentUrl,
      sales_id: salesId,
      booking_code: bookingCode,
      pass_key: passKey,
      login_required: true,           // FORCE LOGIN MODE
      login_hints: loginCheck,
      page_content: pageContent,
      send_telegram: sendToTelegram
    });

    return { success: true, path: outPath };
    
  } catch (e) {
    console.log(chalk.red(`âŒ Screenshot error: ${e.message}`));
    console.log(chalk.gray(`ğŸ” Error stack: ${e.stack}`));
    await appendJsonLog({
      event: 'mobile_screenshot_error',
      error: e.message,
      stack: e.stack,
      sales_id: salesId
    });
    return { success: false, error: e.message };
  } finally {
    // Safety double-close kalau tadi gagal
    try { 
      if (page) {
        console.log(chalk.gray('ğŸ§¹ Closing page (finally)...'));
        await page.close();
        console.log(chalk.gray('ğŸ“± Page closed'));
      }
    } catch {}
    try { 
      if (browser) {
        console.log(chalk.gray('ğŸ§¹ Closing browser (finally)...'));
        await browser.close();
        console.log(chalk.gray('ğŸš€ Browser closed'));
      }
    } catch {}
  }
}






// --- BARCODE (1D) HELPERS ---
async function makeCode128PngBuffer(data, opts = {}) {
  const bwipjs = (await import('bwip-js')).default;
  const buf = await bwipjs.toBuffer({
    bcid: 'code128',           // tipe barcode
    text: String(data || ''),  // data yang di-encode
    scale: opts.scale ?? 3,    // ukuran
    height: opts.height ?? 12, // tinggi bar
    includetext: true,         // tulis teks di bawah barcode
    textxalign: 'center',
  });
  return buf; // Node Buffer (PNG)
}

function base64ImageToBuffer(b64) {
  const clean = String(b64 || '').replace(/^data:image\/\w+;base64,/, '');
  return Buffer.from(clean, 'base64');
}

async function sendTelegramPhotoBuffer(buffer, filename, caption = '', chatId = TELEGRAM_CHAT_ID) {
  const FormData = (await import('form-data')).default;
  const form = new FormData();
  form.append('chat_id', chatId);
  if (caption) {
    form.append('caption', caption.slice(0, 1024));
    form.append('parse_mode', 'HTML');
  }
  form.append('photo', buffer, { filename, contentType: 'image/png' });

  const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;
  const res = await fetch(url, { method: 'POST', body: form, headers: form.getHeaders() });
  const text = await res.text();
  let json = null; try { json = JSON.parse(text); } catch {}
  if (!res.ok) throw new Error(json?.description || `HTTP ${res.status}`);
  return { success: true, response: json };
}

function generateQRCodeUrl(data, size = '200x200') {
  const encodedData = encodeURIComponent(data);
  return `https://api.qrserver.com/v1/create-qr-code/?size=${size}&data=${encodedData}&format=png`;
}


function generateAdvancedQRUrl(data, options = {}) {
  const {
    size = '300x300',
    color = '000000',
    bgcolor = 'ffffff',
    ecc = 'M',
    format = 'png'
  } = options;
  
  const encodedData = encodeURIComponent(data);
  return `https://api.qrserver.com/v1/create-qr-code/?size=${size}&data=${encodedData}&color=${color}&bgcolor=${bgcolor}&ecc=${ecc}&format=${format}`;
}

// ---------- QR CODE HELPERS (untuk 2D QR) ----------
async function sendTelegramBookingQRCode(qrData, caption = '', chatId = TELEGRAM_CHAT_ID) {
  const payload = String(qrData ?? '');

  try {
    // ğŸ¯ UTAMA: Generate BARCODE 1D (Code128) mirip tampilan CGV
    // pastikan sudah: npm install bwip-js
    const bwipModule = await import('bwip-js');
    const bwip = bwipModule.default || bwipModule;

    const png = await bwip.toBuffer({
      bcid: 'code128',        // tipe barcode
      text: payload,          // isi = {BOOKING}{PASSKEY}
      scale: 3,               // ketebalan garis
      height: 15,             // tinggi barcode dalam mm
      includetext: true,      // tulis teks di bawah barcode
      textxalign: 'center',   // teks rata tengah
      textsize: 13,           // ukuran font teks
      textfont: 'Courier'     // font yang supported
    });

    await sendTelegramPhotoBuffer(png, 'ticket_barcode.png', caption, chatId);
    return { success: true, mode: 'barcode' };

  } catch (errBarcode) {
    console.log(chalk.yellow(`âš ï¸ barcode (bwip-js) gagal: ${errBarcode.message}, fallback ke QR 2D`));


    try {
      // ğŸ” FALLBACK 1: tetap bikin QR 2D lokal kalau barcode gagal
      const QRCode = (await import('qrcode')).default;
      const png = await QRCode.toBuffer(payload, {
        errorCorrectionLevel: 'H',
        type: 'png',
        margin: 1,
        scale: 8,
        color: { dark: '#000000', light: '#ffffff' }
      });

      await sendTelegramPhotoBuffer(png, 'ticket_qr.png', caption, chatId);
      return { success: true, mode: 'qr2d' };
    } catch (error) {
      // ğŸ” FALLBACK 2: terakhir, pakai URL generator seperti sebelumnya
      console.log(chalk.yellow(`âš ï¸ qrcode local gagal: ${error.message}, fallback ke url`));
      const qrUrl = generateAdvancedQRUrl(payload, {
        size: '400x400',
        color: '000000',
        bgcolor: 'ffffff',
        ecc: 'H',
        format: 'png'
      });
      const telegramUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;
      const response = await requestJson('POST', telegramUrl, {
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({
          chat_id: chatId,
          photo: qrUrl,
          caption: caption.slice(0, 1024),
          parse_mode: 'HTML'
        })
      });
      return { success: true, mode: 'remote', response };
    }
  }
}




async function sendTelegramMessage(message, parseMode = 'HTML') {
  try {
    const telegramUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
    await requestJson('POST', telegramUrl, {
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        chat_id: TELEGRAM_CHAT_ID,
        text: message.slice(0, 4096),
        parse_mode: parseMode
      })
    });
    return { success: true };
  } catch (error) {
    console.log(chalk.red(`âŒ Telegram failed: ${error.message}`));
    return { success: false, error: error.message };
  }
}

// ---------- TICKET GENERATION ----------
async function generateTicketLayout(ticketData, type = 'movie') {
  const { 
    movieName, duration, rating, cinemaName, format, date, time, 
    auditorium, seats, bookingCode, passKey, salesId
  } = ticketData;
  
  const lines = [];
  const width = 61;
  const center = (text) => {
    const padding = Math.max(0, Math.floor((width - text.length) / 2));
    return ' '.repeat(padding) + text + ' '.repeat(width - text.length - padding);
  };
  
  const safeString = (val) => String(val || '');
  const safeSlice = (val, start, end) => safeString(val).slice(start, end);
  
  lines.push('â•­' + 'â”€'.repeat(width) + 'â•®');
  lines.push('â”‚' + center('MOVIE TICKET DETAIL') + 'â”‚');
  lines.push('â”œ' + 'â”€'.repeat(width) + 'â”¤');
  lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
  
  lines.push('â”‚    ğŸ¬ ' + safeSlice(movieName || 'Movie Title', 0, 54).padEnd(54) + 'â”‚');
  lines.push('â”‚    â±ï¸  ' + `${duration || 0} minutes | ${rating || 'N/A'}`.slice(0, 54).padEnd(54) + 'â”‚');
  lines.push('â”‚    ğŸ¢ ' + `${cinemaName || 'Cinema'} - ${format || '2D'}`.slice(0, 54).padEnd(54) + 'â”‚');
  lines.push('â”‚    ğŸ“… ' + `${date || ''} ${time || ''}`.slice(0, 54).padEnd(54) + 'â”‚');
  lines.push('â”‚    ğŸ­ ' + safeSlice(auditorium || 'Studio', 0, 54).padEnd(54) + 'â”‚');
  lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
  lines.push('â”‚    ğŸŸï¸  ' + `${seats?.length || 1} Ticket : ${seats?.map(s => s.row_name + s.number).join(', ') || 'N/A'}`.slice(0, 54).padEnd(54) + 'â”‚');
  
  lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
  lines.push('â”œ' + 'â”€'.repeat(width) + 'â”¤');
  
  const bookingText = `BOOKING ID          â”‚  PASSKEY`;
  const safeBookingCode = safeString(bookingCode);
  const safePassKey = safeString(passKey);
  const bookingValue = `${safeBookingCode.padEnd(19)} â”‚  ${safePassKey.slice(0, 28)}`;
  
  lines.push('â”‚  ' + bookingText.padEnd(width - 2) + 'â”‚');
  lines.push('â”‚  ' + bookingValue.padEnd(width - 2) + 'â”‚');
  lines.push('â”œ' + 'â”€'.repeat(width) + 'â”¤');
  lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
  
// 2D QR Code data: BOOKING_CODE + PASS_KEY (tanpa pemisah)
const bookingCodeSafe = safeString(bookingCode);
const passKeySafe = safeString(passKey);
const barcodeData = `${bookingCodeSafe}${passKeySafe}`;
const barcodeLines = generateASCIIBarcode(barcodeData);

  
  barcodeLines.forEach(barcode => {
    lines.push('â”‚' + barcode.padEnd(width) + 'â”‚');
  });
  
  lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
  lines.push('â”‚  ' + barcodeData.slice(0, width - 4).padEnd(width - 4) + 'â”‚');
  lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
  lines.push('â•°' + 'â”€'.repeat(width) + 'â•¯');
  
  return lines.join('\n');
}

function generateASCIIBarcode(data) {
  // Generate 2D QR Code ASCII pattern (BOOKING_CODE|PASS_KEY format)
  const safeData = String(data || 'NO_DATA');
  const size = 11; // 11x11 QR pattern
  const qrPattern = [];
  
  // Generate QR-like 2D pattern based on data
  for (let row = 0; row < size; row++) {
    let line = '  ';
    for (let col = 0; col < size; col++) {
      const index = (row * size + col) % safeData.length;
      const charCode = safeData.charCodeAt(index);
      
      // Create QR-like pattern dengan finder patterns di corner
      if ((row < 3 && col < 3) || (row < 3 && col >= size-3) || (row >= size-3 && col < 3)) {
        // Finder pattern (corner squares)
        const isEdge = row === 0 || row === 2 || col === 0 || col === 2 || 
                      row === size-1 || row === size-3 || col === size-1 || col === size-3;
        line += isEdge ? 'â–ˆâ–ˆ' : '  ';
      } else {
        // Data pattern berdasar BOOKING|PASSKEY
        const shouldFill = (charCode + row + col) % 3 !== 0;
        line += shouldFill ? 'â–ˆâ–ˆ' : '  ';
      }
    }
    qrPattern.push(line);
  }
  
  return qrPattern;
}


async function saveTicketAsText(ticketText, filename) {
  try {
    const ordersDir = 'orders';
    try {
      await fs.mkdir(ordersDir, { recursive: true });
    } catch (mkdirError) {
      // Folder already exists, continue
    }
    
    const fullPath = path.join(ordersDir, filename);
    await fs.writeFile(fullPath, ticketText, 'utf-8');
    return { success: true, filename: fullPath };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

function generatePremiumMovieTelegramTicket(movieData) {
  if (!movieData) return null;
  
  const safe = (val) => String(val || '');
  
  let message = `ğŸ¬ <b>MOVIE TICKET DETAIL</b> ğŸ¬\n\n`;
  
  message += `â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“\n`;
  message += `â–“                       â–“\n`;
  message += `â–“  ğŸ­ <b>${safe(movieData.movieName).slice(0,18)}</b>\n`;
  message += `â–“                       â–“\n`;
  message += `â–“  â±ï¸ ${safe(movieData.duration)} minutes | ${safe(movieData.rating)}\n`;
  message += `â–“  ğŸ¢ ${safe(movieData.cinemaName)} - ${safe(movieData.format)}\n`;
  message += `â–“  ğŸ“… ${safe(movieData.date)} ${safe(movieData.time)}\n`;
  message += `â–“  ğŸ­ ${safe(movieData.auditorium)}\n`;
  message += `â–“                       â–“\n`;
  message += `â–“  ğŸ« ${safe(movieData.ticketCount)} Ticket: <b>${safe(movieData.seats)}</b>\n`;
  message += `â–“                       â–“\n`;
  message += `â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“\n\n`;
  
  const bookingId = safe(movieData.bookingCode);
  const passKey = safe(movieData.passKey);
  
  message += `<b>BOOKING ID</b>                    <b>PASSKEY</b>\n`;
  message += `<code>${bookingId}</code>              <code>${passKey}</code>\n\n`;
  
  const barcodeData = bookingId + passKey;
  message += `<pre>`;
  
  const chars = barcodeData.split('').slice(0, 30);
  
  for (let i = 0; i < 3; i++) {
    let line = '';
    chars.forEach((char, idx) => {
      const code = char.charCodeAt(0);
      const num = parseInt(char) || 0;
      
      if (i === 0) {
        line += (code % 2 === 0) ? 'â•‘' : 'â”‚';
      } else if (i === 1) {
        line += (num % 2 === 0) ? 'â•‘' : 'â”‚';
      } else {
        line += ((code + idx) % 2 === 0) ? 'â•‘' : 'â”‚';
      }
      
      if ((idx + 1) % 3 === 0) line += ' ';
    });
    
    message += line.slice(0, 32) + '\n';
  }
  message += `</pre>\n`;
  
  message += `<b>SALES ID ${safe(movieData.salesId)}</b>\n\n`;
  
  message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
  message += `âœ… <b>TICKET CONFIRMED & READY</b>\n`;
  message += `ğŸ’° <b>Total Paid:</b> ${safe(movieData.totalAmount)}\n`;
  message += `ğŸ“ <b>Location:</b> ${safe(movieData.cinemaName)}\n`;
  message += `ğŸ• <b>Show Time:</b> ${safe(movieData.date)} ${safe(movieData.time)}\n`;
  message += `ğŸ“± Present this ticket or passkey at cinema\n`;
  message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
  message += `â° Generated: ${new Date().toLocaleString('id-ID')}`;
  
  return message;
}

// Kirim QR Movie Ticket ke Telegram (BOOKING+PASSKEY)
// sekarang ada opsi sendToTelegram (true/false)
async function sendMovieTicketWithBarcode(movieData, options = {}) {
  if (!movieData) return;

  const { sendToTelegram = false } = options;  // ğŸ”§ konfigurasi kirim Telegram

  const safe = (val) => String(val ?? '').trim();

  // --- core ticket data ---
  const bookingId = safe(
    movieData.bookingCode ??
    movieData.booking_code ??
    movieData.bookingId ??
    movieData.booking
  );
  const passKey = safe(
    movieData.passKey ??
    movieData.pass_key ??
    movieData.passcode
  );
  const salesId = safe(
    movieData.salesId ??
    movieData.sales_id
  );

  // --- deteksi object akun (selectedAccount / account / dst) ---
  const accountObj =
    movieData.account ||
    movieData.orderAccount ||
    movieData.cgvAccount ||
    movieData.selectedAccount ||
    movieData.user ||
    movieData.member ||
    null;

  // nama, email, password bisa dikirim langsung / dari object akun
  const accountNameRaw =
    movieData.accountName ??
    (accountObj && (
      accountObj.name ||
      accountObj.fullName ||
      accountObj.customer_name
    ));

  const accountEmailRaw =
    movieData.accountEmail ??
    movieData.email ??
    (accountObj && (
      accountObj.email ||
      accountObj.email_id ||
      accountObj.username ||
      accountObj.userId ||
      accountObj.loginEmail
    ));

  const accountPasswordRaw =
    movieData.accountPassword ??
    movieData.password ??
    (accountObj && (
      accountObj.password ||
      accountObj.pass ||
      accountObj.loginPassword ||
      accountObj.pin
    ));

  const accountName     = accountNameRaw ? safe(accountNameRaw) : '';
  const accountEmail    = accountEmailRaw ? safe(accountEmailRaw) : '';
  const accountPassword = accountPasswordRaw ? safe(accountPasswordRaw) : '';

  // --- info film / bioskop ---
  const movieName   = safe(movieData.movieName ?? movieData.title ?? movieData.movie_title);
  const duration    = safe(movieData.duration);
  const rating      = safe(movieData.rating);
  const cinemaName  = safe(movieData.cinemaName ?? movieData.theaterName ?? movieData.cinema);
  const format      = safe(movieData.format ?? movieData.movieFormat ?? movieData.screen_type);
  const dateLabel   = safe(movieData.date);
  const timeLabel   = safe(movieData.time);
  const auditorium  = safe(movieData.auditorium ?? movieData.auditorium_name ?? movieData.studio);
  const seats       = safe(
    movieData.seats ??
    (Array.isArray(movieData.seatLabels) ? movieData.seatLabels.join(', ') : '')
  );
  const totalAmount = safe(movieData.totalAmount ?? movieData.total_amount);

  try {
    // 2D QR Code payload: BOOKING_ID + PASSKEY (tanpa pemisah, sama kayak F&B)
    const qrPayload = `${bookingId}${passKey}`;
    console.log(chalk.cyan('\nğŸ“± Preparing MOVIE 2D QR Code (BOOKING+PASSKEY)...'));

    // Kalau kirim ke Telegram dimatikan â†’ cuma log & retur
    if (!sendToTelegram) {
      console.log(chalk.yellow('ğŸ“µ sendMovieTicketWithBarcode: sendToTelegram = false, skip kirim ke Telegram.'));
      return {
        success   : false,
        skipped   : true,
        reason    : 'sendToTelegram=false',
        qrPayload,
        bookingId,
        passKey,
        salesId
      };
    }

    console.log(chalk.cyan('ğŸ“± Sending MOVIE 2D QR Code to Telegram...'));

    // Caption lengkap (HTML)
    let caption = '';

    // âœ… HEADER
    caption += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
    caption += `ğŸ¬ <b>MOVIE TICKET QR CODE</b>\n`;
    caption += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;

    // ğŸ¬ INFO FILM
    caption += `ğŸ¬ <b>INFO FILM</b>\n`;
    caption += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
    caption += `Movie    : ${movieName || '-'}\n`;
    caption += `Duration : ${duration || '-'} min | ${rating || '-'}\n`;
    caption += `Cinema   : ${cinemaName || '-'}${format ? ' - ' + format : ''}\n`;
    caption += `Date     : ${dateLabel || '-'} ${timeLabel || ''}\n`;
    caption += `Studio   : ${auditorium || '-'}\n`;
    caption += `Seats    : ${seats || '-'}\n\n`;

    // ğŸŸï¸ INFO TIKET
    caption += `ğŸŸï¸ <b>INFO TIKET</b>\n`;
    caption += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
    caption += `Booking  : <code>${bookingId}</code>\n`;
    caption += `Passkey  : <code>${passKey || '-'}</code>\n`;
    if (salesId) {
      caption += `Sales ID : <code>${salesId}</code>\n`;
    }
    caption += `Total    : ${totalAmount || '-'}\n\n`;

    // ğŸ‘¤ Info akun CGV (nama + email + password)
    if (accountName || accountEmail || accountPassword) {
      caption += `ğŸ‘¤ <b>AKUN CGV</b>\n`;
      caption += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      if (accountName) {
        caption += `Nama     : ${accountName}\n`;
      }
      caption += `Email    : ${accountEmail || '-'}\n`;
      if (accountPassword) {
        caption += `Password : ${accountPassword}\n`;
      }
      caption += `\n`;
    }

    // âœ… FOOTER
    caption += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
    caption += `âœ… <b>SCAN QR AT CINEMA ENTRANCE</b>\n`;
    caption += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;

    // Kirim QR Code sebagai gambar
    const qrResult = await sendTelegramBookingQRCode(qrPayload, caption);
    
    if (qrResult.success) {
      console.log(chalk.green('ğŸ¬ğŸ“± Movie 2D QR Code sent to Telegram!'));
      return { success: true, telegram: true };
    }
    
    // Fallback: kirim sebagai text jika QR gagal
    console.log(chalk.yellow('âš ï¸ QR Code gagal, mengirim text version...'));
    const textTicket = generatePremiumMovieTelegramTicket({
      ...movieData,
      accountName,
      accountEmail,
      accountPassword,
      salesId
    });
    await sendTelegramMessage(`ğŸ“„ <b>MOVIE TICKET (TEXT):</b>\n\n${textTicket}`);
    return { success: true, telegram: true, fallback: 'text' };
    
  } catch (error) {
    console.log(chalk.yellow(`âš ï¸ QR Code failed, sending text version only: ${error.message}`));
    if (sendToTelegram) {
      const textTicket = generatePremiumMovieTelegramTicket({
        ...movieData,
        accountName,
        accountEmail,
        accountPassword,
        salesId
      });
      await sendTelegramMessage(textTicket);
      return { success: true, telegram: true, fallback: 'text-only' };
    }
    return { success: false, telegram: false, error: error.message };
  }
}






  function idNum(n){ try { return Number(n).toLocaleString('id-ID'); } catch { return String(n??'-'); } }


  function getRandomUA() {
    const seeds = [
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/124.0 Safari/537.36',
      'Mozilla/5.0 (Linux; Android 13; Pixel 6) AppleWebKit/537.36 Chrome/124.0 Mobile Safari/537.36',
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 14_5) AppleWebKit/605.1.15 Version/17.4 Safari/605.1.15',
    ];
    return seeds[Math.floor(Math.random()*seeds.length)];
  }
  function getRandomLang(){ return Math.random() < 0.85 ? 'id-ID,id;q=0.9' : 'en-US,en;q=0.9'; }
  function generateRandomHeaders(extra={}) {
    return {
      accept: 'application/json, text/plain, */*',
      'accept-encoding': 'gzip',
      'user-agent': getRandomUA(),
      'accept-language': getRandomLang(),
      ...extra,
    };
  }
  function getRandomProxy(){ return undefined; }

  const safe = (x, d='-') => (x==null || x==='') ? d : x;
  const toRp = (n)=>`Rp${(Number(n)||0).toLocaleString('id-ID')}`;
  const todayYmd = ()=> {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    return `${y}${m}${dd}`;
  };
  const todayFormatted = ()=> {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${dd}`;
  };
  function maskToken(tok){ if(!tok) return ''; return tok.slice(0,6)+'â€¦'+tok.slice(-6); }

  function multilineBox(lines) {
    const w = Math.max(...lines.map(l=>stripAnsi(l).length));
    const top = 'â•­' + 'â”€'.repeat(w+2) + 'â•®';
    const bot = 'â•°' + 'â”€'.repeat(w+2) + 'â•¯';
    const body = lines.map(l=>'â”‚ ' + l + ' '.repeat(w - stripAnsi(l).length) + ' â”‚');
    return [top, ...body, bot].join('\n');
  }
  function normalize(s){ return String(s || '').trim().toLowerCase(); }
  function includesIgnoreCase(haystack, needle){
    return normalize(haystack).includes(normalize(needle));
  }
  function isB1G1(name){
    return /b1g1/i.test(name) || /buy\s*1\s*get\s*1/i.test(name);
  }
  function includesWord(haystack, word){
    try { return new RegExp(`\\b${word}\\b`, 'i').test(haystack||''); } catch { return includesIgnoreCase(haystack, word); }
  }

  // --- HTML entity decoder ---
  function htmlDecode(input) {
    const s = String(input || '');
    return s
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&#x2F;/g, '/')
      .replace(/&#(\d+);/g, (_,n)=>String.fromCharCode(Number(n)))
      .replace(/&#x([0-9a-fA-F]+);/g, (_,h)=>String.fromCharCode(parseInt(h,16)));
  }

  // ---------- BEARER ENSURE ----------
  async function readAccountsFromJson(path) {
    try {
      const raw = await fs.readFile(path,'utf-8');
      const j = JSON.parse(raw);
      const items = Array.isArray(j?.items) ? j.items : [];
      return items.filter(it => it?.email);
    } catch { return []; }
  }
  async function ensureBearerForAccount(acc) {
    const bearer = acc?.bearer;
    if (bearer) return { ok:true, token: bearer, source:'account.json' };

    if (typeof globalThis.loginWithSmartRetry === 'function' && acc?.password) {
      const res = await globalThis.loginWithSmartRetry(acc.email, [acc.password]);
      if (res?.ok && res?.res?.token) return { ok:true, token: res.res.token, source:'login' };
      return { ok:false, reason: res?.res?.message || 'Login gagal' };
    }
    return { ok:false, reason: 'Bearer tidak tersedia & login helper tidak ada.' };
  }

  // ---------- GENERIC REQUEST (logs raw â†’ log.json) ----------
  function redactHeaders(h){
    const out = { ...(h||{}) };
    if (out.Authorization) out.Authorization = `Bearer ${maskToken(String(out.Authorization).replace(/^Bearer\s+/i,''))}`;
    if (out.authorization) out.authorization = `Bearer ${maskToken(String(out.authorization).replace(/^Bearer\s+/i,''))}`;
    return out;
  }
  async function requestJson(method, url, { headers={}, body, note='' } = {}) {
    const hdrs = generateRandomHeaders(headers);
    let status = 0;
    let text = '';
    let json = null;
    try {
      const res = await fetch(url, {
        method,
        headers: hdrs,
        body,
        ...proxyFetchOpts(),   // â† inject proxy runtime di sini
      });
      status = res.status;
      if (note) log.http(method, url, status, note);
      try { text = await res.text(); } catch { text = ''; }
      try { json = text ? JSON.parse(text) : null; } catch { json = null; }
      await appendJsonLog({
        http: { method, url, status },
        request: { headers: redactHeaders(hdrs), body: (typeof body==='string' && body.length<2048) ? body : (body? '[[binary or long body]]' : '') },
        response: { text: text?.slice?.(0, 100000) }
      });
      return { json, status, text };
    } catch (e) {
      await appendJsonLog({
        http: { method, url, status: 0 },
        request: { headers: redactHeaders(hdrs), body: (typeof body==='string' && body.length<2048) ? body : (body? '[[binary or long body]]' : '') },
        response: { error: String(e?.message||e) }
      });
      log.error(`${method} ${url} failed: ${e.message}`);
      return { json: null, status: 0, text: '', error: e };
    }
  }


  // ---------- API WRAPPERS ----------
  async function fetchMoviesPlaying(locationId, token) {
    const url = `${baseURL}/api/movies/playing?location_id=${encodeURIComponent(locationId)}`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: [] };
  }
  async function fetchMoviesUpcoming(locationId, token) {
    const url = `${baseURL}/api/movies/upcoming?location_id=${encodeURIComponent(locationId)}`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: [] };
  }
  const ENHANCED_CINEMA_CACHE = { at: 0, list: [], byLocation: new Map() };
  async function fetchEnhancedCinemaList(token) {
    const TTL = 12 * 60 * 60 * 1000; // 12 jam
    if (ENHANCED_CINEMA_CACHE.list.length && Date.now() - ENHANCED_CINEMA_CACHE.at < TTL) {
      return ENHANCED_CINEMA_CACHE.list;
    }
    const url = `${baseURL}/api/cinemas`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    try {
      if (json?.status_code === 200 && Array.isArray(json?.data)) {
        const byLocation = new Map();
        json.data.forEach(cinema => {
          const locationId = cinema.location_id;
          if (!byLocation.has(locationId)) {
            byLocation.set(locationId, {
              location_id: locationId,
              location_name: cinema.location_name,
              cinemas: []
            });
          }
          byLocation.get(locationId).cinemas.push({
            id: cinema.id,
            name: cinema.name,
            address: cinema.address,
            distance: cinema.distance,
            is_favorite: cinema.is_favorite,
            has_hotspot: cinema.has_hotspot,
            auditorium_types: cinema.auditoriumTypes || []
          });
        });
        ENHANCED_CINEMA_CACHE.list = json.data;
        ENHANCED_CINEMA_CACHE.byLocation = byLocation;
        ENHANCED_CINEMA_CACHE.at = Date.now();
        return json.data;
      }
      return [];
    } catch (e) {
      log.error(`fetchEnhancedCinemaList error: ${e.message}`);
      return ENHANCED_CINEMA_CACHE.list;
    }
  }
  async function getAvailableLocations(token) {
    await fetchEnhancedCinemaList(token);
    return Array.from(ENHANCED_CINEMA_CACHE.byLocation.values())
      .sort((a, b) => a.location_name.localeCompare(b.location_name));
  }
  async function fetchMovieDetail(movieId, token) {
    const url = `${baseURL}/api/movies/${encodeURIComponent(movieId)}`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }
  async function fetchMovieSchedules(movieId, locationId, dateYmd, token) {
    const url = `${baseURL}/api/movies/${encodeURIComponent(movieId)}/schedules?location_id=${encodeURIComponent(locationId)}&date=${encodeURIComponent(dateYmd)}`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: { cinemas: [] } };
  }
  async function fetchSeats(scheduleId, token) {
    const url = `${baseURL}/api/movie-schedules/${encodeURIComponent(scheduleId)}/seats`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: { rows: [] } };
  }
  async function bookSeats(payload, token) {
    const url = `${baseURL}/api/seats/book`;
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': 'application/json' },
      body: JSON.stringify(payload),
      note: `payload: ${JSON.stringify({ ...payload, seats: (payload.seats||[]).map(s=>({id:s.id})) })}`
    });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }
  async function fetchPaymentMethods(token) {
    const url = `${baseURL}/api/payments`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: [] };
  }
  function buildMultipartBody(fields) {
    const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
    const parts = [];
    Object.entries(fields||{}).forEach(([k,v])=>{
      const val = String(v ?? '');
      parts.push(`--${boundary}`);
      parts.push(`Content-Disposition: form-data; name="${k}"`);
      parts.push(`Content-Length: ${val.length}`);
      parts.push('');
      parts.push(val);
    });
    parts.push(`--${boundary}--`);
    const body = parts.join('\r\n');
    return { body, boundary };
  }
  async function cancelOrder(orderId, token) {
    const url = `${baseURL}/api/orders/cancel`;
    const { body, boundary } = buildMultipartBody({ order_id: String(orderId) });
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': `multipart/form-data; boundary=${boundary}` },
      body,
      note: `form: order_id=${orderId}`
    });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }

  // --- Member Info (untuk ambil voucher GIFT dari ds_GFT_LIST) ---
  async function getMemberInfo(token){
    const url = `${baseURL}/api/membership/info`;
    const { body, boundary } = buildMultipartBody({}); // POST dengan empty FormData seperti fullkode.js
    const { json } = await requestJson('POST', url, {
      headers: {
        Authorization: `Bearer ${token}`,
        'content-type': `multipart/form-data; boundary=${boundary}`
      },
      body,
      note: 'getMemberInfo (vouchers)'
    });
    return json || { status_code: 500, message: 'Invalid JSON', RESULTS: null };
  }

  // --- Coupons endpoints ---
  async function couponSelect(orderId, token){
    const url = `${baseURL}/api/orders/coupon/select`;
    const payload = { ...APP_CHANNEL, order_id: Number(orderId) };
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': 'application/json' },
      body: JSON.stringify(payload),
      note: `payload: ${JSON.stringify(payload)}`
    });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }
  async function couponValidate(orderId, discount_code, coupon_number, token){
    const url = `${baseURL}/api/orders/coupon/validate`;
    const payload = { ...APP_CHANNEL, order_id: Number(orderId), coupon_number: coupon_number||'', discount_code: discount_code||'' };
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': 'application/json' },
      body: JSON.stringify(payload),
      note: `payload: ${JSON.stringify(payload)}`
    });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }
  async function couponPay(orderId, discount_code, coupon_number, token){
    const url = `${baseURL}/api/orders/coupon/pay`;
    const payload = { ...APP_CHANNEL, order_id: Number(orderId), coupon_number: coupon_number||'', discount_code: discount_code||'' };
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': 'application/json' },
      body: JSON.stringify(payload),
      note: `payload: ${JSON.stringify(payload)}`
    });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }

  // --- Gift Voucher (E-Voucher) ---
  async function voucherSelect(orderId, voucherNumber, token){
    const url = `${baseURL}/api/orders/voucher/select`;
    const payload = { order_id: Number(orderId), vouchers: [{ number: voucherNumber }] };
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': 'application/json' },
      body: JSON.stringify(payload),
      note: `payload: ${JSON.stringify(payload)}`
    });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }
  async function voucherValidate(orderId, voucherNumber, token){
    const url = `${baseURL}/api/orders/voucher/validate`;
    const payload = { order_id: Number(orderId), vouchers: [{ number: voucherNumber }] };
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': 'application/json' },
      body: JSON.stringify(payload),
      note: `payload: ${JSON.stringify(payload)}`
    });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }
  async function voucherPay(orderId, voucherNumber, token, memberInfo){
    const url = `${baseURL}/api/orders/voucher/pay`;
    const payload = {
      order_id: Number(orderId),
      vouchers: [{ number: voucherNumber }],
      member_grade_id: memberInfo?.grade_id || '02',
      member_tier_id: memberInfo?.tier_id || '02'
    };
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': 'application/json' },
      body: JSON.stringify(payload),
      note: `payload: ${JSON.stringify(payload)}`
    });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }

  // --- Payment Partners ---
  async function paymentPartnerSelect(orderId, categoryId, paymentId, token, extraFields = {}){
    const url = `${baseURL}/api/orders/payment-partners/select`;
    const fields = {
      order_id: String(orderId),
      category_id: String(categoryId),
      payment_id: String(paymentId),
      ...extraFields
    };
    const { body, boundary } = buildMultipartBody(fields);
    
    // Retry mechanism for payment partner select
    let lastError = null;
    for (let attempt = 1; attempt <= 3; attempt++) {
      const { json, status } = await requestJson('POST', url, {
        headers: { Authorization: `Bearer ${token}`, 'content-type': `multipart/form-data; boundary=${boundary}` },
        body,
        note: `form: ${Object.entries(fields).map(([k,v])=>`${k}=${v}`).join(', ')} (attempt ${attempt})`
      });
      
      if (status === 200 && json) {
        if (json.status_code === 200) return json;
        lastError = json;
        if (attempt < 3) {
          console.log(chalk.yellow(`âš ï¸  Payment partner select attempt ${attempt} status_code=${json.status_code}, retrying in 2s...`));
          await delay(2000);
          continue;
          }
        return json;
      } else if (status >= 500 || status === 0) {
        lastError = json;
        if (attempt < 3) {
          console.log(chalk.yellow(`âš ï¸  Payment partner select attempt ${attempt} failed (${status}), retrying in 2s...`));
          await delay(2000);
        }
      } else {
        return json || { status_code: status, message: 'Request failed', data: null };
      }
    }
    
    return lastError || { status_code: 500, message: 'Max retries reached', data: null };
  }
  async function paymentPartnerPay(orderId, token){
    const url = `${baseURL}/api/orders/payment-partners/pay`;
    const { body, boundary } = buildMultipartBody({ order_id: String(orderId) });
    
    // Retry mechanism for payment partner pay
    let lastError = null;
    for (let attempt = 1; attempt <= 3; attempt++) {
      const { json, status } = await requestJson('POST', url, {
        headers: { Authorization: `Bearer ${token}`, 'content-type': `multipart/form-data; boundary=${boundary}` },
        body,
        note: `form: order_id=${orderId} (attempt ${attempt})`
      });
      
      if (status === 200 && json) {
        if (json.status_code === 200) return json;
        lastError = json;
        if (attempt < 3) {
          console.log(chalk.yellow(`âš ï¸  Payment partner select attempt ${attempt} status_code=${json.status_code}, retrying in 2s...`));
          await delay(2000);
          continue;
          }
        return json;
      } else if (status >= 500 || status === 0 || (json?.message && /timeout|timed out/i.test(json.message))) {
        lastError = json;
        if (attempt < 3) {
          console.log(chalk.yellow(`âš ï¸  Payment init attempt ${attempt} failed (${status}), retrying in 3s...`));
          await delay(3000);
        }
      } else {
        return json || { status_code: status, message: 'Request failed', data: null };
      }
    }
    
    return lastError || { status_code: 500, message: 'Max retries reached after timeout', data: null };
  }

  // --- Order & Transactions Monitoring ---
  async function fetchOrderDetail(orderId, token){
    const url = `${baseURL}/api/orders/${encodeURIComponent(orderId)}`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }
  async function fetchMembershipTransactions(token){
    const url = `${baseURL}/api/membership/transactions`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: [] };
  }

  
  // Cari transaksi Movie yang paling match dengan sesi kita barusan
  function pickRelevantTransaction(txList=[], ctx={}, { preferComplete = true } = {}){
    const {
      completeDate,                  // string "YYYY-MM-DD HH:mm:ss" dari order.complete_date
      movieName,                     // selectedMovie.name
      movieDateYmd,                  // "YYYYMMDD" (dateYmd)
      cinemaName,                    // selectedCinema.name
      ticketCount,                   // seatsPick.length
      totalAmount                    // od.total_amount
    } = ctx;
    const toMs = (s)=> s ? new Date(s.replace(' ', 'T')).getTime() : 0;
    const targetMs = toMs(completeDate);
    const targetDate = movieDateYmd ? `${movieDateYmd.slice(0,4)}-${movieDateYmd.slice(4,6)}-${movieDateYmd.slice(6,8)}` : null;

    // filter: hanya Movie & status sesuai preferensi (1=complete, 0=aktif)
    const cand = txList.filter(t =>
      (t?.type === 'Movie') &&
      (Number(t?.is_complete) === (preferComplete ? 1 : 0))
      );

    // beri skor
    const scored = cand.map(t => {
      let score = 0;
      if (movieName && (t.name||'').toLowerCase().includes(movieName.toLowerCase())) score += 40;
      if (cinemaName && (t.cinema_name||'').toLowerCase().includes((cinemaName||'').toLowerCase())) score += 15;
      if (targetDate && t.movie_date === targetDate) score += 20;
      if (ticketCount && Number(t.qty) === Number(ticketCount)) score += 10;
      if (totalAmount && Number(t.amount) <= Number(totalAmount)) score += 5; // kadang amount setelah diskon
      const dtMs = toMs(t.transaction_date_time);
      if (targetMs && dtMs) {
        const diff = Math.abs(dtMs - targetMs);
        // makin dekat makin tinggi
        if (diff < 60_000) score += 30;
        else if (diff < 3*60_000) score += 20;
        else if (diff < 10*60_000) score += 10;
      }
      return { t, score };
    });

    scored.sort((a,b)=> b.score - a.score || toMs(b.t.transaction_date_time) - toMs(a.t.transaction_date_time));
    return scored[0]?.t || null;
  }
  async function fetchPaymentDetail(categoryId, paymentId, token){
    const url = `${baseURL}/api/payments/detail?category_id=${encodeURIComponent(categoryId)}&payment_id=${encodeURIComponent(paymentId)}`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }

  // --- Voucher checking helper ---
  function getVoucherDataFromAccount(acc) {
    const visits = Number(acc.visits || 0);
    const lastTxnDate = acc.last_movie_date || acc.last_txn_date || '-';
    const isToday = lastTxnDate === todayFormatted();
    
    // Check TELKOMSEL 10K dari voucher_details
    const vouchers = acc.voucher_details || [];
    const hasTsel10K = vouchers.some(v => 
      v.is_active_unused && 
      /telkomsel.*10k.*flatprice/i.test(v.name || '')
    );
    
    // Ambil status dari account.json
    const has1stVisit = acc.popcorn_1st_visit_status === 'YES';
    const hasComboSolo = acc.combo_solo_status === 'YES';
    const has3rdVisit = acc.third_visit_b1g1_status === 'YES';
    
    return {
      visits,
      lastTxnDate,
      isToday,
      has1stVisit,
      hasComboSolo, 
      has3rdVisit,
      hasTsel10K,
      activeVouchersCount: acc.voucher_count_active || 0,
      totalVouchersCount: acc.voucher_count || 0
    };
  }

  function formatMovieInfo(movie) {
    const duration = movie.duration ? `${movie.duration} min` : 'TBA';
    return {
      id: movie.id,
      name: movie.name,
      duration,
      rating: movie.censor_rating || 'TBC',
      genre: movie.genre || 'Unknown',
      openDate: movie.opening_date || 'TBA',
      watchlist: movie.watchlist_count || 0,
      score: movie.review_score || movie.golden_egg || 0,
      type: movie.type,
      auditoriums: movie.auditoriums || []
    };
  }

  // ---------- FUZZY CITY MATCH ----------
  function cityScore(hay, needle) {
    hay = normalize(hay); needle = normalize(needle);
    if (!needle) return 0;
    if (hay === needle) return 100;
    if (hay.includes(needle)) return 90;
    if (hay.startsWith(needle)) return 80;
    const hTok = new Set(hay.split(/\s+/));
    const nTok = new Set(needle.split(/\s+/));
    let overlap = 0;
    nTok.forEach(t=>{ if (hTok.has(t)) overlap++; });
    return overlap * 10;
  }
  function findCityCandidates(locations, input) {
    const scored = locations.map(loc => ({
      score: cityScore(loc.location_name, input),
      loc
    })).filter(x => x.score > 0);
    scored.sort((a,b)=> b.score - a.score || a.loc.location_name.localeCompare(b.loc.location_name));
    return scored.map(x => x.loc);
  }

  // ---------- TABLE RENDER ----------
  function renderAccountTable(accounts) {
    const t = new CliTable({
      head: ['#','Email','Phone','Visits','LastTxn','1stPop','ComboSolo','3rdB1G1','Tsel10K','Vouchers'],
      wordWrap: true,
      style: { head: ['green'] },
      colWidths: [4, 30, 16, 8, 12, 8, 10, 8, 8, 10]
    });

    accounts.forEach((acc, i) => {
      const vData = getVoucherDataFromAccount(acc);
      const visitColor = vData.isToday ? chalk.green(String(vData.visits || 0)) : chalk.red(String(vData.visits || 0));
      const txnColor = vData.isToday ? chalk.green(vData.lastTxnDate || '-') : chalk.red(vData.lastTxnDate || '-');
      
      t.push([
        i+1,
        acc.email,
        acc.phone || '-',
        visitColor,
        txnColor,
        vData.has1stVisit ? chalk.green('YES') : chalk.red('NO'),
        vData.hasComboSolo ? chalk.green('YES') : chalk.red('NO'),
        vData.has3rdVisit ? chalk.green('YES') : chalk.red('NO'),
        vData.hasTsel10K ? chalk.green('YES') : chalk.red('NO'),
        `${vData.activeVouchersCount}/${vData.totalVouchersCount}`
      ]);
    });
    console.log(t.toString());
  }

  function renderCinemaTable(cinemas) {
    const t = new CliTable({
      head: ['#','Cinema Name','Address'],
      wordWrap: true,
      style: { head: ['cyan'] },
      colWidths: [4, 30, 60]
    });

    cinemas.forEach((cinema, i) => {
      t.push([
        i+1,
        cinema.name,
        cinema.address || '-'
      ]);
    });
    console.log(t.toString());
  }

  function renderMoviesTable(movies, type = 'PLAYING') {
    const t = new CliTable({
      head: ['#','Movie Title','Genre','Duration','Rating','Score','Watchlist'],
      wordWrap: true,
      style: { head: type === 'PLAYING' ? ['green'] : ['cyan'] },
      colWidths: [4, 45, 12, 10, 8, 7, 10]
    });
    movies.forEach((m,i)=>{
      t.push([
        i+1,
        m.name,
        m.genre,
        m.duration,
        m.rating,
        m.score ? String(m.score) : '-',
        idNum(m.watchlist)
      ]);
    });
    console.log(t.toString());
  }

  function renderSchedulesTable(flatList) {
    const t = new CliTable({
      head: ['#','Start','End','Cinema','Audi','Type','Format','Sisa/Tot','Harga'],
      wordWrap: true,
      style: { head: ['yellow'] },
      colWidths: [4, 8, 8, 16, 10, 10, 8, 10, 14]
    });
    flatList.forEach((s,i)=>{
      t.push([
        i+1,
        s.start_time,
        s.end_time,
        s.cinema_name,
        s.auditorium_name,
        s.movie_type_name,
        s.movie_format,
        `${idNum(s.remaining)}/${idNum(s.total)}`,
        s.price || '-'
      ]);
    });
    console.log(t.toString());
  }

function renderSeatMap(seatRes, chosenIds = new Set()) {
  const rows = seatRes?.data?.rows || [];
  const lines = [];
  const rowInfo = new Map();

  // ========== HITUNG INFO PER BARIS ==========
  rows.forEach(r => {
    const seats = r.seats || [];
    const rowLabel = seats.find(s => s?.row_name)?.row_name;
    if (rowLabel) {
      let totalSeats = 0;
      let availSeats = 0;
      const seatNumbers = [];
      seats.forEach(s => {
        if (s.is_seat) {
          totalSeats++;
          seatNumbers.push(s.number || '?');
          if (s.is_available) availSeats++;
        }
      });
      const seatRange = seatNumbers.length > 0 ?
        `${seatNumbers[0]}-${seatNumbers[seatNumbers.length - 1]}` : '-';
      rowInfo.set(rowLabel, { total: totalSeats, avail: availSeats, range: seatRange });
    }
  });

  let avail = 0, total = 0;
  const seatLines = [];

  // ========== BANGUN BARIS KURSI (TANPA HEADER DULU) ==========
  rows.forEach(r => {
    const seats = r.seats || [];
    const rowLabel = seats.find(s => s?.row_name)?.row_name || ' ';
    let line = rowLabel + ' ';

    seats.forEach(s => {
      if (!s.is_seat) {
        line += '    '; // 4 spaces untuk non-seat (konsisten dengan spacing kursi)
        return;
      }

      total++;
      if (s.is_available) avail++;

      // Ambil nomor kursi dan format
      const seatNum = String(s.number || '?');

      // Tentukan display berdasarkan status dan nomor
      let display = '';
      if (!s.is_available) {
        display = 'â– â– '; // Terisi (2 char untuk konsisten dengan nomor 2 digit)
      } else if (chosenIds.has(s.id)) {
        display = 'â—â—'; // Dipilih (2 char)
      } else {
        // Tampilkan nomor kursi dengan format konsisten
        if (seatNum.length === 1) {
          display = ` ${seatNum}`; // " 1", " 2", " 3", dll (2 char total)
        } else if (seatNum.length === 2) {
          display = seatNum; // "10", "11", "12", dll (2 char)
        } else {
          display = 'â–¡â–¡'; // Fallback untuk nomor sangat panjang
        }
      }

      // Add display dengan spacing konsisten (4 char total per seat)
      line += display + '  ';
    });

    seatLines.push(line);
  });

  // ========== HITUNG LEBAR GRID & CENTER TEKS "LAYAR" ==========
  const screenLabel = 'L A Y A R';
  const maxSeatLineLen = seatLines.reduce((m, s) => Math.max(m, s.length), 0);
  const width = Math.max(maxSeatLineLen, screenLabel.length);

  const padTotal = width - screenLabel.length;
  const padLeft = Math.floor(padTotal / 2);
  const padRight = padTotal - padLeft;

  // Header dan garis atas/bawah seatmap
  lines.push(chalk.gray(' '.repeat(padLeft) + screenLabel + ' '.repeat(padRight)));
  lines.push(chalk.gray('â”ˆ'.repeat(width)));

  // Tambah semua baris kursi
  lines.push(...seatLines);

  // Garis bawah seatmap
  lines.push(chalk.gray('â”ˆ'.repeat(width)));

  // ========== INFO PER BARIS & LEGEND ==========
  if (rowInfo.size > 0) {
    lines.push('');
    lines.push(chalk.cyan('ğŸ“ Info Kursi per Baris:'));
    Array.from(rowInfo.entries())
      .sort(([a], [b]) => b.localeCompare(a))
      .forEach(([row, info]) => {
        const status = info.avail === info.total ? chalk.green('KOSONG')
          : info.avail === 0 ? chalk.red('PENUH')
          : chalk.yellow(`${info.avail}/${info.total}`);
        lines.push(`${row}: ${status} (No.${info.range})`);
      });
    lines.push('');
    lines.push(chalk.gray('Legend: â—â— = Dipilih, 1-99 = Nomor Kursi, â–¡â–¡ = Kursi Khusus, â– â–  = Terisi'));
  }

  const box = multilineBox(lines);
  console.log(box);
  return { avail, total };
}



  function renderPaymentMethodsTable(payData) {
    const t = new CliTable({
      head: ['Kategori','Metode (aktif saja)'],
      wordWrap: true,
      style: { head: ['magenta'] },
      colWidths: [24, 70]
    });
    (payData?.data||[]).forEach(cat=>{
      const active = (cat.items||[]).filter(it=>it.status).map(it=>it.name).join(', ') || '-';
      t.push([cat.name, active]);
    });
    console.log(t.toString());
  }

function renderCouponsTable(coupons = []) {
  const t = new CliTable({
    head: ['#', 'Discount Code', 'Type', 'Name'],
    wordWrap: true,
    style: { head: ['blue'] },
    colWidths: [4, 16, 14, 70] // type dibikin sedikit lebih lebar
  });

  coupons.forEach((c, i) => {
    // Discount code: pakai apa pun yang ada
    const discountCode =
      c.discount ||
      c.number   ||
      c.code     ||
      '-';

    // Deteksi asal: coupon vs gift
    const kindRaw  = String(c.kind || c._source_kind || c._source || '').toLowerCase();
    const baseType = kindRaw === 'gift' ? 'GIFT' : 'COUPON';

    // Kalau di luar sudah kamu siapkan label jadi "COUPON (02)" / "GIFT (01)"
    // (via couponsForDisplay), pakai itu; kalau tidak, minimal tampil "COUPON" / "GIFT"
    const typeLabel = c.type || baseType;

    t.push([
      i + 1,
      discountCode,
      typeLabel,
      c.name || c.note || '-'
    ]);
  });

  console.log(t.toString());
}


// ---------- INPUT HELPERS ----------
function parseSeatsInput(raw, availableSeats = []) {
  if (!raw) return [];

  // Normalisasi dasar
  let text = String(raw).toUpperCase();

  // Gabung "B 7" â†’ "B7", "AA 10" â†’ "AA10"
  text = text.replace(/([A-Z]+)\s*([0-9]+)/g, '$1$2');

  // Hilangkan spasi di sekitar tanda minus: "B7 - B8" â†’ "B7-B8"
  text = text.replace(/\s*-\s*/g, '-');

  // ğŸ”¹ NEW: dukung format titik seperti "A4.5" atau "A4.5.6" atau "A15.14.13.12"
  //  - "A4.5"           â†’ "A4,5"   (token jadi: ["A4","5"] â†’ A4,A5)
  //  - "A4.5.6"         â†’ "A4,5,6" (token jadi: ["A4","5","6"] â†’ A4,A5,A6)
  //  - "A15.14.13.12"   â†’ "A15,14,13,12" (token jadi: ["A15","14","13","12"])

  // Step 1: Replace semua titik dengan koma (simple & robust)
  text = text.replace(/\./g, ',');

  // Split pakai koma, spasi, newline, tab, dsb (tapi hyphen tetap dipertahankan)
  const tokens = text.split(/[,\s]+/).filter(Boolean);

  // Map label â†’ seat object, biar gampang match ke availableSeats
  const seatByLabel = new Map();
  for (const s of availableSeats) {
    const label = String(s.label || '').toUpperCase().replace(/\s+/g, '');
    if (label) seatByLabel.set(label, s);
  }

  const pickedLabels = [];
  let lastRow = null; // untuk kasus "B7,8" â†’ 8 pakai row B

  // helper parse 1 "token" jadi {row, num}
  const parseSingle = (token) => {
    // Bentuk normal "B7", "AA10", dll
    const full = /^([A-Z]+)(\d+)$/.exec(token);
    if (full) {
      lastRow = full[1]; // update row terakhir
      return { row: full[1], num: parseInt(full[2], 10) };
    }

    // Hanya angka: "8" â†’ pakai row terakhir -> B8
    const onlyNum = /^(\d+)$/.exec(token);
    if (onlyNum && lastRow) {
      return { row: lastRow, num: parseInt(onlyNum[1], 10) };
    }

    return null;
  };

  for (const token of tokens) {
    if (!token) continue;

    // ğŸ”¹ Handle format sambung seperti "B7B8" â†’ ["B7","B8"]
    // Pola: beberapa kali (ROW+NUMBER) berulang tanpa pemisah.
    const multiMatches = token.match(/([A-Z]+[0-9]+)/g);
    if (multiMatches && multiMatches.length > 1 && !token.includes('-')) {
      for (const m of multiMatches) {
        const seat = parseSingle(m);
        if (!seat) continue;
        const lbl = `${seat.row}${seat.num}`;
        if (!pickedLabels.includes(lbl)) pickedLabels.push(lbl);
      }
      continue; // token ini sudah di-consume, lanjut token berikutnya
    }

    // Range: "B7-B8" atau "B7-8"
    if (token.includes('-')) {
      const [left, right] = token.split('-');
      if (!left || !right) continue;

      const leftSeat = parseSingle(left);
      if (!leftSeat) continue;

      const rightSeat = parseSingle(right);
      // Range beda baris gue skip biar aman
      if (!rightSeat || rightSeat.row !== leftSeat.row) continue;

      const row = leftSeat.row;
      const start = Math.min(leftSeat.num, rightSeat.num);
      const end   = Math.max(leftSeat.num, rightSeat.num);

      for (let n = start; n <= end; n++) {
        const lbl = `${row}${n}`;
        if (!pickedLabels.includes(lbl)) pickedLabels.push(lbl);
      }
    } else {
      // Single kursi: "B7" atau "8" (kalau sebelumnya sudah ada row)
      const seat = parseSingle(token);
      if (!seat) continue;
      const lbl = `${seat.row}${seat.num}`;
      if (!pickedLabels.includes(lbl)) pickedLabels.push(lbl);
    }
  }

  // Konversi label â†’ object seat yang bener-bener tersedia
  const result = [];
  for (const lbl of pickedLabels) {
    const seat = seatByLabel.get(lbl);
    if (seat) result.push(seat);
  }

  return result;
}



  function needsGapFilling(selectedSeats, allSeats) {
    // Check if we need to fill gaps between selected seats
    const seatsByRow = new Map();
    allSeats.forEach(seat => {
      const match = seat.label.match(/([A-Z])(\d+)/i);
      if (match) {
        const row = match[1];
        const num = parseInt(match[2]);
        if (!seatsByRow.has(row)) seatsByRow.set(row, []);
        seatsByRow.get(row).push({ ...seat, num });
      }
    });
    
    const gapsToFill = [];
    const selectedByRow = new Map();
    
    selectedSeats.forEach(seat => {
      const match = seat.label.match(/([A-Z])(\d+)/i);
      if (match) {
        const row = match[1];
        const num = parseInt(match[2]);
        if (!selectedByRow.has(row)) selectedByRow.set(row, []);
        selectedByRow.get(row).push(num);
      }
    });

    selectedByRow.forEach((nums, row) => {
      nums.sort((a, b) => a - b);
      const rowSeats = seatsByRow.get(row) || [];
      
      for (let i = 0; i < nums.length - 1; i++) {
        const current = nums[i];
        const next = nums[i + 1];
        
        if (next - current > 1) {
          // There's a gap, check if seats exist in between
          for (let gapNum = current + 1; gapNum < next; gapNum++) {
            const gapSeat = rowSeats.find(s => s.num === gapNum);
            if (gapSeat) {
              gapsToFill.push(gapSeat);
            }
          }
        }
      }
    });

    return gapsToFill;
  }

// ====== [NEW] 422 WARN PARSER & SEAT HELPERS ======
const WARN_RE = /(empty|kosong)\s*[:\-â€“]\s*([A-Z])\s*0*([0-9]{1,2})/i;
function parseWarnedSeatMsg(msg){
  const m = String(msg||'').match(WARN_RE);
  return m ? { row: m[2].toUpperCase(), num: Number(m[3]), label: `${m[2].toUpperCase()}${Number(m[3])}` } : null;
}

// Index seat map untuk akses cepat
function indexRows(seatRes){
  const rows = seatRes?.data?.rows || [];
  const byLabel = new Map();
  const byRow = new Map(); // key: 'B' â†’ [{id,label,num,is_available,grade,price}]
  rows.forEach(r=>{
    (r.seats||[]).forEach(s=>{
      if (!s.is_seat) return;
      const rowName = String(s.row_name||'').toUpperCase();
      const num = Number(s.number);
      const label = `${rowName}${num}`;
      const item = {
        id: s.id,
        label,
        num,
        row: rowName,
        is_available: !!s.is_available,
        grade: s.grade,
        price: s.price
      };
      byLabel.set(label, item);
      if (!byRow.has(rowName)) byRow.set(rowName, []);
      byRow.get(rowName).push(item);
    });
  });
  byRow.forEach(list => list.sort((a,b)=>a.num-b.num));
  return { byLabel, byRow };
}

function findByLabel(idx, label){
  return idx.byLabel.get(String(label).toUpperCase()) || null;
}

function neighborsAvailable(idx, warnedLabel){
  const w = findByLabel(idx, warnedLabel);
  if (!w) return [];
  const rowList = idx.byRow.get(w.row) || [];
  const i = rowList.findIndex(x=>x.label===w.label);
  const out = [];
  const left  = rowList[i-1]; if (left  && left.is_available)  out.push(left);
  const right = rowList[i+1]; if (right && right.is_available) out.push(right);
  return out;
}

function sortByProximity(candidates, intendedLabels=[]){
  if (!Array.isArray(candidates) || !candidates.length) return [];
  const setIntended = new Set((intendedLabels||[]).map(s=>String(s).toUpperCase()));
  return candidates
    .map(c => ({ c, score: setIntended.has(c.label) ? 0 : 1 })) // 0 = prioritas (bagian dari niat)
    .sort((a,b)=> a.score - b.score)
    .map(x=>x.c);
}

function labelsToSeatPayload(labels, seatResOrIdx){
  const idx = seatResOrIdx?.byLabel ? seatResOrIdx : indexRows(seatResOrIdx);
  const seats = [];
  for (const L of (labels||[])){
    const s = findByLabel(idx, L);
    if (s && s.is_available) seats.push({ id: s.id });
  }
  return seats;
}

// ====== [UPDATED] SMART AUTO-FIX 422 (reserve-then-rebook terlebih dulu) ======
async function smartAutoFixAfter422({
  seatRes,                // seat map terkini dari /seats
  warnedLabel,            // "E4" (hasil parse)
  intendedLabels = [],    // mis. ["E6","E5"]
  basePayload = {},       // { order_id:'', movie_schedule_id, date, movie_id }
  bookSeatsFn,            // (payload) => bookSeats(payload, token)
  fetchSeatsFn,           // (scheduleId, token) => fetchSeats(...)
  context = {},           // { schedule_id, token, date, movie_id, ... }
  enablePolling = true,
  pollEvery = 3000,
  pollMs = 20000
}){
  // === 1) PARKIR kursi yang diperingatkan sendirian (sesuai kebutuhanmu)
  const idx = indexRows(seatRes);
  const warnedSeat = findByLabel(idx, warnedLabel);
  if (!warnedSeat || !warnedSeat.is_available) {
    // kalau tidak available, langsung ke fallback tetangga
  } else {
    const parkPayload = { ...basePayload, seats: [{ id: warnedSeat.id }] };
    const parkRes = await bookSeatsFn(parkPayload);

    if (parkRes?.status_code === 200) {
      const parkedOrderId = parkRes?.data?.id || null;

      // === 2) REBOOK ke niat awal (dengan smart retry untuk handle rate limit)
      // Ambil seat map terbaru dulu biar mapping id up-to-date
      const freshA = await fetchSeatsFn(context.schedule_id, context.token);
      const idxA = indexRows(freshA);
      const intendedSeatsPayload = labelsToSeatPayload(intendedLabels, idxA);

      if (intendedSeatsPayload.length === intendedLabels.length) {
        // Smart retry: coba 3x dengan delay bertahap (2s, 5s, 8s)
        const retryDelays = [2000, 5000, 8000];
        let rebookSuccess = false;
        let rebookRes = null;

        for (let attempt = 0; attempt < retryDelays.length + 1; attempt++) {
          if (attempt > 0) {
            const delayTime = retryDelays[attempt - 1];
            log.info(`â³ Rebook attempt #${attempt + 1}: Waiting ${delayTime / 1000}s sebelum retry (rate limit cooldown)...`);
            await delay(delayTime);
          }

          rebookRes = await bookSeatsFn({ ...basePayload, seats: intendedSeatsPayload });

          if (rebookRes?.status_code === 200) {
            rebookSuccess = true;
            break;
          } else if (rebookRes?.status_code === 429) {
            log.warning(`âš ï¸  Rate limit (429) pada attempt #${attempt + 1}. Retry dengan delay lebih lama...`);
          } else {
            log.warning(`âš ï¸  Rebook gagal (${rebookRes?.status_code}) pada attempt #${attempt + 1}`);
            // Jika bukan 429, tidak perlu retry
            break;
          }
        }

        if (rebookSuccess && rebookRes?.status_code === 200) {
          // sukses â†’ batalkan order parkir agar tidak dobel
          if (parkedOrderId && typeof cancelOrder === 'function') {
            try { await cancelOrder(parkedOrderId, context.token); } catch {}
          }
          return {
            ok: true,
            mode: 'RESERVE_THEN_REBOOK_INTENDED',
            labels: intendedLabels,
            res: rebookRes,
            parkedOrderId
          };
        } else {
          log.warning(`âš ï¸  Rebook ke kursi niat awal gagal setelah ${retryDelays.length + 1} attempts. Lanjut ke polling...`);
        }
      }

      // === 3) (opsional) polling sebentar menunggu intended kebuka
      if (enablePolling) {
        const deadline = Date.now() + pollMs;
        while (Date.now() < deadline) {
          await delay(pollEvery);
          const freshB = await fetchSeatsFn(context.schedule_id, context.token);
          const idxB = indexRows(freshB);
          const allAvail = intendedLabels.every(L => {
            const s = findByLabel(idxB, L);
            return s && s.is_available;
          });
          if (allAvail) {
            const backSeats = labelsToSeatPayload(intendedLabels, idxB);

            // Smart retry untuk handle rate limit
            let pollingRetrySuccess = false;
            let resBack = null;
            const pollingRetries = [0, 3000, 6000]; // 3 attempts: instant, +3s, +6s

            for (let pRetry = 0; pRetry < pollingRetries.length; pRetry++) {
              if (pRetry > 0) {
                log.info(`â³ Polling rebook attempt #${pRetry + 1}: Waiting ${pollingRetries[pRetry] / 1000}s...`);
                await delay(pollingRetries[pRetry]);
              }

              resBack = await bookSeatsFn({ ...basePayload, seats: backSeats });

              if (resBack?.status_code === 200) {
                pollingRetrySuccess = true;
                break;
              } else if (resBack?.status_code === 429) {
                log.warning(`âš ï¸  Rate limit (429) pada polling attempt #${pRetry + 1}`);
              } else {
                // Bukan 429, tidak perlu retry
                break;
              }
            }

            if (pollingRetrySuccess && resBack?.status_code === 200) {
              if (parkedOrderId && typeof cancelOrder === 'function') {
                try { await cancelOrder(parkedOrderId, context.token); } catch {}
              }
              return {
                ok: true,
                mode: 'POLLING_INTENDED',
                labels: intendedLabels,
                res: resBack
              };
            }

            // gagal rebook setelah retry â†’ cancel parkir dan return fail
            log.warning(`âš ï¸  Polling rebook gagal setelah ${pollingRetries.length} attempts.`);
            log.info(`ğŸ—‘ï¸  Membatalkan order parkir ${warnedLabel} (Order ID: ${parkedOrderId})...`);
            if (parkedOrderId && typeof cancelOrder === 'function') {
              try {
                await cancelOrder(parkedOrderId, context.token);
                log.success(`âœ… Order parkir dibatalkan`);
              } catch (e) {
                log.error(`âŒ Gagal cancel order parkir: ${e.message}`);
              }
            }
            return {
              ok: false,
              reason: 'rebook_failed_after_retries',
              parkedOrderId,
              cancelledParkir: true
            };
          }
        }
      }
      // polling habis waktu â†’ cancel parkir dan return fail
      log.warning(`â²ï¸  Polling timeout. Kursi niat awal tidak tersedia dalam ${pollMs / 1000}s.`);
      log.info(`ğŸ—‘ï¸  Membatalkan order parkir ${warnedLabel} (Order ID: ${parkedOrderId})...`);
      if (parkedOrderId && typeof cancelOrder === 'function') {
        try {
          await cancelOrder(parkedOrderId, context.token);
          log.success(`âœ… Order parkir dibatalkan`);
        } catch (e) {
          log.error(`âŒ Gagal cancel order parkir: ${e.message}`);
        }
      }
      return {
        ok: false,
        reason: 'polling_timeout',
        parkedOrderId,
        cancelledParkir: true
      };
    }
    // kalau parkir gagal â†’ lanjut ke fallback tetangga di bawah
  }

  // === 4) FALLBACK (strategi lama): pesan [warned + tetangga] lalu (opsional) polling kembali ke niat awal
  const neigh = neighborsAvailable(idx, warnedLabel);
  if (!neigh.length) return { ok:false, reason:'no_neighbor_available' };

  const ordered = sortByProximity(neigh, intendedLabels);
  for (const n of ordered) {
    const fallbackLabels = [warnedLabel, n.label];
    const seats = labelsToSeatPayload(fallbackLabels, idx);
    if (seats.length !== fallbackLabels.length) continue;
    const res = await bookSeatsFn({ ...basePayload, seats });
    if (res?.status_code === 200){
      const parkedOrderId = res?.data?.id || null;

      if (!enablePolling) {
        return { ok:true, mode:'AUTO_FIX', labels:fallbackLabels, res, parkedOrderId };
      }

      const deadline = Date.now() + pollMs;
      while (Date.now() < deadline){
        await delay(pollEvery);
        const fresh = await fetchSeatsFn(context.schedule_id, context.token);
        const idx2 = indexRows(fresh);
        const allAvail = intendedLabels.every(L=>{
          const s = findByLabel(idx2, L);
          return s && s.is_available;
        });
        if (allAvail){
          const backSeats = labelsToSeatPayload(intendedLabels, idx2);

          // Smart retry untuk fallback polling
          let fallbackRetrySuccess = false;
          let resBack = null;
          const fallbackRetries = [0, 3000, 6000]; // 3 attempts

          for (let fRetry = 0; fRetry < fallbackRetries.length; fRetry++) {
            if (fRetry > 0) {
              log.info(`â³ Fallback polling attempt #${fRetry + 1}: Waiting ${fallbackRetries[fRetry] / 1000}s...`);
              await delay(fallbackRetries[fRetry]);
            }

            resBack = await bookSeatsFn({ ...basePayload, seats: backSeats });

            if (resBack?.status_code === 200) {
              fallbackRetrySuccess = true;
              break;
            } else if (resBack?.status_code === 429) {
              log.warning(`âš ï¸  Rate limit (429) pada fallback attempt #${fRetry + 1}`);
            } else {
              // Bukan 429, tidak perlu retry
              break;
            }
          }

          if (fallbackRetrySuccess && resBack?.status_code === 200) {
            if (parkedOrderId && typeof cancelOrder === 'function') {
              try { await cancelOrder(parkedOrderId, context.token); } catch {}
            }
            return { ok: true, mode: 'POLLING_INTENDED', labels: intendedLabels, res: resBack };
          }

          // gagal rebook setelah retry â†’ cancel auto-fix dan return fail
          log.warning(`âš ï¸  Fallback polling rebook gagal setelah ${fallbackRetries.length} attempts.`);
          log.info(`ğŸ—‘ï¸  Membatalkan order auto-fix [${fallbackLabels.join(', ')}] (Order ID: ${parkedOrderId})...`);
          if (parkedOrderId && typeof cancelOrder === 'function') {
            try {
              await cancelOrder(parkedOrderId, context.token);
              log.success(`âœ… Order auto-fix dibatalkan`);
            } catch (e) {
              log.error(`âŒ Gagal cancel order auto-fix: ${e.message}`);
            }
          }
          return {
            ok: false,
            reason: 'fallback_rebook_failed',
            parkedOrderId,
            cancelledAutoFix: true
          };
        }
      }
      // polling timeout â†’ cancel auto-fix dan return fail
      log.warning(`â²ï¸  Fallback polling timeout. Kursi niat awal tidak tersedia dalam ${pollMs / 1000}s.`);
      log.info(`ğŸ—‘ï¸  Membatalkan order auto-fix [${fallbackLabels.join(', ')}] (Order ID: ${parkedOrderId})...`);
      if (parkedOrderId && typeof cancelOrder === 'function') {
        try {
          await cancelOrder(parkedOrderId, context.token);
          log.success(`âœ… Order auto-fix dibatalkan`);
        } catch (e) {
          log.error(`âŒ Gagal cancel order auto-fix: ${e.message}`);
        }
      }
      return {
        ok: false,
        reason: 'fallback_timeout',
        parkedOrderId,
        cancelledAutoFix: true
      };
    }
  }
  return { ok:false, reason:'fallback_booking_failed' };
}


  // ---------- PAYMENT HELPERS ----------
  function findDana(payData){
    const cats = payData?.data || [];

    for (const cat of cats){
      const catId = (cat?.category_id ?? cat?.id ?? cat?.categoryId ?? cat?.categoryID);
      const isWallet = String(catId) === '2' || includesWord(cat?.name, 'E-WALLET') || includesWord(cat?.name, 'EWALLET');
      if (!isWallet) continue;
      for (const it of (cat.items||[])){
        if (!it?.status) continue;
        const nameNorm = normalize(it.name);
        if (nameNorm === 'dana' || String(it.id) === '5') {
          return { payment_id: it.id, payment_name: it.name, category_id: catId, category_name: cat.name };
        }
      }
    }

    for (const cat of cats){
      const catId = (cat?.category_id ?? cat?.id ?? cat?.categoryId ?? cat?.categoryID);
      for (const it of (cat.items||[])){
        if (!it?.status) continue;
        if (normalize(it.name) === 'dana') {
          return { payment_id: it.id, payment_name: it.name, category_id: catId, category_name: cat.name };
        }
      }
    }

    for (const cat of cats){
      const catId = (cat?.category_id ?? cat?.id ?? cat?.categoryId ?? cat?.categoryID);
      for (const it of (cat.items||[])){
        if (!it?.status) continue;
        if (includesWord(it.name, 'DANA')) {
          return { payment_id: it.id, payment_name: it.name, category_id: catId, category_name: cat.name };
        }
      }
    }
    return null;
  }

  // ---------- OPEN EXTERNAL URL ----------
  async function openExternalUrl(url){
    if (!url) return { ok:false, reason:'empty_url' };
    try{
      try {
        const openMod = (await import('open')).default;
        await openMod(url, { wait:false });
        return { ok:true, via:'open' };
      } catch {}
      const { spawn } = await import('child_process');
      const platform = process.platform;
      let cmd, args;
      if (platform === 'darwin') { cmd='open'; args=[url]; }
      else if (platform === 'win32') { cmd='cmd'; args=['/c','start','',url]; }
      else { cmd='xdg-open'; args=[url]; }
      const child = spawn(cmd, args, { stdio:'ignore', detached:true });
      child.unref();
      return { ok:true, via:cmd };
    } catch (e) {
      return { ok:false, reason:e?.message || 'unknown' };
    }
  }

  // ---------- MONITORING UTILS ----------
  function parseUtcish(s){
    if (!s) return null;
    const t = s.replace(' ', 'T') + 'Z';
    const d = new Date(t);
    return isNaN(+d) ? null : d;
  }
  function formatRemaining(ms){
    if (ms <= 0) return '0s';
    const s = Math.floor(ms/1000);
    const m = Math.floor(s/60);
    const r = s%60;
    return m ? `${m}m ${r}s` : `${r}s`;
  }

  // ======== [NEW] RENDER RINGKASAN LENGKAP (helper reusable) ========
  const pad = (s, w)=> (String(s).length<w ? s + ' '.repeat(w-String(s).length) : s);
function renderFullOrderSummaryBox(orderObj, statusText = 'Pembayaran Diproses', context = {}) {
  const o = orderObj || {};
  const { selectedAccount, chosenLocation, selectedCinema, selectedMovie, dateYmd, selectedSchedule, seatsPick } = context;
  console.log();
  log.section('ğŸ“‹ RINGKASAN LENGKAP PESANAN');
  console.log(chalk.cyan('â•­' + 'â”€'.repeat(80) + 'â•®'));
  console.log(chalk.cyan('â”‚') + chalk.white.bold('                        DETAIL PESANAN LENGKAP                        ') + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”œ' + 'â”€'.repeat(80) + 'â”¤'));
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Akun Email')}      : ${String(selectedAccount?.email||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Kota')}           : ${String(chosenLocation?.location_name||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Bioskop')}        : ${String(selectedCinema?.name||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Alamat')}         : ${String(selectedCinema?.address||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Film')}           : ${String(selectedMovie?.name||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Genre/Rating')}   : ${`${selectedMovie?.genre||'-'} / ${selectedMovie?.rating||'-'}`.slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Durasi')}         : ${String(selectedMovie?.duration||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Status Film')}    : ${String(selectedMovie?.status==='PLAYING'?'SEDANG TAYANG':'AKAN TAYANG').padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Tanggal Nonton')} : ${(dateYmd ? `${dateYmd.slice(6,8)}/${dateYmd.slice(4,6)}/${dateYmd.slice(0,4)}` : '-').padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Jam Tayang')}     : ${(selectedSchedule ? `${selectedSchedule.start_time} - ${selectedSchedule.end_time}` : '-').padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Studio/Format')}  : ${(selectedSchedule ? `${selectedSchedule.auditorium_name} (${selectedSchedule.movie_format})` : '-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Tipe Teater')}    : ${String(selectedSchedule?.movie_type_name || 'Regular').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Kursi Terpilih')} : ${(seatsPick ? seatsPick.map(s=>s.label).join(', ') : '-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Jumlah Kursi')}   : ${String(seatsPick?.length || 0).slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”œ' + 'â”€'.repeat(80) + 'â”¤'));
  console.log(chalk.cyan('â”‚') + ` ${chalk.green('Order ID')}       : ${String(o.id||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.green('Booking Code')}   : ${String(o.booking_code||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.green('Total Bayar')}    : ${toRp(o.total_amount||0).slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.green('Voucher')}        : ${(o.discount_code ? `${o.discount_code} - ${o.discount_name||''}` : 'Tidak Ada').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.green('Diskon')}         : ${(o.discount_value ? toRp(o.discount_value) : 'Rp0').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.red('Expire Time')}    : ${String(o.expired_date||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â”‚') + ` ${chalk.blue('Status')}         : ${String(statusText||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
  console.log(chalk.cyan('â•°' + 'â”€'.repeat(80) + 'â•¯'));
}

// ===== Helper: auto handle order dengan total 0 (FREE) =====
async function autoHandleZeroTotalOrderIfAny({ order, token, context = {} }) {
  try {
    if (!order) return null;

    // Ambil total dari beberapa kemungkinan field
    const rawTotal =
      order.total_amount ??
      order.total ??
      order.final_amount ??
      0;

    const total = Number(rawTotal);

    // Jika bukan angka valid atau total > 0 â†’ biarkan flow normal
    if (!Number.isFinite(total) || total > 0) return null;

    const {
      orderContext,
      selectedAccount,
      selectedMovie,
      dateYmd,
      selectedSchedule,
      seatsPick
    } = context;

    const movie = selectedMovie || { name: order.movie_name || '-' };
    const seatsArr = Array.isArray(seatsPick) ? seatsPick : [];

    const ctx = orderContext || {
      selectedAccount,
      selectedMovie: movie,
      dateYmd,
      selectedSchedule,
      seatsPick: seatsArr
    };

    log.section('ğŸ’¸ ZERO TOTAL ORDER DETECTED (AUTO HANDLER)');

    const lines = [];

    lines.push(`Film       : ${movie.name}`);

    // Guard tanggal biar nggak error kalau formatnya aneh
    const d = (dateYmd || '').toString();
    if (d && d.length === 8 && selectedSchedule) {
      const tgl = `${d.slice(6, 8)}/${d.slice(4, 6)}/${d.slice(0, 4)}`;
      lines.push(`Tanggal    : ${tgl} ${selectedSchedule.start_time || ''}`.trim());
    }

    if (seatsArr.length) {
      lines.push(`Kursi      : ${seatsArr.map(s => s.label || s.name || '?').join(', ')}`);
    }

    lines.push(`Order ID   : ${order.id || '-'}`);
    lines.push(`Booking    : ${order.booking_code || '-'}`);
    lines.push(`Total      : ${toRp(total)}`);
    lines.push(`Status     : FREE (Rp 0) â€” pembayaran tidak diperlukan`);

    console.log(multilineBox(lines));

    await appendJsonLog({
      event: 'zero_total_order_detected',
      order_id: order.id,
      total,
      raw: order
    });

    // ğŸ”” Kirim ringkasan ke Telegram (pakai label khusus FREE)
    let telegramPaymentMessageId = null;
    try {
      if (typeof sendTelegramPaymentSummary === 'function') {
        telegramPaymentMessageId = await sendTelegramPaymentSummary({
          order,
          movie,
          dateYmd,
          schedule: selectedSchedule || null,
          seats: seatsArr,              // konsisten dengan pemanggilan lain (array seats)
          methodLabel: 'FREE (Rp 0)',
          checkoutUrl: null
        });
      }
    } catch (e) {
      log.warning(`Gagal kirim ringkasan FREE ke Telegram: ${e.message}`);
      await appendJsonLog({
        event: 'zero_total_order_telegram_error',
        order_id: order.id,
        error: e.message
      });
    }

    // ğŸ“¸ Opsional: auto screenshot tiket (kalau sales_id + email + password tersedia)
    try {
      const acc = ctx.selectedAccount || selectedAccount;
      const salesId = order.sales_id;

      if (
        salesId &&
        acc &&
        acc.email &&
        acc.password &&
        typeof loginAndScreenshotTicket === 'function'
      ) {
        console.log(chalk.cyan('\nğŸŒ Auto login m.cgv.id mobile & screenshot tiket (FREE Rp0)...'));

        const screenshotResult = await loginAndScreenshotTicket({
          salesId,
          email: acc.email,
          password: acc.password,
          bookingCode: order.booking_code,
          passKey: order.pass_key,
          outDir: 'orders',
          headless: true,
          sendToTelegram: (process.env.SEND_SCREENSHOT_TO_TELEGRAM || 'true').toLowerCase() === 'true',
          accountName: acc.name || acc.fullName || acc.customer_name || '',
          accountEmail: acc.email,
          accountPassword: acc.password,
          movieTitle: order.movie_name || '',
          cinemaName: order.cinema_name || '',
          seatsLabel: (orderContext?.seatsPick || order.seats)?.map(s => s.label || `${s.row_name}${s.number}`).join('-') || '',
          showDate: ctx.dateYmd || '',
          showTime: ctx.selectedSchedule ? `${ctx.selectedSchedule.start_time}-${ctx.selectedSchedule.end_time}` : ''
        });

        if (screenshotResult?.success) {
          console.log(chalk.green(`ğŸ“¸ Screenshot tiket Rp0 berhasil: ${screenshotResult.path}`));
          await appendJsonLog({
            event: 'zero_total_mobile_screenshot_success',
            file: screenshotResult.path,
            sales_id: salesId,
            booking_code: order.booking_code
          });
        } else {
          console.log(chalk.yellow(`âš ï¸ Screenshot tiket Rp0 gagal: ${screenshotResult?.error || 'Unknown error'}`));
          await appendJsonLog({
            event: 'zero_total_mobile_screenshot_failed',
            sales_id: salesId,
            error: screenshotResult?.error || 'Unknown error'
          });
        }
      } else {
        console.log(chalk.gray('â„¹ï¸ Skip screenshot FREE (butuh sales_id + email + password).'));
      }
    } catch (e) {
      console.log(chalk.red(`âŒ Zero total screenshot error: ${e.message}`));
      await appendJsonLog({
        event: 'zero_total_mobile_screenshot_error',
        order_id: order.id,
        error: e.message
      });
    }

    // Untuk sekarang anggap order sudah selesai / completed
    const monitorResult = {
      status: 'completed',
      order
    };

    await appendJsonLog({
      event: 'zero_total_order_completed_local',
      order_id: order.id
    });

    // NOTE:
    // - renderFullOrderSummaryBox & deleteTelegramPaymentMessage
    //   tetap dikerjakan di ujung autoOrder (supaya konsisten).
    return { monitorResult, telegramPaymentMessageId };

  } catch (err) {
    log.warning(`autoHandleZeroTotalOrderIfAny error: ${err?.message || err}`);
    await appendJsonLog({
      event: 'zero_total_order_handler_error',
      error: err?.message || String(err)
    });
    return null;
  }
}


  function statusLabelFromResult(result, orderSnapshot){
    if (result === 'success') return 'LUNAS';
    if (result === 'canceled') return 'DIBATALKAN';
    if (result === 'expired') return 'EXPIRED';
    // fallback check:
    if (orderSnapshot?.complete_date) return 'LUNAS';
    return 'BELUM LUNAS';
  }
  // =============================================================

  async function monitorPaymentLoop({
    orderId,
    token,
    methodLabel='(unknown)',
    movieName='',
    seats='',
    intervalSec=0.1,
    confirmEverySec=60,
    initialRapidSec=20,
    rapidIntervalSec=0.1,
    orderContext,
    telegramMessageId = null
  }){
    log.section('ğŸ“¡ MONITORING PEMBAYARAN');
    console.log(chalk.gray('â–¶ Monitoring otomatis tanpa prompt. Tekan Ctrl+C untuk membatalkan pesanan.'));
    
    console.log(chalk.cyan('â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
    console.log(chalk.cyan('â”‚') + chalk.white.bold('                   MONITORING PEMBAYARAN                   ') + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.cyan('â”‚') + ` ğŸ« Order ID  : ${String(orderId).padEnd(40)} ` + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”‚') + ` ğŸ¬ Film      : ${movieName.slice(0,40).padEnd(40)} ` + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”‚') + ` ğŸª‘ Kursi     : ${seats.padEnd(40)} ` + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”‚') + ` ğŸ’³ Metode    : ${methodLabel.padEnd(40)} ` + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.cyan('â”‚') + chalk.gray(' Check: 0.1s (cepat) | Error: 1s (backoff) | Log: 1s      ') + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n'));

  // Non-interaktif: tidak ada prompt sama sekali
  let done = false;
  let canceled = false;
  let sigintOnce = false; // ğŸ†• penting: flag biar handler hanya jalan sekali
  let lastLogTime = 0;
  let consecutiveErrors = 0;
  let currentInterval = intervalSec;

  let cur = (await fetchOrderDetail(orderId, token))?.data || {};
  let expUtc = parseUtcish(cur?.expired_date_utc) || parseUtcish(cur?.expired_date);

  const onSigint = async () => {
    if (sigintOnce) return;
    sigintOnce = true;
    console.log(chalk.yellow('\nğŸ›‘ Ctrl+C terdeteksi â€” membatalkan pesanan...'));

    // Set flags IMMEDIATELY to stop tick() loop
    canceled = true;
    done = true;

    try {
      // Retry loop untuk cancel order sampai sukses
      const maxRetries = 10;
      const retryDelay = 2000; // 2 detik
      let cancelSuccess = false;

      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          const r = await cancelOrder(orderId, token);
          if (r?.status_code === 200) {
            console.log(chalk.green('âœ… Order berhasil dibatalkan.'));
            cancelSuccess = true;

            // ğŸ”„ Hapus pesan tracking di Telegram juga
            if (telegramMessageId) {
              await deleteTelegramPaymentMessage(telegramMessageId);
              await appendJsonLog({
                event: 'telegram_payment_message_deleted',
                message_id: telegramMessageId,
                final_status: 'canceled',
                order_id: orderId,
                via: 'sigint'
              });
            }
            break; // Sukses, keluar dari loop
          } else {
            const errMsg = r?.message || 'Unknown error';
            console.log(chalk.red(`âŒ Gagal batalkan order (attempt ${attempt}/${maxRetries}): ${errMsg}`));

            if (attempt < maxRetries) {
              console.log(chalk.yellow(`â³ Retry dalam ${retryDelay/1000} detik...`));
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            }
          }
        } catch (e) {
          console.log(chalk.red(`âŒ Cancel error (attempt ${attempt}/${maxRetries}): ${e.message}`));

          if (attempt < maxRetries) {
            console.log(chalk.yellow(`â³ Retry dalam ${retryDelay/1000} detik...`));
            await new Promise(resolve => setTimeout(resolve, retryDelay));
          }
        }
      }

      if (!cancelSuccess) {
        console.log(chalk.red(`âŒ Gagal batalkan order setelah ${maxRetries} percobaan. Order mungkin expire otomatis.`));
      }
    } catch (e) {
      console.log(chalk.red(`âŒ Critical cancel error: ${e.message}`));
    } finally {
      try {
        process.off('SIGINT', onSigint);
        process.off('SIGTERM', onSigint);
      } catch {}
      process.exit(130); // kode exit standar untuk Ctrl+C
    }
  };

  // ğŸ†• DAFTARKAN HANDLER DI SINI
  try {
    process.on('SIGINT', onSigint);
    process.on('SIGTERM', onSigint);
  } catch {}



    const tick = async () => {
      // Skip fetch jika sudah canceled atau done
      if (canceled || done) {
        return;
      }

      const res = await fetchOrderDetail(orderId, token);
      if (res?.status_code === 200) {
        cur = res.data || cur;
        consecutiveErrors = 0;
        currentInterval = intervalSec;
      } else {
        consecutiveErrors++;
        if (consecutiveErrors >= 2) {
          currentInterval = 1.0;
        }
      }

      const tx = await fetchMembershipTransactions(token);
      const txCount = Array.isArray(tx?.data) ? tx.data.length : 0;
      await appendJsonLog({ event: 'monitor_tick', order_id: orderId, tx_count: txCount, order_snapshot: {
        complete_date: cur.complete_date || '',
        payment_method: cur.payment_method || '',
        expired_date: cur.expired_date || '',
        total_amount: cur.total_amount || 0
      }});

      if (cur?.complete_date) {
        console.log(chalk.green('\nğŸ‰ PEMBAYARAN BERHASIL DIKONFIRMASI!'));
        console.log(chalk.green(`âœ… Waktu selesai: ${cur.complete_date}`));
        console.log(chalk.green('ğŸ« Tiket sudah bisa digunakan!'));

        // ğŸ”„ Auto-delete pesan init pembayaran di Telegram
        if (telegramMessageId) {
          await deleteTelegramPaymentMessage(telegramMessageId);
          console.log(chalk.cyan('ğŸ—‘ï¸  Pesan init pembayaran di Telegram telah dihapus.'));
          await appendJsonLog({
            event: 'telegram_payment_init_deleted',
            message_id: telegramMessageId,
            reason: 'payment_confirmed',
            order_id: orderId
          });
        }

        // Fetch detailed ticket info with barcode
        console.log(chalk.cyan('\nğŸ“‹ Mengambil detail tiket dan barcode...'));
        
        try {
          // 1) kalau order sudah bawa sales_id, pakai itu
          let salesId = cur?.sales_id || null;
          // 2) kalau belum, ambil transaksi lalu pilih yang paling relevan dgn sesi ini
          if (!salesId) {
            const txRes = await fetchMembershipTransactions(token);
            if (txRes?.status_code === 200 && Array.isArray(txRes.data)) {
      const picked = pickRelevantTransaction(
        txRes.data,
        {
          completeDate: cur.complete_date,
          movieName,
          movieDateYmd: (orderContext?.dateYmd),
          cinemaName: (orderContext?.selectedCinema?.name),
          ticketCount: (orderContext?.seatsPick?.length || 1),
          totalAmount: cur?.total_amount,
          bookingCode: cur?.booking_code
        },
        { preferComplete: true } // âœ… sesudah bayar: cari transaksi complete=1
      );
              salesId = picked?.sales_id || null;
            }
          }
          
          if (salesId) {
            // Fetch detailed ticket info
            const ticketUrl = `${baseURL}/api/membership/tickets/${salesId}`;
            const ticketRes = await requestJson('GET', ticketUrl, {
              headers: { Authorization: `Bearer ${token}` }
            });
            
            const tj = ticketRes?.json;
            if (tj?.status_code === 200 && tj.data) {
              const ticket = tj.data;
              
              // Display comprehensive ticket details WITHOUT discount info
              console.log(chalk.green('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
              console.log(chalk.green('â”‚') + chalk.white.bold('                    TIKET BERHASIL DITERBITKAN              ') + chalk.green('â”‚'));
              console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
              console.log(chalk.green('â”‚') + ` ğŸ¬ Film      : ${(ticket.movie_name || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
              console.log(chalk.green('â”‚') + ` ğŸ¢ Bioskop   : ${(ticket.cinema_name || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
              console.log(chalk.green('â”‚') + ` ğŸ­ Studio    : ${(ticket.auditorium_name || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
              console.log(chalk.green('â”‚') + ` ğŸ“… Tanggal   : ${(ticket.movie_date || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
              console.log(chalk.green('â”‚') + ` â° Waktu     : ${(ticket.movie_start_time || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
              console.log(chalk.green('â”‚') + ` ğŸª‘ Kursi     : ${ticket.seats?.map(s => `${s.row_name}${s.number}`).join(', ').slice(0,40).padEnd(40) || ''.padEnd(40)} ` + chalk.green('â”‚'));
              console.log(chalk.green('â”‚') + ` ğŸŸï¸  Booking   : ${(ticket.booking_code || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
              console.log(chalk.green('â”‚') + ` ğŸ”‘ Pass Key  : ${(ticket.pass_key || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
              console.log(chalk.green('â”‚') + ` ğŸ’° Total     : ${toRp(ticket.total_amount || 0).slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
              const derivedType = (Array.isArray(ticket.seats) && ticket.seats.length) ? 'Movie' : (Array.isArray(ticket.conces) && ticket.conces.length ? 'Food & Beverage' : 'Unknown');
              console.log(chalk.green('â”‚') + ` ğŸ·ï¸  Type      : ${derivedType.padEnd(40)} ` + chalk.green('â”‚'));
              console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
              console.log(chalk.green('â”‚') + chalk.yellow.bold('                         BARCODE TIKET                       ') + chalk.green('â”‚'));
              console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
              
              // Display barcode if available
              if (ticket.sales_id_barcode) {
                console.log(chalk.green('â”‚') + ` ğŸ“Š Barcode tersedia dalam format base64                    ` + chalk.green('â”‚'));
                console.log(chalk.green('â”‚') + ` ğŸ”— Sales ID : ${(ticket.sales_id || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
                console.log(chalk.green('â”‚') + ` âœ… Status   : ${(ticket.process_status || 'Confirmed').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
                
                // Log full barcode data for external use
                await appendJsonLog({ 
                  event: 'ticket_barcode_generated', 
                  sales_id: ticket.sales_id,
                  barcode_data: ticket.sales_id_barcode,
                  booking_code: ticket.booking_code,
                  pass_key: ticket.pass_key
                });
              }
              
              console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
              console.log(chalk.green('â”‚') + ` ğŸ« TIKET SIAP DIGUNAKAN - Tunjukkan booking code di bioskop ` + chalk.green('â”‚'));
              console.log(chalk.green('â”‚') + ` ğŸ“± Simpan screenshot ini sebagai backup tiket              ` + chalk.green('â”‚'));
              console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
              
              // Additional seat details if multiple seats
              if (ticket.seats && ticket.seats.length > 0) {
                console.log(chalk.cyan('\nğŸ“ DETAIL KURSI:'));
                ticket.seats.forEach((seat, i) => {
                  console.log(chalk.white(`   ${i+1}. Kursi ${seat.row_name}${seat.number} - ${toRp(seat.price)}`));
                });
              }
              
              // Payment method info (without showing discount)
              if (ticket.payment && ticket.payment.length > 0) {
                console.log(chalk.cyan('\nğŸ’³ METODE PEMBAYARAN:'));
                ticket.payment.forEach((pay, i) => {
                  const subtotal = pay.subtotal || 0;
                  const fee = pay.convenience_fee || 0;
                  console.log(chalk.white(`   ${pay.payment_name}: ${toRp(subtotal)} + fee ${toRp(fee)}`));
                });
              }
              
              // F&B items if any (hide prices if free due to vouchers)
              if (ticket.conces && ticket.conces.length > 0) {
                console.log(chalk.cyan('\nğŸ¿ F&B ITEMS:'));
                ticket.conces.forEach((item, i) => {
                  console.log(chalk.white(`   ${i+1}. ${item.name}`));
                });
              }
              
              console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
              

              // Prepare movie ticket data FIRST (sebelum screenshot dan telegram)
              const movieTicketData = {
                movieName: ticket.movie_name,
                duration: ticket.movie_duration,
                rating: ticket.movie_censor_rating,
                cinemaName: ticket.cinema_name,
                format: ticket.movie_format,
                date: ticket.movie_date,
                time: `${ticket.movie_start_time}-${ticket.movie_end_time}`,
                showDate: ticket.movie_date,
                showTime: `${ticket.movie_start_time}-${ticket.movie_end_time}`,
                auditorium: ticket.auditorium_name,
                seats: ticket.seats?.map(s => `${s.row_name}${s.number}`).join(', '),
                bookingCode: ticket.booking_code,
                passKey: ticket.pass_key,
                salesId: ticket.sales_id,
                totalAmount: toRp(ticket.total_amount || 0),
                ticketCount: ticket.seats?.length || 1,
                salesIdBarcode: null,
                accountName: selectedAccount?.name || selectedAccount?.fullName || selectedAccount?.customer_name || '',
                accountEmail: selectedAccount?.email || '',
                accountPassword: selectedAccount?.password || ''
              };

              // AUTO LOGIN + SCREENSHOT mobile web
              try {
                const accForLogin = selectedAccount || {};
                if (salesId && accForLogin?.email && accForLogin?.password) {
                  console.log(chalk.cyan('\nğŸŒ Auto login m.cgv.id mobile & screenshot tiket...'));
                  const screenshotResult = await loginAndScreenshotTicket({
                    salesId,
                    email: accForLogin.email,
                    password: accForLogin.password,
                    bookingCode: movieTicketData.bookingCode,
                    passKey: movieTicketData.passKey,
                    outDir: 'orders',
                    headless: true,
                    sendToTelegram: (process.env.SEND_SCREENSHOT_TO_TELEGRAM || 'true').toLowerCase() === 'true',
                    accountName: accForLogin.name || accForLogin.fullName || accForLogin.customer_name || '',
                    accountEmail: accForLogin.email,
                    accountPassword: accForLogin.password,
                    movieTitle: movieTicketData.movieName || '',
                    cinemaName: movieTicketData.cinemaName || '',
                    seatsLabel: movieTicketData.seats?.replace(/, /g, '-') || '',
                    showDate: movieTicketData.showDate || '',
                    showTime: movieTicketData.showTime || ''
                  });

                  if (screenshotResult.success) {
                    console.log(chalk.green(`ğŸ“¸ Screenshot berhasil: ${screenshotResult.path}`));
                    await appendJsonLog({ 
                      event: 'mobile_screenshot_success', 
                      file: screenshotResult.path,
                      sales_id: salesId,
                      booking_code: movieTicketData.bookingCode
                    });
                  } else {
                    console.log(chalk.yellow(`âš ï¸ Screenshot gagal: ${screenshotResult.error}`));
                    await appendJsonLog({ 
                      event: 'mobile_screenshot_failed', 
                      error: screenshotResult.error,
                      sales_id: salesId
                    });
                  }
                } else {
                  console.log(chalk.yellow('â„¹ï¸ Skip screenshot (butuh salesId + email + password).'));
                }
              } catch (e) {
                console.log(chalk.red(`âŒ Screenshot error: ${e.message}`));
                await appendJsonLog({ 
                  event: 'mobile_screenshot_error', 
                  error: e.message,
                  sales_id: salesId
                });
              }

              // Kirim 2D QR BOOKING+PASSKEY ke Telegram
              await sendMovieTicketWithBarcode(movieTicketData, {
                sendToTelegram: (process.env.SEND_QR_TO_TELEGRAM || 'true').toLowerCase() === 'true'
              });



              await appendJsonLog({ 
                event: 'ticket_details_fetched', 
                sales_id: ticket.sales_id,
                telegram_sent: true,
                barcode_payload: 'BOOKING+PASSKEY',
                screenshot_file: `${movieTicketData.bookingCode}_${movieTicketData.passKey}.png`,
                ticket_summary: {
                  movie: ticket.movie_name,
                  cinema: ticket.cinema_name,
                  date: ticket.movie_date,
                  time: ticket.movie_start_time,
                  seats: ticket.seats?.length || 0,
                  booking_code: ticket.booking_code,
                  total: ticket.total_amount
                }
              });



              
} else {
  console.log(chalk.yellow('âš ï¸  Tidak dapat mengambil detail tiket, menggunakan data order saja'));
  if (cur?.booking_code && cur?.pass_key) {
    const fallbackTicket = {
      movie_name: movieName,
      movie_duration: orderContext?.selectedMovie?.duration,
      movie_censor_rating: orderContext?.selectedMovie?.rating,
      cinema_name: orderContext?.selectedCinema?.name,
      movie_format: orderContext?.selectedSchedule?.movie_format,
      movie_date: orderContext?.dateYmd
        ? `${orderContext.dateYmd.slice(0,4)}-${orderContext.dateYmd.slice(4,6)}-${orderContext.dateYmd.slice(6,8)}`
        : '-',
      movie_start_time: orderContext?.selectedSchedule?.start_time,
      movie_end_time: orderContext?.selectedSchedule?.end_time,
      auditorium_name: orderContext?.selectedSchedule?.auditorium_name,
      seats: (orderContext?.seatsPick||[]).map(s => ({ row_name: s.label[0], number: s.label.slice(1) })),
      booking_code: cur.booking_code,
      pass_key: cur.pass_key,
      sales_id: cur.sales_id || null,
      total_amount: cur.total_amount || 0
    };

    let salesId = fallbackTicket.sales_id;
    if (!salesId) {
      try {
        const txRes = await fetchMembershipTransactions(token);
        const picked = pickRelevantTransaction(
          txRes?.data || [],
          {
            completeDate: cur.complete_date,
            movieName,
            movieDateYmd: (orderContext?.dateYmd),
            cinemaName: (orderContext?.selectedCinema?.name),
            ticketCount: (orderContext?.seatsPick?.length || 1),
            totalAmount: cur?.total_amount
          },
          { preferComplete: true }
        );
        salesId = picked?.sales_id || null;
      } catch {}
    }

    // Prepare fallback movie ticket data FIRST
    const movieTicketData = {
      movieName: fallbackTicket.movie_name,
      duration: fallbackTicket.movie_duration,
      rating: fallbackTicket.movie_censor_rating,
      cinemaName: fallbackTicket.cinema_name,
      format: fallbackTicket.movie_format,
      date: fallbackTicket.movie_date,
      time: `${fallbackTicket.movie_start_time}-${fallbackTicket.movie_end_time}`,
      showDate: fallbackTicket.movie_date,
      showTime: `${fallbackTicket.movie_start_time}-${fallbackTicket.movie_end_time}`,
      auditorium: fallbackTicket.auditorium_name,
      seats: (orderContext?.seatsPick||[]).map(s=>s.label).join(', '),
      bookingCode: fallbackTicket.booking_code,
      passKey: fallbackTicket.pass_key,
      salesId: salesId || '-',
      totalAmount: toRp(fallbackTicket.total_amount),
      ticketCount: (orderContext?.seatsPick||[]).length,
      accountName: selectedAccount?.name || selectedAccount?.fullName || selectedAccount?.customer_name || '',
      accountEmail: selectedAccount?.email || '',
      accountPassword: selectedAccount?.password || ''
    };

    // Screenshot dengan data yang sudah disiapkan
    try {
      const accForLogin = selectedAccount || {};
      if (salesId && accForLogin?.email && accForLogin?.password) {
        console.log(chalk.cyan('\nğŸŒ Auto login m.cgv.id mobile & screenshot tiket (fallback)...'));
        const screenshotResult = await loginAndScreenshotTicket({
          salesId,
          email: accForLogin.email,
          password: accForLogin.password,
          bookingCode: movieTicketData.bookingCode,
          passKey: movieTicketData.passKey,
          outDir: 'orders',
          headless: true,
          sendToTelegram: (process.env.SEND_SCREENSHOT_TO_TELEGRAM || 'true').toLowerCase() === 'true',
          accountName: accForLogin.name || accForLogin.fullName || accForLogin.customer_name || '',
          accountEmail: accForLogin.email,
          accountPassword: accForLogin.password,
          movieTitle: movieTicketData.movieName || '',
          cinemaName: movieTicketData.cinemaName || '',
          seatsLabel: movieTicketData.seats?.replace(/, /g, '-') || '',
          showDate: movieTicketData.showDate || '',
          showTime: movieTicketData.showTime || ''
        });
        
        if (screenshotResult.success) {
          console.log(chalk.green(`ğŸ“¸ Screenshot berhasil: ${screenshotResult.path}`));
          await appendJsonLog({ 
            event: 'mobile_screenshot_success', 
            file: screenshotResult.path,
            sales_id: salesId,
            booking_code: movieTicketData.bookingCode
          });
        } else {
          console.log(chalk.yellow(`âš ï¸ Screenshot gagal: ${screenshotResult.error}`));
          await appendJsonLog({ 
            event: 'mobile_screenshot_failed', 
            error: screenshotResult.error,
            sales_id: salesId
          });
        }
      } else {
        console.log(chalk.yellow('â„¹ï¸ Skip screenshot (butuh salesId + email + password).'));
      }
    } catch (e) {
      console.log(chalk.red(`âŒ Screenshot error: ${e.message}`));
      await appendJsonLog({ 
        event: 'mobile_screenshot_error', 
        error: e.message,
        sales_id: salesId
      });
    }

    await sendMovieTicketWithBarcode(movieTicketData, {
      sendToTelegram: (process.env.SEND_QR_TO_TELEGRAM || 'true').toLowerCase() === 'true'
    });
  }
}




          } else {
            console.log(chalk.yellow('âš ï¸  Sales ID tidak ditemukan, menggunakan data order saja'));
          }
        } catch (ticketError) {
          console.log(chalk.yellow(`âš ï¸  Error mengambil detail tiket: ${ticketError.message}`));
          await appendJsonLog({ event: 'ticket_fetch_error', error: ticketError.message });
        }
        
        done = true; return;
      }


      expUtc = parseUtcish(cur?.expired_date_utc) || parseUtcish(cur?.expired_date);
      const now = new Date();
      if (expUtc && now > expUtc) {
        console.log(chalk.red('\nâ° WAKTU PEMBAYARAN HABIS'));
        console.log(chalk.red('âŒ Order sudah melewati batas waktu pembayaran.'));
        console.log(chalk.yellow('â„¹ï¸  Kemungkinan sudah dibatalkan otomatis oleh sistem.'));
        done = true; return;
      }

      const remainStr = expUtc ? formatRemaining(expUtc - now) : '-';

      // Throttle log output: hanya print setiap 1 detik
      const currentTime = Date.now();
      if (currentTime - lastLogTime >= 1000) {
        console.log(chalk.blue(`â³ Menunggu konfirmasi pembayaran... (sisa waktu: ${chalk.white(remainStr)})`));
        lastLogTime = currentTime;
      }
    };

    await tick();

    const rapidUntil = Date.now() + initialRapidSec * 1000;
    while (!done) {
      const now = Date.now();
      const isRapid = now < rapidUntil;

      // Adaptive interval: gunakan currentInterval yang bisa berubah jika ada error
      const delayMs = Math.max(100, currentInterval * 1000);
      await delay(delayMs);

      await tick();
      if (done) break;

    }

// bersihkan listener sinyal jika keluar normal (tanpa Ctrl+C)
try { process.off('SIGINT', onSigint); process.off('SIGTERM', onSigint); } catch {}
let finalStatus = 'pending';


    let finalSnapshot = cur;

    const final = await fetchOrderDetail(orderId, token);
    if (final?.status_code === 200) {
      finalSnapshot = final.data || cur;
      if (finalSnapshot?.complete_date) {
        console.log(chalk.green('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
        console.log(chalk.green('â”‚') + chalk.white.bold('                    PEMBAYARAN SELESAI                     ') + chalk.green('â”‚'));
        console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
        console.log(chalk.green('â”‚') + ` âœ… Status     : LUNAS                                   ` + chalk.green('â”‚'));
        console.log(chalk.green('â”‚') + ` ğŸ• Waktu      : ${String(finalSnapshot.complete_date||'-').padEnd(40)} ` + chalk.green('â”‚'));
        console.log(chalk.green('â”‚') + ` ğŸ« Booking    : ${String(finalSnapshot.booking_code||'-').padEnd(40)} ` + chalk.green('â”‚'));
        console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
        console.log(chalk.green('â”‚') + ' Tiket sudah bisa digunakan! Simpan booking code dengan    ' + chalk.green('â”‚'));
        console.log(chalk.green('â”‚') + ' baik untuk ditunjukkan saat masuk bioskop.                ' + chalk.green('â”‚'));
        console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
        finalStatus = 'success';
      } else {
        // kalau tidak complete, tentukan expired/pending berdasar waktu
        const exp = parseUtcish(finalSnapshot?.expired_date_utc) || parseUtcish(finalSnapshot?.expired_date);
        finalStatus = (exp && new Date() > exp) ? 'expired' : (canceled ? 'canceled' : 'pending');
        if (finalStatus !== 'success' && canceled) {
          console.log(chalk.yellow('\nğŸ”” Status akhir: DIBATALKAN oleh pengguna.'));
        } else if (finalStatus === 'expired') {
          console.log(chalk.red('\nğŸ”” Status akhir: EXPIRED (melewati batas waktu).'));
        } else {
          console.log(chalk.yellow('\nğŸ”” Status akhir: BELUM LUNAS.'));
        }
      }
    } else {
      finalStatus = canceled ? 'canceled' : 'pending';
    }

    return { status: canceled ? 'canceled' : finalStatus, order: finalSnapshot };
  }

// ---------- MAIN FLOW ----------
console.clear();
log.header('ğŸ¬ AUTO ORDER', 'Automated Movie Ticket Ordering');

await appendJsonLog({ event: 'session_start' });

// ğŸ”° Startup proxy & double-check outbound IP (khusus Auto Order Movie)
try {
  // ğŸ”Œ Proxy setup (untuk fetch). Puppeteer tetap tanpa proxy.
  await promptProxyAtStartup();
  await initSessionAgentIfNeeded();

  // Guards & helper
  const PROXY_DISABLED_SAFE = typeof PROXY_DISABLED !== 'undefined' ? !!PROXY_DISABLED : false;
  const HAS_PROXY_URL       = typeof sessionProxyUrl !== 'undefined' && !!sessionProxyUrl;
  const proxyActive         = !PROXY_DISABLED_SAFE && HAS_PROXY_URL;

  const STARTUP_IP_WAIT_MS = Math.max(0, Number(process.env.STARTUP_IP_WAIT_MS ?? 5000) || 5000);
  const FORCE_DOUBLE_IP_CHECK = String(process.env.FORCE_DOUBLE_IP_CHECK || '') === '1';
  const DO_SECOND_HIT = proxyActive || FORCE_DOUBLE_IP_CHECK;

  async function getPublicIp(note){
    try {
      const r = await requestJson('GET', 'https://api.ipify.org?format=json', { note });
      return r?.json?.ip || '-';
    } catch (e) {
      console.log(chalk.yellow(`âš ï¸  Gagal cek IP publik (${note}): ${e?.message || e}`));
      return '-';
    }
  }
  const safeMaskProxy = (u) => {
    try { return maskProxy ? maskProxy(u) : String(u || ''); }
    catch { return String(u || ''); }
  };

  log.section('ğŸŒ PROXY / OUTBOUND IP CHECK');
  let ip1 = '-', ip2 = '-';

  // Hit #1 (selalu)
  ip1 = await getPublicIp('proxy-ip-check#1');
  console.log(chalk.cyan(`ğŸ” Public IP #1: ${ip1}`));
  try {
    if (proxyActive) {
      console.log(chalk.gray(`   via proxy: ${safeMaskProxy(sessionProxyUrl)}`));
    } else {
      console.log(chalk.gray('   via direct connection'));
    }
  } catch {}

  if (!DO_SECOND_HIT) {
    // DIRECT â†’ skip hit #2 & tanpa delay
    console.log(chalk.gray('â­ï¸  Skip IP check #2 (DIRECT mode). Set FORCE_DOUBLE_IP_CHECK=1 untuk paksa 2x cek.'));
    ip2 = ip1; // supaya perbandingan tetap konsisten

    await appendJsonLog({
      event: 'startup_ip_single_check',
      ip_first: ip1,
      proxy: 'DIRECT'
    });
  } else {
    // PROXY aktif atau paksa 2x â†’ delay lalu hit #2
    await delay(STARTUP_IP_WAIT_MS);
    ip2 = await getPublicIp('proxy-ip-check#2');
    console.log(chalk.cyan(`ğŸ” Public IP #2: ${ip2}`));

    // Bandingkan
    if (ip1 !== '-' && ip2 !== '-') {
      if (ip1 !== ip2) {
        console.log(chalk.green(`ğŸ”„ IP berubah: ${ip1} â†’ ${ip2}`));
      } else {
        console.log(chalk.yellow('â¸ï¸  IP belum berubah (masih sama).'));
      }
    } else {
      console.log(chalk.gray('â„¹ï¸  Tidak cukup data untuk membandingkan IP.'));
    }

    await appendJsonLog({
      event: 'startup_ip_double_check',
      ip_first: ip1,
      ip_second: ip2,
      wait_ms: STARTUP_IP_WAIT_MS,
      proxy: proxyActive ? safeMaskProxy(sessionProxyUrl) : 'DIRECT'
    });
  }

} catch (e) {
  console.log(chalk.yellow(`âš ï¸  Startup proxy check skipped: ${e.message}`));
}


// â¬‡ï¸ lanjut flow seperti biasa
const accItems = await readAccountsFromJson(accountJsonPath);
if (!accItems.length) {
  log.error('account.json kosong/invalid. Pastikan file berisi "items[]"');
  await appendJsonLog({ event: 'session_end', reason: 'no_accounts' });
  return;
}

// Display account table
log.section('ğŸ‘¤ PILIH AKUN');

// ========== AUTO ACCOUNT SELECTION HELPERS ==========

/**
 * Read first line from txt file and return it (without deleting yet)
 */
async function readFirstAccountLine(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const lines = content.split('\n').map(l => l.trim()).filter(Boolean);
    return lines.length > 0 ? lines[0] : null;
  } catch (err) {
    return null;
  }
}

/**
 * Check if file exists
 */
async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Open file in default editor (cross-platform) - NON-BLOCKING
 * Returns immediately after spawning editor process
 */
async function openFileInEditor(filePath) {
  const { spawn } = await import('child_process');
  const os = await import('os');

  // Ensure file exists (create if not)
  const exists = await fileExists(filePath);
  if (!exists) {
    await fs.writeFile(filePath, '# Tambahkan email atau nomor telepon akun, 1 per baris\n# Format: 088276594887 atau tokpediqra0704@gmail.com\n\n', 'utf-8');
    console.log(chalk.gray(`ğŸ“ File ${filePath} dibuat otomatis`));
  }

  const platform = os.platform();
  let command;
  let args = [filePath];

  if (platform === 'win32') {
    command = 'notepad';
  } else if (platform === 'darwin') {
    command = 'open';
    args = ['-a', 'TextEdit', filePath];
  } else {
    // Linux: try xdg-open for GUI editors (non-blocking)
    command = 'xdg-open';
  }

  try {
    console.log(chalk.cyan(`ğŸ“‚ Membuka ${filePath} dengan ${command}...`));
    console.log(chalk.gray(`ğŸ’¡ Tambahkan akun ke file & Save (Ctrl+S), monitoring realtime!\n`));

    // Spawn detached process (non-blocking)
    spawn(command, args, {
      detached: true,
      stdio: 'ignore',
      shell: true
    }).unref();

    // Small delay to ensure editor starts
    await delay(500);
  } catch (err) {
    console.log(chalk.yellow(`âš ï¸  Gagal buka editor: ${err.message}`));
  }
}

/**
 * Delete first line from txt file (after successful selection)
 */
async function deleteFirstAccountLine(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const lines = content.split('\n').map(l => l.trim()).filter(Boolean);
    if (lines.length === 0) return;

    const remaining = lines.slice(1);
    await fs.writeFile(filePath, remaining.join('\n') + (remaining.length > 0 ? '\n' : ''), 'utf-8');
    console.log(chalk.gray(`âœ‚ï¸  Akun dihapus dari ${filePath}, sisa: ${remaining.length} akun`));
  } catch (err) {
    console.log(chalk.yellow(`âš ï¸  Gagal hapus baris dari ${filePath}: ${err.message}`));
  }
}

/**
 * Match account by email (partial/full) or phone number
 */
function matchAccount(accounts, query) {
  if (!query) return null;

  const q = query.toLowerCase().trim();

  // Try exact email match
  let match = accounts.find(acc => acc.email.toLowerCase() === q);
  if (match) return match;

  // Try exact phone match
  match = accounts.find(acc => acc.phone === q);
  if (match) return match;

  // Try partial email match (e.g., "tokpediqra0704" matches "tokpediqra0704@gmail.com")
  match = accounts.find(acc => acc.email.toLowerCase().includes(q));
  if (match) return match;

  // Try adding @gmail.com if not present
  if (!q.includes('@')) {
    const withGmail = q + '@gmail.com';
    match = accounts.find(acc => acc.email.toLowerCase() === withGmail);
    if (match) return match;
  }

  return null;
}

// Define function FIRST before calling
function renderEnhancedAccountTable(accounts) {
  const t = new CliTable({
    head: ['#','Email','Phone','Visits','LastTxn','1stPop','ComboSolo','3rdB1G1','Tsel10K','Vouchers'],
    wordWrap: true,
    style: { head: ['green'] },
    colWidths: [4, 32, 16, 8, 12, 8, 10, 8, 8, 10]
  });

  accounts.forEach((acc, i) => {
    const vouchData = acc.voucher_details || [];
    const hasActive = vouchData.filter(v => v.status === 'ACTIVE' && !v.is_expired);
    const has1stPop = acc.popcorn_1st_visit_status === 'YES' ? chalk.green('YES') : chalk.red('NO');
    const hasComboSolo = acc.combo_solo_status === 'YES' ? chalk.green('YES') : chalk.red('NO');
    const has3rdB1G1 = acc.third_visit_b1g1_status === 'YES' ? chalk.green('YES') : chalk.red('NO');
    const hasTsel10K = vouchData.some(v => /telkomsel.*10k/i.test(v.name) && v.status === 'ACTIVE') 
      ? chalk.green('YES') : chalk.red('NO');
    
    const today = todayFormatted();
    const visitColor = acc.last_txn_date === today ? chalk.green(String(acc.visits || 0)) : chalk.red(String(acc.visits || 0));
    const txnColor = acc.last_txn_date === today ? chalk.green(acc.last_txn_date || '-') : chalk.red(acc.last_txn_date || '-');
    
    t.push([
      i+1,
      acc.email,
      acc.phone || '-',
      visitColor,
      txnColor,
      has1stPop,
      hasComboSolo,
      has3rdB1G1,
      hasTsel10K,
      `${hasActive.length}/${vouchData.length}`
    ]);
  });
  console.log(t.toString());
}

// ========== AUTO ACCOUNT SELECTION ==========
const AUTO_SELECT_ACCOUNT = (process.env.AUTO_SELECT_ACCOUNT || 'false').toLowerCase() === 'true';
const AUTO_ACCOUNT_FILE = process.env.AUTO_ACCOUNT_FILE || 'akuntsel-10k.txt';

let selectedAccount = null;

if (AUTO_SELECT_ACCOUNT) {
  console.log(chalk.cyan(`ğŸ¤– Auto-select mode: ON (file: ${AUTO_ACCOUNT_FILE})`));

  const accountQuery = await readFirstAccountLine(AUTO_ACCOUNT_FILE);

  if (accountQuery) {
    console.log(chalk.gray(`ğŸ“„ Membaca dari file: "${accountQuery}"`));

    const matched = matchAccount(accItems, accountQuery);

    if (matched) {
      selectedAccount = matched;
      console.log(chalk.green(`âœ… Auto-selected: ${matched.email} (${matched.phone || 'no phone'})`));

      // Delete line from file after successful match
      await deleteFirstAccountLine(AUTO_ACCOUNT_FILE);

      await appendJsonLog({
        event: 'account_auto_selected',
        email: matched.email,
        source: AUTO_ACCOUNT_FILE,
        query: accountQuery
      });
    } else {
      console.log(chalk.yellow(`âš ï¸  Tidak ada akun yang cocok dengan "${accountQuery}"`));
      console.log(chalk.yellow(`ğŸ’¡ Fallback: Pilih akun manual...\n`));
      await delay(1500);
    }
  } else {
    // File kosong/tidak ada â†’ monitoring mode
    const MONITORING_INTERVAL = parseInt(process.env.AUTO_ACCOUNT_MONITORING_INTERVAL || '5', 10);

    if (MONITORING_INTERVAL > 0) {
      console.log(chalk.yellow(`âš ï¸  File ${AUTO_ACCOUNT_FILE} kosong atau tidak ada`));
      console.log(chalk.cyan(`ğŸ”„ Mode Monitoring: Cek file setiap ${MONITORING_INTERVAL} detik\n`));

      // Auto-open file editor (non-blocking)
      await openFileInEditor(AUTO_ACCOUNT_FILE);

      console.log(chalk.cyan(`â³ Monitoring dimulai... (tekan Ctrl+C untuk batal)\n`));

      // Monitoring loop (start immediately)
      while (!selectedAccount) {
        await delay(MONITORING_INTERVAL * 1000);

        const query = await readFirstAccountLine(AUTO_ACCOUNT_FILE);

        if (query) {
          console.log(chalk.gray(`ğŸ“„ Terdeteksi akun baru: "${query}"`));

          const matched = matchAccount(accItems, query);

          if (matched) {
            selectedAccount = matched;
            console.log(chalk.green(`âœ… Auto-selected: ${matched.email} (${matched.phone || 'no phone'})`));

            // Delete line from file
            await deleteFirstAccountLine(AUTO_ACCOUNT_FILE);

            await appendJsonLog({
              event: 'account_auto_selected_monitoring',
              email: matched.email,
              source: AUTO_ACCOUNT_FILE,
              query: query
            });

            break;
          } else {
            console.log(chalk.yellow(`âš ï¸  Akun "${query}" tidak cocok, skip & hapus dari file`));
            await deleteFirstAccountLine(AUTO_ACCOUNT_FILE);
          }
        } else {
          console.log(chalk.gray(`â³ File masih kosong... (cek lagi dalam ${MONITORING_INTERVAL}s)`));
        }
      }
    } else {
      console.log(chalk.yellow(`âš ï¸  File ${AUTO_ACCOUNT_FILE} kosong atau tidak ada`));
      console.log(chalk.yellow(`ğŸ’¡ Fallback: Pilih akun manual...\n`));
      await delay(1500);
    }
  }
}

// ========== MANUAL ACCOUNT SELECTION ==========
if (!selectedAccount) {
  renderEnhancedAccountTable(accItems);

  // Enhanced account selection with filter
  let view = accItems;
  let filter = '';

  while (!selectedAccount) {
    console.clear();
    log.header('ğŸ¬ AUTO ORDER', 'Pilih Akun untuk Booking');
    
    if (filter) {
      console.log(chalk.yellow(`Filter aktif: "${filter}" | Ketik /r untuk reset`));
      view = accItems.filter(acc => 
        includesIgnoreCase(acc.email, filter) || 
        includesIgnoreCase(acc.phone || '', filter)
      );
    } else {
      view = accItems;
    }
    
    if (!view.length) {
      console.log(chalk.gray('(Tidak ada hasil - reset filter)'));
    } else {
      renderEnhancedAccountTable(view);
    }

    const { inp } = await inquirer.prompt([{
      type: 'input',
      name: 'inp',
      message: 'Pilih akun (nomor/email/keyword) Â· /f <query> filter Â· /r reset Â· /q batal:',
      filter: s => String(s || '').trim()
    }]);

    const low = inp.toLowerCase();
    if (low === '/q') {
      log.warning('Dibatalkan pada tahap pemilihan akun.');
      return;
    }
    if (low.startsWith('/f ')) {
      filter = inp.slice(3).trim();
      continue;
    }
    if (low === '/r') {
      filter = '';
      continue;
    }

// Select by number (table index or phone number)
if (/^\d+$/.test(inp)) {
  // First check if it's a phone number match
  const phoneMatch = view.find(acc => acc.phone === inp);
  if (phoneMatch) {
    selectedAccount = phoneMatch;
    break;
  }
  
  // Then check if it's a table index (reasonable range)
  if (inp.length <= 3) { // Max 3 digits for table index
    const idx = Number(inp) - 1;
    const row = view[idx];
    if (row) {
      selectedAccount = row;
      break;
    }
  }
  
  log.warning('Nomor tidak valid. Ulangi.');
  await delay(600);
  continue;
}


    // Select by exact email match or filter
    const matches = view.filter(acc => 
      acc.email === inp || 
      (acc.phone && acc.phone === inp) || 
      includesIgnoreCase(acc.email, inp)
    );
    
    if (matches.length === 1) {
      selectedAccount = matches[0];
      break;
    } else if (matches.length > 1) {
      view = matches;
      filter = '';
      continue;
    } else {
      log.warning('Input tidak cocok. Ulangi.');
      await delay(600);
    }
  }
} // End manual selection

log.info(`Using account: ${selectedAccount.email}`);
await appendJsonLog({ event: 'account_selected', email: selectedAccount.email });

// Pastikan bearer
log.process('Ensuring bearer...');
const bearerEns = await ensureBearerForAccount(selectedAccount);
if (!bearerEns.ok) {
  log.error(`Bearer error: ${bearerEns.reason || 'unknown'}`);
  await appendJsonLog({ event: 'session_end', reason: 'no_bearer', detail: bearerEns.reason || 'unknown' });
  return;
}
let token = bearerEns.token;
log.success(`Bearer OK ${chalk.gray(`(${bearerEns.source})`)}`);
await appendJsonLog({ event: 'bearer_ok', source: bearerEns.source, token_masked: maskToken(token) });

log.process('Validating bearer token with CGV API...');
let bearerCheck = await validateBearerTokenWithApi(token);

if (!bearerCheck.ok) {
  log.warn(`Bearer token tidak valid di server CGV (HTTP ${bearerCheck.status}). Mencoba refresh token...`);
  await appendJsonLog({
    event: 'bearer_invalid_first_try',
    http_status: bearerCheck.status
  });

  // ğŸ” Coba refresh bearer (paksa ambil token baru, abaikan cache lama)
  // NOTE:
  // Pastikan implementasi ensureBearerForAccount mendukung opsi { forceRefresh: true }
  // dan DI DALAMNYA dia nggak pakai cache token lama.
  const refreshEns = await ensureBearerForAccount(selectedAccount, { forceRefresh: true });

  if (!refreshEns.ok) {
    log.error(`Gagal refresh bearer token: ${refreshEns.reason || 'unknown'}`);
    await appendJsonLog({
      event: 'session_end',
      reason: 'bearer_refresh_failed',
      detail: refreshEns.reason || 'unknown'
    });
    return;
  }

  token = refreshEns.token;
  log.success(`Berhasil refresh bearer token ${chalk.gray(`(${refreshEns.source})`)}`);
  await appendJsonLog({
    event: 'bearer_refreshed',
    source: refreshEns.source,
    token_masked: maskToken(token)
  });

  // âœ… Validasi ulang token BARU
  bearerCheck = await validateBearerTokenWithApi(token);
  if (!bearerCheck.ok) {
    log.error(`Token baru juga TIDAK valid di server CGV (HTTP ${bearerCheck.status}).`);
    await appendJsonLog({
      event: 'session_end',
      reason: 'bearer_invalid_after_refresh',
      http_status: bearerCheck.status
    });
    return;
  }
}

log.success('Bearer valid di server CGV.');

/**
 * ====== UTIL TAMBAHAN (COPY DARI AUTO ORDER FNB) ======
 */
function safeDecodeJwt(token) {
  try {
    const payload = JSON.parse(
      Buffer.from(String(token || '').split('.')[1] || '', 'base64').toString('utf8')
    );
    return payload || {};
  } catch {
    return {};
  }
}

// Coba panggil getMemberInfo seperti di listAccounts(); jika tidak ada, balikin null
async function tryGetMemberInfo(token) {
  try {
    if (typeof getMemberInfo === 'function') {
      const info = await getMemberInfo(token);
      if (info?.RESULTS?.ds_mbrList) return info;
    }
  } catch {}
  return null;
}

function parseMemberProfileFromInfo(info) {
  if (!info?.RESULTS?.ds_mbrList) return null;
  const m = info.RESULTS.ds_mbrList;
  const points = Number(m.ACCU_POINT ?? m.MILEAGE_AMT ?? 0);
  return {
    name: m.MBR_NM || '-',
    tier_name: m.MBR_GRD_NM || m.MBR_TIER_NM || 'NEW',
    // best-effort code (kalau ada); fallback tetap ke '03' saat pay
    grade_id: m.MBR_GRD_CD || null,
    tier_id:  m.MBR_TIER_CD || null,
    points,
    member_no: m.MBR_NO || null,
    phone: m.MOBILE_NO || null,
    city:  m.ADDR_REGION_NM || null,
    email_id: m.EMAIL_ID || null
  };
}

function extractPointNumber(obj) {
  if (!obj || typeof obj !== 'object') return null;
  const keys = [
    'point', 'points', 'point_balance', 'balance',
    'balance_point', 'available_point', 'available_points'
  ];
  for (const k of keys) {
    const v = obj[k] ?? obj?.data?.[k];
    if (typeof v === 'number' && Number.isFinite(v)) return v;
    if (typeof v === 'string' && /^[0-9]+$/.test(v)) return Number(v);
  }
  return null;
}

async function validateBearerTokenWithApi(token) {
  const url = 'https://v2-api.cgv.id/api/membership/profile';
  try {
    const res = await requestJson('GET', url, {
      headers: {
        accept: 'application/json',
        authorization: `Bearer ${token}`
      },
      silent: true
    });

    const status = res?.status_code ?? res?.status ?? 200;
    // 401 / 403 â†’ token sudah mati / tidak valid
    if (status === 401 || status === 403) {
      return { ok: false, status };
    }
    return { ok: true, status };
  } catch (e) {
    const status = e?.status || e?.response?.status || 0;

    // Kalau server jelas bilang 401/403 di error, anggap invalid
    if (status === 401 || status === 403) {
      return { ok: false, status };
    }

    // Error lain (timeout / network) â†’ jangan matiin flow, anggap ok tapi catat status
    return { ok: true, status: status || 0 };
  }
}

async function probeGet(url, token) {
  try {
    const res = await requestJson('GET', url, {
      headers: { accept: 'application/json', authorization: `Bearer ${token}` },
      silent: true
    });
    const status = (res?.status_code ?? res?.status ?? 200);
    console.log(`HTTP GET ${url} â†’ ${status} | cgv-point-balance`);
    return { ok: true, status, body: res };
  } catch (e) {
    const status = e?.status || e?.response?.status || 0;
    console.log(`HTTP GET ${url} â†’ ${status} | cgv-point-balance`);
    return { ok: false, status, body: null };
  }
}

async function getCgvPointOverviewOrProfile(token, selectedAccount, selectedCinema) {
  // 1) PRIORITAS: getMemberInfo (rujukan dari listAccounts)
  const info = await tryGetMemberInfo(token);
  if (info?.RESULTS?.ds_mbrList) {
    const prof = parseMemberProfileFromInfo(info);
    const claims = safeDecodeJwt(token);
    return {
      // balance akan dipakai di ringkasan â€œkebutuhan pointâ€
      balance: prof.points,
      source: 'getMemberInfo()',
      // profil kaya untuk display
      profile: {
        name: prof.name,
        tier_name: prof.tier_name,
        grade_id: prof.grade_id,
        tier_id: prof.tier_id,
        member_no: prof.member_no,
        email: selectedAccount?.email || prof.email_id || '-',
        phone: (prof.phone || selectedAccount?.phone || '-').replace(/[^0-9+]/g, ''),
        city: prof.city || (selectedAccount?.city || '-'),
        channel_code: claims?.channel_code || '-'
      }
    };
  }

  // 2) FALLBACK: probe endpoints lama (agar log tetap konsisten)
  const base = 'https://v2-api.cgv.id';
  const candidates = [
    '/api/membership/profile',
    '/api/membership/point',
    '/api/membership/points',
    '/api/membership/me'
  ];

  let balance = null;
  let source  = 'n/a';
  for (const path of candidates) {
    const { ok, body } = await probeGet(`${base}${path}`, token);
    if (!ok) continue;
    const data = body?.data ?? body;
    const val  = extractPointNumber(data);
    if (val !== null) { balance = val; source = path; break; }
  }
  const claims = safeDecodeJwt(token);
  return {
    balance,
    source,
    profile: {
      name: selectedAccount?.name || '-',
      tier_name: selectedAccount?.tier || 'NEW',
      grade_id: selectedAccount?.member_grade_id || null,
      tier_id: selectedAccount?.member_tier_id  || null,
      member_no: claims?.member_no || null,
      email: selectedAccount?.email || '-',
      phone: (selectedAccount?.phone || '-').replace(/[^0-9+]/g, ''),
      city: selectedAccount?.city || (selectedCinema?.location_name || '-'),
      channel_code: claims?.channel_code || '-'
    }
  };
}

function renderPointProfileBox(pov) {
  const p = pov?.profile || {};
  const lines = [
    `Nama        : ${p.name || '-'}`,
    `Tier        : ${p.tier_name || '-'}`,
    `Member No   : ${p.member_no || '-'}`,
    `Email       : ${p.email || '-'}`,
    `Phone       : ${p.phone || '-'}`,
    `Kota        : ${p.city  || '-'}`,
    `Saldo Point : ${pov?.balance != null ? pov.balance : '(tidak terdeteksi)'}`,
    `Sumber      : ${pov?.source || 'n/a'}`
  ];
  console.log(multilineBox(lines));
}

// ====== PANGGIL (SAMA PERSIS SEPERTI DI FNB) ======
log.section('ğŸ’  CGV POINT KAMU');
const pointPov = await getCgvPointOverviewOrProfile(token, selectedAccount);
renderPointProfileBox(pointPov);

/**
 * ====== LANJUT ALUR LAMA (AMBIL LOKASI BIOSKOP) ======
 */
log.process('Loading cinema locations...');
const locations = await getAvailableLocations(token);

if (!locations.length) {
  log.error('Gagal ambil data lokasi bioskop.');
  await appendJsonLog({ event: 'session_end', reason: 'no_locations' });
  return;
}

// === QUICK PICK: ketik nama BIOSKOP atau KOTA ===
log.section('ğŸ™ï¸/ğŸ¢ PILIH KOTA ATAU LANGSUNG BIOSKOP');

function cinemaScore(hay, needle) {
  hay = normalize(hay); needle = normalize(needle);
  if (!needle) return 0;

  // Exact match = highest score
  if (hay === needle) return 100;

  // Full substring match = very high score
  if (hay.includes(needle)) return 90;

  // Starts with = high score
  if (hay.startsWith(needle)) return 80;

  // ğŸ†• Token-based scoring with partial matching
  const hTok = hay.split(/\s+/);
  const nTok = needle.split(/\s+/);

  let exactMatches = 0;
  let partialMatches = 0;

  nTok.forEach(nWord => {
    // Check exact word match
    if (hTok.some(hWord => hWord === nWord)) {
      exactMatches++;
    } else {
      // Check partial word match (e.g., "grand" matches "grande", "mal" matches "mall")
      const partialMatch = hTok.some(hWord =>
        hWord.includes(nWord) || nWord.includes(hWord)
      );
      if (partialMatch) {
        partialMatches++;
      }
    }
  });

  // Score: exact matches worth more than partial
  const totalWords = nTok.length;
  const matchRatio = (exactMatches * 1.0 + partialMatches * 0.6) / totalWords;
  return Math.round(matchRatio * 70); // Max 70 for partial matches
}
function findCinemaCandidates(allCinemas, input) {
  return allCinemas
    .map(c => ({
      score: Math.max(
        cinemaScore(c.name, input),
        cinemaScore((c.alias || ''), input),
        cinemaScore(c.location_name || '', input) * 0.6
      ),
      c
    }))
    .filter(x => x.score > 0)
    .sort((a, b) => b.score - a.score || a.c.name.localeCompare(b.c.name))
    .map(x => x.c);
}

// daftar bioskop lintas kota dari cache yang sudah diisi saat fetchEnhancedCinemaList()
const ALL_CINEMAS = (ENHANCED_CINEMA_CACHE.list || []).map(c => ({
  id: c.id,
  name: c.name,
  address: c.address || '-',
  location_id: c.location_id,
  location_name: c.location_name || '-'
}));

const { quickInput } = await inquirer.prompt([{
  type: 'input',
  name: 'quickInput',
  message: 'Ketik nama bioskop (mis: "paskal", "pvj") atau nama kota (mis: "bandung"):',
  filter: s => String(s || '').trim()
}]);

let chosenLocation = null;
let selectedCinema = null;

// === FALLBACK: PILIH KOTA DULU, TAPI SEKARANG BISA LANGSUNG KETIK NAMA BIOSKOP JUGA ===
async function fallbackPickByCity() {
  // tampilkan daftar kota
  log.section('ğŸ“ PILIH LOKASI');
  const locTable = new CliTable({
    head: ['#', 'Kota', 'Jumlah Cinema'],
    wordWrap: true,
    style: { head: ['cyan'] },
    colWidths: [4, 30, 15]
  });
  locations.forEach((loc, i) => {
    locTable.push([i + 1, loc.location_name, `${loc.cinemas.length}`]);
  });
  console.log(locTable.toString());

  // pilih kota ATAU langsung bioskop dari sini
  while (!chosenLocation && !selectedCinema) {
    const { locInput } = await inquirer.prompt([{
      type: 'input',
      name: 'locInput',
      message: 'Pilih lokasi (nomor atau nama kota / nama bioskop):',
      filter: s => String(s || '').trim()
    }]);

    if (!locInput) {
      log.error('Input tidak boleh kosong.');
      continue;
    }

    // 1) kalau angka â†’ pilih kota by index
    if (/^\d+$/.test(locInput)) {
      const idx = Number(locInput) - 1;
      if (locations[idx]) {
        chosenLocation = locations[idx];
        break;
      } else {
        log.error('Nomor tidak valid.');
        continue;
      }
    }

    // 2) coba dulu sebagai NAMA KOTA
    const cityCands = findCityCandidates(locations, locInput);
    if (cityCands.length === 1) {
      chosenLocation = cityCands[0];
      break;
    } else if (cityCands.length > 1) {
      const pick = await inquirer.prompt([{
        type: 'list',
        name: 'locPick',
        message: 'Beberapa kota cocok, pilih salah satu:',
        choices: cityCands.slice(0, 10).map(l => ({
          name: `${l.location_name} (${l.cinemas.length})`,
          value: l
        }))
      }]);
      chosenLocation = pick.locPick;
      break;
    }

    // 3) kalau bukan kota â†’ anggap sebagai NAMA BIOSKOP (smart)
    const cinemaCandsRaw = findCinemaCandidates(ALL_CINEMAS, locInput);
    // ğŸ†• Lower threshold untuk lebih permissive
    const cinemaCands = cinemaCandsRaw.filter(c =>
      includesIgnoreCase(c.name, locInput) ||
      cinemaScore(c.name, locInput) >= 35
    );

    if (cinemaCands.length === 1) {
      // Auto pilih bioskop + location
      selectedCinema = cinemaCands[0];

      // cari location sesuai cinema ini
      const locFromList = locations.find(l => l.location_id === selectedCinema.location_id);
      if (locFromList) {
        chosenLocation = locFromList;
      } else {
        const byLoc = ENHANCED_CINEMA_CACHE.byLocation.get(selectedCinema.location_id);
        chosenLocation = byLoc ? { ...byLoc, cinemas: byLoc.cinemas } : {
          location_id: selectedCinema.location_id,
          location_name: selectedCinema.location_name,
          cinemas: ALL_CINEMAS.filter(x => x.location_id === selectedCinema.location_id)
        };
      }

      log.info(`Selected cinema (quick via lokasi prompt): ${selectedCinema.name} â€” ${chosenLocation.location_name}`);
      return; // sudah dapat dua-duanya, langsung keluar
    } else if (cinemaCands.length > 1) {
      // banyak bioskop cocok â†’ tampilkan tabel, biar pilih nomor
      const t = new CliTable({
        head: ['#', 'Cinema Name', 'City', 'Address'],
        wordWrap: true,
        style: { head: ['cyan'] },
        colWidths: [4, 30, 18, 50]
      });
      cinemaCands.slice(0, 12).forEach((c, i) => {
        t.push([i + 1, c.name, c.location_name || '-', c.address || '-']);
      });
      console.log(t.toString());

      // ğŸ†• Allow re-search dengan nama baru
      let searchComplete = false;
      while (!searchComplete) {
        const { pickIdx } = await inquirer.prompt([{
          type: 'input',
          name: 'pickIdx',
          message: 'Pilih bioskop (nomor ATAU ketik nama bioskop untuk cari lagi):',
          filter: s => String(s || '').trim()
        }]);

        if (!pickIdx) {
          log.error('Input tidak boleh kosong.');
          continue;
        }

        if (/^\d+$/.test(pickIdx)) {
          const idx = Number(pickIdx) - 1;
          const picked = cinemaCands[idx];
          if (picked) {
            selectedCinema = picked;

            const locFromList = locations.find(l => l.location_id === selectedCinema.location_id);
            if (locFromList) {
              chosenLocation = locFromList;
            } else {
              const byLoc = ENHANCED_CINEMA_CACHE.byLocation.get(selectedCinema.location_id);
              chosenLocation = byLoc ? { ...byLoc, cinemas: byLoc.cinemas } : {
                location_id: selectedCinema.location_id,
                location_name: selectedCinema.location_name,
                cinemas: ALL_CINEMAS.filter(x => x.location_id === selectedCinema.location_id)
              };
            }

            log.info(`Selected cinema: ${selectedCinema.name} â€” ${chosenLocation.location_name}`);
            searchComplete = true;
            return;
          } else {
            log.error('Nomor tidak valid.');
            continue;
          }
        }

        // User ketik nama â†’ re-search
        const newCands = findCinemaCandidates(ALL_CINEMAS, pickIdx)
          .filter(c => includesIgnoreCase(c.name, pickIdx) || cinemaScore(c.name, pickIdx) >= 35);

        if (newCands.length === 0) {
          log.error(`Tidak ditemukan bioskop untuk: "${pickIdx}". Coba lagi.`);
          continue;
        }

        if (newCands.length === 1) {
          selectedCinema = newCands[0];
          const locFromList = locations.find(l => l.location_id === selectedCinema.location_id);
          if (locFromList) {
            chosenLocation = locFromList;
          } else {
            const byLoc = ENHANCED_CINEMA_CACHE.byLocation.get(selectedCinema.location_id);
            chosenLocation = byLoc ? { ...byLoc, cinemas: byLoc.cinemas } : {
              location_id: selectedCinema.location_id,
              location_name: selectedCinema.location_name,
              cinemas: ALL_CINEMAS.filter(x => x.location_id === selectedCinema.location_id)
            };
          }
          log.info(`Selected cinema: ${selectedCinema.name} â€” ${chosenLocation.location_name}`);
          searchComplete = true;
          return;
        }

        // ğŸ†• SMART AUTO-SELECT: Cek apakah ada 1 bioskop dengan score sangat tinggi (>= 80)
        const highScoreFallback = newCands
          .map(c => ({ c, score: cinemaScore(c.name, pickIdx) }))
          .filter(x => x.score >= 80);

        if (highScoreFallback.length === 1) {
          selectedCinema = highScoreFallback[0].c;
          const locFromList = locations.find(l => l.location_id === selectedCinema.location_id);
          if (locFromList) {
            chosenLocation = locFromList;
          } else {
            const byLoc = ENHANCED_CINEMA_CACHE.byLocation.get(selectedCinema.location_id);
            chosenLocation = byLoc ? { ...byLoc, cinemas: byLoc.cinemas } : {
              location_id: selectedCinema.location_id,
              location_name: selectedCinema.location_name,
              cinemas: ALL_CINEMAS.filter(x => x.location_id === selectedCinema.location_id)
            };
          }
          log.info(`Selected cinema (auto - high match): ${selectedCinema.name} â€” ${chosenLocation.location_name}`);
          searchComplete = true;
          return;
        }

        // Update table
        const newTable = new CliTable({
          head: ['#', 'Cinema Name', 'City', 'Address'],
          wordWrap: true,
          style: { head: ['cyan'] },
          colWidths: [4, 30, 18, 50]
        });
        newCands.slice(0, 12).forEach((c, i) => {
          newTable.push([i + 1, c.name, c.location_name || '-', c.address || '-']);
        });
        console.log(newTable.toString());
        cinemaCands.length = 0;
        cinemaCands.push(...newCands);
      }
    } else {
      log.error('Lokasi/bioskop tidak ditemukan. Coba nama kota atau bioskop lain.');
    }
  }

  // Kalau sudah dapat kota tapi belum pilih bioskop â†’ lanjut pilih bioskop di kota tsb
  if (chosenLocation && !selectedCinema) {
    // ğŸ†• SMART: Auto-select bioskop kalau cuma ada 1
    if (chosenLocation.cinemas.length === 1) {
      selectedCinema = chosenLocation.cinemas[0];
      log.info(`Selected cinema  : ${selectedCinema.name}`);
    } else {
      // Banyak bioskop di kota ini â†’ tampilkan tabel + minta pilih
      log.section('ğŸ¢ PILIH BIOSKOP');
      renderCinemaTable(chosenLocation.cinemas);

      while (!selectedCinema) {
        const { cinemaInput } = await inquirer.prompt([{
          type: 'input',
          name: 'cinemaInput',
          message: 'Pilih bioskop (nomor atau keyword):',
          filter: s => String(s || '').trim()
        }]);

        if (!cinemaInput) {
          log.error('Input tidak boleh kosong.');
          continue;
        }

        if (/^\d+$/.test(cinemaInput)) {
          const idx = Number(cinemaInput) - 1;
          if (chosenLocation.cinemas[idx]) {
            selectedCinema = chosenLocation.cinemas[idx];
          } else {
            log.error('Nomor tidak valid.');
          }
        } else {
          const filtered = chosenLocation.cinemas.filter(c => includesIgnoreCase(c.name, cinemaInput));
          if (filtered.length === 1) {
            selectedCinema = filtered[0];
          } else if (!filtered.length) {
            log.error('Bioskop tidak ditemukan.');
          } else {
            const pick = await inquirer.prompt([{
              type: 'list',
              name: 'cinPick',
              message: 'Beberapa bioskop cocok, pilih salah satu:',
              choices: filtered.map(c => ({ name: c.name, value: c }))
            }]);
            selectedCinema = pick.cinPick;
          }
        }
      }
    }
  }
}

// ==== MAIN BRANCH QUICK INPUT ====
if (!quickInput) {
  await fallbackPickByCity();
} else {
  // coba anggap sebagai nama BIOSKOP dulu
  // ğŸ†• Lower threshold (35 instead of 60) untuk lebih permissive
  const cinemaCands = findCinemaCandidates(ALL_CINEMAS, quickInput)
    .filter(c => includesIgnoreCase(c.name, quickInput) || cinemaScore(c.name, quickInput) >= 35);

  if (cinemaCands.length === 1) {
    selectedCinema = cinemaCands[0];
    const byLoc = ENHANCED_CINEMA_CACHE.byLocation.get(selectedCinema.location_id);
    chosenLocation = byLoc ? { ...byLoc, cinemas: byLoc.cinemas } : {
      location_id: selectedCinema.location_id,
      location_name: selectedCinema.location_name,
      cinemas: ALL_CINEMAS.filter(x => x.location_id === selectedCinema.location_id)
    };
    log.info(`Selected cinema (auto): ${selectedCinema.name} â€” ${selectedCinema.location_name}`);
  } else if (cinemaCands.length > 1) {
    // ğŸ†• SMART AUTO-SELECT: Cek apakah ada 1 bioskop dengan score sangat tinggi (>= 80)
    const highScoreCands = cinemaCands
      .map(c => ({ c, score: cinemaScore(c.name, quickInput) }))
      .filter(x => x.score >= 80);

    if (highScoreCands.length === 1) {
      // Auto-select karena cuma 1 yang match sangat tinggi
      selectedCinema = highScoreCands[0].c;
      const byLoc = ENHANCED_CINEMA_CACHE.byLocation.get(selectedCinema.location_id);
      chosenLocation = byLoc ? { ...byLoc, cinemas: byLoc.cinemas } : {
        location_id: selectedCinema.location_id,
        location_name: selectedCinema.location_name,
        cinemas: ALL_CINEMAS.filter(x => x.location_id === selectedCinema.location_id)
      };
      log.info(`Selected cinema (auto - high match): ${selectedCinema.name} â€” ${selectedCinema.location_name}`);
    } else {
    // tampilkan kandidat bioskop lintas kota
    const t = new CliTable({
      head: ['#', 'Cinema Name', 'City', 'Address'],
      wordWrap: true,
      style: { head: ['cyan'] },
      colWidths: [4, 30, 18, 50]
    });
    cinemaCands.slice(0, 12).forEach((c, i) => {
      t.push([i + 1, c.name, c.location_name || '-', c.address || '-']);
    });
    console.log(t.toString());

    // ğŸ†• Loop untuk allow re-search dengan nama baru
    while (!selectedCinema) {
      const { pickIdx } = await inquirer.prompt([{
        type: 'input',
        name: 'pickIdx',
        message: 'Pilih bioskop (nomor ATAU ketik nama bioskop untuk cari lagi):',
        filter: s => String(s || '').trim()
      }]);

      if (!pickIdx) {
        log.error('Input tidak boleh kosong.');
        continue;
      }

      // Check if input is a number
      if (/^\d+$/.test(pickIdx)) {
        const idx = Number(pickIdx) - 1;
        const picked = cinemaCands[idx];
        if (picked) {
          selectedCinema = picked;
          const byLoc = ENHANCED_CINEMA_CACHE.byLocation.get(selectedCinema.location_id);
          chosenLocation = byLoc ? { ...byLoc, cinemas: byLoc.cinemas } : {
            location_id: selectedCinema.location_id,
            location_name: selectedCinema.location_name,
            cinemas: ALL_CINEMAS.filter(x => x.location_id === selectedCinema.location_id)
          };
          break;
        } else {
          log.error('Nomor tidak valid.');
          continue;
        }
      }

      // ğŸ†• User ketik nama â†’ re-search!
      const newCands = findCinemaCandidates(ALL_CINEMAS, pickIdx)
        .filter(c => includesIgnoreCase(c.name, pickIdx) || cinemaScore(c.name, pickIdx) >= 35);

      if (newCands.length === 0) {
        log.error(`Tidak ditemukan bioskop untuk: "${pickIdx}". Coba lagi.`);
        continue;
      }

      if (newCands.length === 1) {
        // Auto-select kalau cuma 1
        selectedCinema = newCands[0];
        const byLoc = ENHANCED_CINEMA_CACHE.byLocation.get(selectedCinema.location_id);
        chosenLocation = byLoc ? { ...byLoc, cinemas: byLoc.cinemas } : {
          location_id: selectedCinema.location_id,
          location_name: selectedCinema.location_name,
          cinemas: ALL_CINEMAS.filter(x => x.location_id === selectedCinema.location_id)
        };
        log.info(`Selected cinema: ${selectedCinema.name} â€” ${selectedCinema.location_name}`);
        break;
      }

      // ğŸ†• SMART AUTO-SELECT: Cek apakah ada 1 bioskop dengan score sangat tinggi (>= 80)
      const highScoreNew = newCands
        .map(c => ({ c, score: cinemaScore(c.name, pickIdx) }))
        .filter(x => x.score >= 80);

      if (highScoreNew.length === 1) {
        // Auto-select karena cuma 1 yang match sangat tinggi
        selectedCinema = highScoreNew[0].c;
        const byLoc = ENHANCED_CINEMA_CACHE.byLocation.get(selectedCinema.location_id);
        chosenLocation = byLoc ? { ...byLoc, cinemas: byLoc.cinemas } : {
          location_id: selectedCinema.location_id,
          location_name: selectedCinema.location_name,
          cinemas: ALL_CINEMAS.filter(x => x.location_id === selectedCinema.location_id)
        };
        log.info(`Selected cinema (auto - high match): ${selectedCinema.name} â€” ${selectedCinema.location_name}`);
        break;
      }

      // Update table dengan hasil search baru
      const newTable = new CliTable({
        head: ['#', 'Cinema Name', 'City', 'Address'],
        wordWrap: true,
        style: { head: ['cyan'] },
        colWidths: [4, 30, 18, 50]
      });
      newCands.slice(0, 12).forEach((c, i) => {
        newTable.push([i + 1, c.name, c.location_name || '-', c.address || '-']);
      });
      console.log(newTable.toString());
      // Update cinemaCands untuk iterasi selanjutnya
      cinemaCands.length = 0;
      cinemaCands.push(...newCands);
    }
    }
  } else {
    // tidak match bioskop â†’ coba sebagai KOTA
    const candidates = findCityCandidates(locations, quickInput);
    if (candidates.length === 1) {
      chosenLocation = candidates[0];
      log.info(`Selected location (auto): ${chosenLocation.location_name}`);

      // ğŸ†• SMART: Auto-select bioskop kalau cuma ada 1
      if (chosenLocation.cinemas.length === 1) {
        selectedCinema = chosenLocation.cinemas[0];
        log.info(`Selected cinema  : ${selectedCinema.name}`);
      } else {
        // Banyak bioskop di kota ini â†’ tampilkan tabel + minta pilih
        log.section('ğŸ¢ PILIH BIOSKOP');
        renderCinemaTable(chosenLocation.cinemas);
        while (!selectedCinema) {
          const { cinemaInput } = await inquirer.prompt([{
            type: 'input',
            name: 'cinemaInput',
            message: 'Pilih bioskop (nomor atau keyword):',
            filter: s => String(s || '').trim()
          }]);
          if (/^\d+$/.test(cinemaInput)) {
            const index = parseInt(cinemaInput, 10) - 1;
            if (index >= 0 && index < chosenLocation.cinemas.length) selectedCinema = chosenLocation.cinemas[index];
            else log.error('Nomor tidak valid.');
          } else {
            const filtered = chosenLocation.cinemas.filter(c => includesIgnoreCase(c.name, cinemaInput));
            if (filtered.length === 1) selectedCinema = filtered[0];
            else if (filtered.length > 1) {
              const pick = await inquirer.prompt([{
                type: 'list',
                name: 'cinPick',
                message: 'Beberapa bioskop cocok, pilih salah satu:',
                choices: filtered.map(c => ({ name: c.name, value: c }))
              }]);
              selectedCinema = pick.cinPick;
            } else {
              log.error('Bioskop tidak ditemukan.');
            }
          }
        }
      }
    } else if (candidates.length > 1) {
      const pick = await inquirer.prompt([{
        type: 'list',
        name: 'locPick',
        message: 'Beberapa kota cocok, pilih salah satu:',
        choices: candidates.slice(0, 10).map(l => ({ name: `${l.location_name} (${l.cinemas.length})`, value: l }))
      }]);
      chosenLocation = pick.locPick;

      // ğŸ†• SMART: Auto-select bioskop kalau cuma ada 1
      if (chosenLocation.cinemas.length === 1) {
        selectedCinema = chosenLocation.cinemas[0];
        log.info(`Selected cinema  : ${selectedCinema.name}`);
      } else {
        // Banyak bioskop di kota ini â†’ tampilkan tabel + minta pilih
        log.section('ğŸ¢ PILIH BIOSKOP');
        renderCinemaTable(chosenLocation.cinemas);
        const { cinemaInput } = await inquirer.prompt([{
          type: 'input',
          name: 'cinemaInput',
          message: 'Pilih bioskop (nomor atau keyword):',
          filter: s => String(s || '').trim()
        }]);
        if (/^\d+$/.test(cinemaInput)) {
          const index = parseInt(cinemaInput, 10) - 1;
          if (index >= 0 && index < chosenLocation.cinemas.length) {
            selectedCinema = chosenLocation.cinemas[index];
          } else { log.error('Nomor tidak valid.'); }
        } else {
          const filtered = chosenLocation.cinemas.filter(c => includesIgnoreCase(c.name, cinemaInput));
          if (filtered.length === 1) selectedCinema = filtered[0];
          else {
            const pick2 = await inquirer.prompt([{
              type: 'list',
              name: 'cinPick',
              message: 'Beberapa bioskop cocok, pilih salah satu:',
              choices: filtered.map(c => ({ name: c.name, value: c }))
            }]);
            selectedCinema = pick2.cinPick;
          }
        }
      }
    } else {
      log.warning(`Tidak ketemu kota/bioskop untuk input: "${quickInput}". Menampilkan daftar kotaâ€¦`);
      await fallbackPickByCity();
    }
  }
}

log.info(`Selected location: ${chosenLocation.location_name}`);
log.info(`Selected cinema  : ${selectedCinema.name}`);
await appendJsonLog({
  event: 'cinema_selected',
  location: chosenLocation.location_name,
  cinema: { id: selectedCinema.id, name: selectedCinema.name }
});


// Load movies
log.process('Loading movies...');

const [playingRes, upcomingRes] = await Promise.all([
  fetchMoviesPlaying(chosenLocation.location_id, token),
  fetchMoviesUpcoming(chosenLocation.location_id, token)
]);

const playingMovies = (playingRes?.data || []).map(formatMovieInfo);
const upcomingMovies = (upcomingRes?.data || []).map(formatMovieInfo);

if (!playingMovies.length && !upcomingMovies.length) {
  log.error('Tidak ada film untuk lokasi ini.');
  await appendJsonLog({ event: 'session_end', reason: 'no_movies' });
  return;
}

// ====== NEW: quick search film berdasarkan keyword ======
log.section('ğŸ¬ PILIH FILM');

let movieType = null;      // 'playing' | 'upcoming'
let selectedMovie = null;  // object film terpilih

const { movieKeyword } = await inquirer.prompt([{
  type: 'input',
  name: 'movieKeyword',
  message: 'Ketik nama film (Enter=lewati & pilih manual dari kategori):',
  filter: (s) => String(s || '').trim()
}]);

if (movieKeyword) {
  const kw = movieKeyword.toLowerCase();
  const matches = [];

  const pushMatches = (list, type) => {
    (list || []).forEach(m => {
      const name = String(m.name || '').toLowerCase();
      if (name.includes(kw)) {
        matches.push({ movie: m, type });
      }
    });
  };

  pushMatches(playingMovies, 'playing');
  pushMatches(upcomingMovies, 'upcoming');

  if (!matches.length) {
    log.warning(`Tidak ada film yang cocok dengan keyword: "${movieKeyword}". Lanjut pilih manual.`);
  } else if (matches.length === 1) {
    movieType = matches[0].type;
    selectedMovie = { ...matches[0].movie, status: movieType.toUpperCase() };
    log.info(
      `Auto memilih film: ${selectedMovie.name} (${movieType === 'playing' ? 'Sedang tayang' : 'Akan tayang'})`
    );
  } else {
    const { pickedIndex } = await inquirer.prompt([{
      type: 'list',
      name: 'pickedIndex',
      message: 'Ditemukan beberapa film cocok, pilih salah satu:',
      choices: matches.map((m, idx) => ({
        name: `${idx + 1}. ${m.movie.name} ${m.type === 'playing' ? '[Sedang tayang]' : '[Akan tayang]'}`,
        value: idx
      }))
    }]);

    const picked = matches[pickedIndex];
    movieType = picked.type;
    selectedMovie = { ...picked.movie, status: movieType.toUpperCase() };
    log.info(
      `Memilih film: ${selectedMovie.name} (${movieType === 'playing' ? 'Sedang tayang' : 'Akan tayang'})`
    );
  }
}

// ====== Flow lama: pilih jenis film kalau belum ditentukan dari keyword ======

// Pilih jenis film dulu (kalau belum)
if (!movieType) {
  const movieTypes = [];
  if (playingMovies.length) movieTypes.push({ name: 'ğŸ­ Film sedang tayang', value: 'playing' });
  if (upcomingMovies.length) movieTypes.push({ name: 'ğŸ”® Film akan tayang', value: 'upcoming' });

  const ansType = await inquirer.prompt([{
    type: 'list',
    name: 'movieType',
    message: 'Pilih jenis film:',
    choices: movieTypes
  }]);
  movieType = ansType.movieType;
}

const selectedMovieList = movieType === 'playing' ? playingMovies : upcomingMovies;

if (!selectedMovieList.length) {
  log.error('Tidak ada film untuk kategori ini.');
  await appendJsonLog({ event: 'session_end', reason: 'no_movies_for_type', movieType });
  return;
}

// Kalau belum ada selectedMovie dari quick-search â†’ pakai flow pilih manual seperti sebelumnya
if (!selectedMovie) {
  log.section(`${movieType === 'playing' ? 'ğŸ­ SEDANG TAYANG' : 'ğŸ”® AKAN TAYANG'}`);
  renderMoviesTable(selectedMovieList, movieType.toUpperCase());

  while (!selectedMovie) {
    const { movieInput } = await inquirer.prompt([{
      type: 'input',
      name: 'movieInput',
      message: 'Pilih film (nomor atau keyword):',
      filter: (s)=>String(s||'').trim()
    }]);

    if (/^\d+$/.test(movieInput)) {
      const index = parseInt(movieInput) - 1;
      if (index >= 0 && index < selectedMovieList.length) {
        selectedMovie = { ...selectedMovieList[index], status: movieType.toUpperCase() };
      } else {
        log.error('Nomor tidak valid. Coba lagi.');
      }
    } else {
      const filtered = selectedMovieList.filter(m =>
        m.name.toLowerCase().includes(movieInput.toLowerCase())
      );
      if (filtered.length === 1) {
        selectedMovie = { ...filtered[0], status: movieType.toUpperCase() };
      } else if (filtered.length > 1) {
        log.warning('Beberapa film cocok:');
        filtered.forEach((m, i) => {
          console.log(`${i+1}. ${m.name}`);
        });
      } else {
        log.error('Film tidak ditemukan. Coba lagi.');
      }
    }
  }
}

log.info(`Selected movie  : ${selectedMovie.name}`);
await appendJsonLog({
  event: 'movie_selected',
  movie: {
    id: selectedMovie.id,
    name: selectedMovie.name,
    status: selectedMovie.status
  }
});


// --- Cek jadwal tersedia dulu ---
const today = new Date();
const currentYear = today.getFullYear();
const currentMonth = String(today.getMonth() + 1).padStart(2, '0');
const currentDay = String(today.getDate()).padStart(2, '0');

// Tentukan berapa hari ke depan yg discan
// - playing  : 10 hari (hari ini + 10 hari ke depan)
// - upcoming : 20 hari (hari ini + 20 hari ke depan)
const scanDays = movieType === 'playing' ? 10 : 20;

// Auto-select date based on .env configuration
const autoSelectToday = (process.env.AUTO_SELECT_TODAY || 'false').toLowerCase() === 'true';
const autoSelectJumat = (process.env.AUTO_SELECT_JUMAT || 'false').toLowerCase() === 'true';

// OPTIMIZATION: Jika auto-select aktif, cek hari target dulu (1 API call), baru scan 10 hari jika gagal
let availableDates = [];
let quickCheckSuccess = false;

if ((autoSelectToday || autoSelectJumat) && movieType === 'playing') {
  // Quick check: Cek hari target dulu tanpa loop 10 hari
  let targetDate = null;
  let targetDayLabel = '';

  if (autoSelectJumat) {
    // Cari hari Jumat terdekat
    const today = new Date(currentYear, Number(currentMonth) - 1, Number(currentDay));
    const dayOfWeek = today.getDay(); // 0=Sunday, 5=Friday
    const daysUntilFriday = dayOfWeek <= 5 ? (5 - dayOfWeek) : (7 - dayOfWeek + 5);
    const friday = new Date(today);
    friday.setDate(today.getDate() + daysUntilFriday);

    targetDate = [
      friday.getFullYear(),
      String(friday.getMonth() + 1).padStart(2, '0'),
      String(friday.getDate()).padStart(2, '0')
    ].join('');
    targetDayLabel = 'Jumat';
  } else if (autoSelectToday) {
    // Hari ini
    targetDate = todayYmd();
    const today = new Date();
    targetDayLabel = today.toLocaleDateString('id-ID', { weekday: 'long' });
  }

  if (targetDate) {
    log.process(`Quick check: Mengecek jadwal untuk hari ${targetDayLabel}...`);
    const scheduleRes = await fetchMovieSchedules(
      selectedMovie.id,
      chosenLocation.location_id,
      targetDate,
      token
    );

    const cinemasData = scheduleRes?.data?.cinemas || [];
    const hasSchedules = cinemasData.some(c =>
      Array.isArray(c.schedule_types) &&
      c.schedule_types.some(
        st => Array.isArray(st.schedules) && st.schedules.length
      )
    );

    if (hasSchedules) {
      availableDates.push(targetDate);
      quickCheckSuccess = true;
      log.success(`âœ… Jadwal ditemukan untuk hari ${targetDayLabel}!`);
    } else {
      log.warning(`âš ï¸  Tidak ada jadwal untuk hari ${targetDayLabel}, fallback ke scan 10 hari...`);
    }
  }
}

// Jika quick check gagal atau auto-select tidak aktif, scan 10 hari
if (!quickCheckSuccess) {
  log.process(
    `Checking available schedules for the next ${scanDays} days...`
  );

  const base = new Date(currentYear, Number(currentMonth) - 1, Number(currentDay));
  for (let i = 0; i <= scanDays; i++) {
    const d = new Date(base);
    d.setDate(base.getDate() + i);

    const checkDate = [
      d.getFullYear(),
      String(d.getMonth() + 1).padStart(2, '0'),
      String(d.getDate()).padStart(2, '0')
    ].join('');

    const scheduleRes = await fetchMovieSchedules(
      selectedMovie.id,
      chosenLocation.location_id,
      checkDate,
      token
    );

    const cinemasData = scheduleRes?.data?.cinemas || [];

    const hasSchedules = cinemasData.some(c =>
      Array.isArray(c.schedule_types) &&
      c.schedule_types.some(
        st => Array.isArray(st.schedules) && st.schedules.length
      )
    );

    if (hasSchedules) {
      availableDates.push(checkDate);
    }
  }
}

// Jika hanya ada 1 tanggal tersedia DAN auto-select aktif, langsung pilih tanpa tampilkan tabel
if (availableDates.length === 1 && (autoSelectToday || autoSelectJumat) && movieType === 'playing') {
  // Skip table display, langsung auto-select di bawah
} else if (availableDates.length) {
  // Tampilkan tabel jika lebih dari 1 tanggal atau auto-select tidak aktif
  log.info('Tanggal dengan jadwal tersedia:');
  const dateTable = new CliTable({
    head: ['Tanggal', 'Hari', 'Status'],
    wordWrap: true,
    style: { head: ['green'] },
    colWidths: [12, 12, 20]
  });

  availableDates.forEach(date => {
    const d = new Date(
      `${date.slice(0, 4)}-${date.slice(4, 6)}-${date.slice(6, 8)}`
    );
    const dayName = d.toLocaleDateString('id-ID', { weekday: 'long' });
    const isToday = date === todayYmd();
    const status = isToday ? 'âœ… Hari ini' : 'ğŸ“… Tersedia';
    dateTable.push([
      `${date.slice(6, 8)}/${date.slice(4, 6)}`,
      dayName,
      status
    ]);
  });
  console.log(dateTable.toString());
}

// Tampilkan pilihan tanggal tersedia dan user pilih
if (!availableDates.length) {
  const reason =
    movieType === 'playing'
      ? `dalam ${scanDays} hari ke depan.`
      : `dalam ${scanDays} hari ke depan (mungkin jadwal belum dirilis untuk film akan tayang).`;
  log.error(`Tidak ada jadwal tersedia untuk film ini ${reason}`);
  return;
}

let dateYmd = null;
let targetDayName = null;

// Priority: AUTO_SELECT_JUMAT > AUTO_SELECT_TODAY
// Tapi hanya jika movieType === 'playing' (SEDANG TAYANG)
if (movieType === 'playing') {
  if (autoSelectJumat) {
    targetDayName = 'Jumat';
  } else if (autoSelectToday) {
    // Get current day name from system
    const today = new Date();
    targetDayName = today.toLocaleDateString('id-ID', { weekday: 'long' });
  }
} else {
  // Film "AKAN TAYANG" (upcoming) â†’ selalu pilih manual, abaikan AUTO_SELECT
  if (autoSelectToday || autoSelectJumat) {
    log.info('â„¹ï¸  Film "AKAN TAYANG" â†’ Auto-select dinonaktifkan, pilih tanggal manual.');
  }
}

if (targetDayName) {
  // Find the first date that matches the target day
  const matchedDate = availableDates.find(date => {
    const d = new Date(
      `${date.slice(0, 4)}-${date.slice(4, 6)}-${date.slice(6, 8)}`
    );
    const dayName = d.toLocaleDateString('id-ID', { weekday: 'long' });
    return dayName === targetDayName;
  });

  if (matchedDate) {
    dateYmd = matchedDate;
    const d = new Date(
      `${matchedDate.slice(0, 4)}-${matchedDate.slice(4, 6)}-${matchedDate.slice(6, 8)}`
    );
    const dayName = d.toLocaleDateString('id-ID', { weekday: 'long' });
    const dateDisplay = `${matchedDate.slice(6, 8)}/${matchedDate.slice(4, 6)}/${matchedDate.slice(0, 4)}`;
    log.success(`âœ… Auto-select tanggal ${dayName}: ${dateDisplay}`);
  } else {
    log.warning(`âš ï¸  Tidak ada jadwal untuk hari ${targetDayName}. Silakan pilih manual.`);
  }
}

// If auto-select is OFF or no match found, prompt user
if (!dateYmd) {
  const { selectedDate } = await inquirer.prompt([{
    type: 'list',
    name: 'selectedDate',
    message: 'Pilih tanggal nonton:',
    choices: availableDates.map(date => {
      const d = new Date(
        `${date.slice(0, 4)}-${date.slice(4, 6)}-${date.slice(6, 8)}`
      );
      const dayName = d.toLocaleDateString('id-ID', { weekday: 'long' });
      const isToday = date === todayYmd();
      const dateDisplay = `${date.slice(6, 8)}/${date.slice(4, 6)}/${date.slice(0, 4)}`;
      const status = isToday ? 'âœ… Hari ini' : '';
      return {
        name: `${dateDisplay} - ${dayName} ${status}`,
        value: date
      };
    })
  }]);
  dateYmd = selectedDate;
}
await appendJsonLog({ event: 'date_selected', dateYmd });

// --- Ambil jadwal untuk tanggal terpilih
const scheduleRes = await fetchMovieSchedules(
  selectedMovie.id,
  chosenLocation.location_id,
  dateYmd,
  token
);
const cinemasData = scheduleRes?.data?.cinemas || [];

// Flatten schedules
const flatSched = [];
cinemasData.forEach(c => {
  (c.schedule_types || []).forEach(st => {
    (st.schedules || []).forEach(s => {
      flatSched.push({
        schedule_id: s.id,
        start_time: s.start_time,
        end_time: s.end_time,
        remaining: s.remaining_seat_count,
        total: s.total_seat_count,
        cinema_id: c.id,
        cinema_name: c.name,
        movie_type_id: st.movie_type_id,
        movie_type_name:
          st.movie_type || st.auditorium_type_name || 'Regular',
        auditorium_name: st.auditorium_name,
        movie_format: st.movie_format,
        price: st.price
      });
    });
  });
});
flatSched.sort((a, b) => a.start_time.localeCompare(b.start_time));

// Fokuskan ke bioskop terpilih dulu (kalau ada)
const inThisCinema = flatSched.filter(s => s.cinema_id === selectedCinema.id);
const baseList = inThisCinema.length ? inThisCinema : flatSched;


// ===== Helpers jam =====
function normalizeTimeInput(inp) {
  const s = String(inp||'').trim();
  if (!s) return '';
  // dukung: "13", "1300", "13.00", "13:00", "9", "0930"
  const m = s.match(/^(\d{1,2})(?::|\.|h)?(\d{2})?$/i) || s.match(/^(\d{1,2})(\d{2})$/);
  if (!m) return '';
  let hh = parseInt(m[1],10);
  let mm = m[2]!=null ? parseInt(m[2],10) : 0;
  if (Number.isNaN(hh) || Number.isNaN(mm) || hh<0 || hh>23 || mm<0 || mm>59) return '';
  return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}`;
}
const tToMin = (t)=> {
  const [hh,mm] = String(t||'00:00').split(':').map(n=>parseInt(n,10)||0);
  return hh*60+mm;
};

// 1) tampilkan semua jadwal dulu
log.section('ğŸ•˜ JADWAL TERSEDIA');
renderSchedulesTable(baseList);

// AUTO-SELECT: Jika hanya ada 1 jadwal tersedia DAN auto-select aktif, langsung pilih
let selectedSchedule = null;
const autoSelectSchedule = (process.env.AUTO_SELECT_TODAY || process.env.AUTO_SELECT_JUMAT || 'false').toLowerCase() === 'true';

if (baseList.length === 1 && autoSelectSchedule && movieType === 'playing') {
  selectedSchedule = baseList[0];
  const dayName = new Date(`${dateYmd.slice(0, 4)}-${dateYmd.slice(4, 6)}-${dateYmd.slice(6, 8)}`).toLocaleDateString('id-ID', { weekday: 'long' });
  log.success(`âœ… Auto-select jadwal: ${selectedSchedule.start_time} (hanya 1 jadwal tersedia untuk ${dayName})`);
}

// 2) Input fleksibel: jam persis / jam mendekati (â†’ filter) / nomor / /all untuk reset
let currentList = baseList.slice();
const allTimes = new Set(baseList.map(s => s.start_time));

while (!selectedSchedule) {
  const { pick } = await inquirer.prompt([{
    type: 'input',
    name: 'pick',
    message: 'Ketik jam (mis: 16:00) untuk filter/auto-pilih, ATAU nomor baris. /all untuk lihat semua:',
    filter: s => String(s||'').trim()
  }]);

  if (!pick) { log.warning('Input kosong. Ulangi.'); continue; }

  // reset ke semua
  if (pick.toLowerCase() === '/all') {
    currentList = baseList.slice();
    log.info('Menampilkan semua jadwal.');
    renderSchedulesTable(currentList);
    continue;
  }

  // pilih via nomor baris (mengacu ke daftar yang sedang ditampilkan)
  if (/^\d+$/.test(pick)) {
    const idx = parseInt(pick,10) - 1;
    if (idx >= 0 && idx < currentList.length) {
      selectedSchedule = currentList[idx];
      break;
    }
    log.error('Nomor tidak valid di tabel saat ini. Coba lagi.');
    continue;
  }

  // coba parse jam
  const tnorm = normalizeTimeInput(pick);
  if (!tnorm) {
    log.error('Format jam tidak valid. Contoh: 13:30 / 1330 / 13.');
    continue;
  }

  // exact match â†’ auto pilih
  if (allTimes.has(tnorm)) {
    selectedSchedule = baseList.find(s => s.start_time === tnorm);
    log.success(`âœ… â±ï¸ Otomatis memilih jadwal ${tnorm} (exact match).`);
    break;
  }

  // tidak exact â†’ filter yang "mendekati"
  const prefMin = tToMin(tnorm);
  const afterEq = baseList.filter(s => tToMin(s.start_time) >= prefMin);
  if (afterEq.length) {
    currentList = afterEq;
    log.info(`â„¹ï¸  Tidak ada jadwal tepat ${tnorm}. Menampilkan jadwal mulai dari sekitar jam itu (â‰¥ ${tnorm}).`);
    renderSchedulesTable(currentList);
    // lalu user bisa pilih nomor baris dari hasil filter
    continue;
  }

  // kalau tidak ada yang â‰¥, tampilkan yang sebelum jam itu (yang paling dekat ke belakang)
  const before = baseList.filter(s => tToMin(s.start_time) < prefMin);
  if (before.length) {
    currentList = before; // sudah berurutan naik; jadwal paling akhir = paling dekat
    const lastTime = currentList[currentList.length-1]?.start_time;
    log.info(`â„¹ï¸  Tidak ada jadwal â‰¥ ${tnorm}. Menampilkan jadwal sebelum waktu itu (terdekat: ${lastTime}).`);
    renderSchedulesTable(currentList);
    continue;
  }

  // fallback aneh (tidak ada jadwal sama sekali)
  log.warning('Tidak ada jadwal untuk filter tersebut. Menampilkan semua kembali.');
  currentList = baseList.slice();
  renderSchedulesTable(currentList);
}

await appendJsonLog({
  event: 'schedule_selected',
  schedule: selectedSchedule,
  selected_by: allTimes.has(selectedSchedule?.start_time) ? 'time_exact' : (currentList === baseList ? 'number_from_all' : 'number_from_filtered')
});


  // === HELPER: Smart Seat Finding ===
  function findAdjacentSeats(availableSeats, count, preferredRow = null) {
    // Group seats by row
    const seatsByRow = {};
    availableSeats.forEach(seat => {
      const row = seat.label.match(/^[A-Z]+/)?.[0] || '';
      if (!seatsByRow[row]) seatsByRow[row] = [];
      seatsByRow[row].push(seat);
    });

    // Sort seats in each row by number
    Object.keys(seatsByRow).forEach(row => {
      seatsByRow[row].sort((a, b) => {
        const numA = parseInt(a.label.match(/\d+/)?.[0] || '0');
        const numB = parseInt(b.label.match(/\d+/)?.[0] || '0');
        return numA - numB;
      });
    });

    // Try preferred row first
    if (preferredRow && seatsByRow[preferredRow]) {
      const adjacent = findAdjacentInRow(seatsByRow[preferredRow], count);
      if (adjacent.length >= count) return adjacent.slice(0, count);
    }

    // Try all rows, sorted by center position (best viewing)
    const sortedRows = Object.keys(seatsByRow).sort((a, b) => {
      // Prefer rows D, E, F (center rows)
      const centerRows = ['D', 'E', 'F', 'C', 'G', 'B', 'H', 'A', 'I', 'J'];
      return centerRows.indexOf(a) - centerRows.indexOf(b);
    });

    for (const row of sortedRows) {
      const adjacent = findAdjacentInRow(seatsByRow[row], count);
      if (adjacent.length >= count) return adjacent.slice(0, count);
    }

    return []; // No adjacent seats found
  }

  function findAdjacentInRow(rowSeats, count) {
    const adjacent = [];
    for (let i = 0; i < rowSeats.length; i++) {
      const currentNum = parseInt(rowSeats[i].label.match(/\d+/)?.[0] || '0');
      const group = [rowSeats[i]];

      // Check next seats
      for (let j = i + 1; j < rowSeats.length && group.length < count; j++) {
        const nextNum = parseInt(rowSeats[j].label.match(/\d+/)?.[0] || '0');
        if (nextNum === currentNum + (j - i)) {
          group.push(rowSeats[j]);
        } else {
          break;
        }
      }

      if (group.length >= count) {
        return group;
      }
    }
    return [];
  }

  // --- Ambil seat map, tampilkan, pilih kursi ---
  log.process('Loading seats...');
  const seatsRes = await fetchSeats(selectedSchedule.schedule_id, token);
  if (seatsRes?.status_code !== 200) {
    log.error(`Gagal ambil kursi: ${seatsRes?.message || 'Unknown error'}`);
    await appendJsonLog({ event: 'seats_error', message: seatsRes?.message || 'unknown' });
    return;
  }

  log.section('ğŸª‘ SEAT MAP');
  const availableSeats = [];
  (seatsRes?.data?.rows||[]).forEach(r=>{
    (r.seats||[]).forEach(s=>{
      if (s.is_seat) {
        const label = `${s.row_name}${s.number||''}`;
        if (s.is_available) availableSeats.push({ id: s.id, label, price: s.price, grade: s.grade });
      }
    });
  });

  const { avail, total } = renderSeatMap(seatsRes);
  log.info(`Kursi tersedia: ${idNum(avail)} / ${idNum(total)}`);
  await appendJsonLog({ event: 'seats_loaded', counts: { avail, total } });

  if (!availableSeats.length) {
    log.warning('Tidak ada kursi tersedia untuk jadwal ini.');
    await appendJsonLog({ event: 'no_seats_available' });
    return;
  }

  // Pilih kursi dengan input manual
  let seatsPick = [];
  let bookingSuccess = false;
  let od = null;

  while (!bookingSuccess) {
    console.log(chalk.cyan('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
    console.log(chalk.cyan('â”‚') + chalk.white.bold('                    PANDUAN INPUT KURSI                    ') + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.cyan('â”‚') + chalk.yellow(' Format Input:') + '                                           ' + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”‚') + '   â€¢ Single kursi     : H1, H2, H3                      ' + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”‚') + '   â€¢ Multiple kursi   : H1,H2,H3 atau H1.H2.H3          ' + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”‚') + '   â€¢ Range kursi      : H1-H4 (pilih H1,H2,H3,H4)       ' + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”‚') + '   â€¢ Kombinasi        : H1-H3,H6 atau H1.H3.H6          ' + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.cyan('â”‚') + chalk.blue(' Legend Seat Map:') + '                                      ' + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”‚') + `   ${chalk.white('â—')} = Kursi dipilih   ${chalk.green('â–¡')} = Tersedia   ${chalk.red('â– ')} = Terisi       ` + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n'));
    
    const { seatsInput } = await inquirer.prompt([{
      type: 'input',
      name: 'seatsInput',
      message: 'ğŸª‘ Masukkan kursi pilihan (lihat panduan di atas):',
      filter: (s)=>String(s||'').trim()
    }]);

    if (!seatsInput) {
      log.warning('âŒ Input kursi tidak boleh kosong.');
      console.log(chalk.gray('ğŸ’¡ Contoh yang benar: H1,H2 atau H5-H7 atau H1-H3,H6'));
      continue;
    }

    seatsPick = parseSeatsInput(seatsInput, availableSeats);

    if (!seatsPick.length) {
      log.error('âŒ Kursi tidak valid atau sudah terisi.');
      console.log(chalk.yellow('ğŸ’¡ Tips:'));
      console.log(chalk.gray('   - Periksa nomor kursi di seat map di atas'));
      console.log(chalk.gray('   - Pastikan kursi menampilkan simbol â–¡ (tersedia)'));
      console.log(chalk.gray('   - Hindari kursi dengan simbol â–  (sudah terisi)'));
      continue;
    }

    // Check for gaps
    const gaps = needsGapFilling(seatsPick, availableSeats);
    let finalSeats = [...seatsPick];

    if (gaps.length) {
      log.warning(`Terdeteksi kursi kosong di antara pilihan: ${gaps.map(g=>g.label).join(', ')}`);
      const { fillGaps } = await inquirer.prompt([{
        type: 'list',
        name: 'fillGaps',
        message: 'Pilih opsi:',
        choices: [
          { name: 'âœ… Otomatis isi kursi kosong', value: 'auto' },
          { name: 'ğŸ”„ Input ulang kursi', value: 'retry' },
          { name: 'âš¡ Coba booking langsung (mungkin gagal)', value: 'force' }
        ]
      }]);

      if (fillGaps === 'auto') {
        finalSeats = [...seatsPick, ...gaps];
        log.info(`Kursi ditambahkan: ${gaps.map(g=>g.label).join(', ')}`);
      } else if (fillGaps === 'retry') {
        continue;
      }
    }

    // Render seat map dengan pilihan
    log.section('ğŸª‘ KONFIRMASI PILIHAN KURSI');
    const chosenSet = new Set(finalSeats.map(s=>s.id));
    renderSeatMap(seatsRes, chosenSet);

    // Konfirmasi
    const totalPrice = finalSeats.reduce((sum, seat) => sum + (seat.price || 0), 0);
    
    console.log(chalk.green('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
    console.log(chalk.green('â”‚') + chalk.white.bold('                    KONFIRMASI BOOKING                     ') + chalk.green('â”‚'));
    console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.green('â”‚') + ` ğŸ¬ Film      : ${selectedMovie.name.slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ“… Tanggal   : ${`${dateYmd.slice(6,8)}/${dateYmd.slice(4,6)}/${dateYmd.slice(0,4)} ${selectedSchedule.start_time}`.padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸª‘ Kursi     : ${chalk.white(finalSeats.map(s=>s.label).join(', ')).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ¯ Jumlah    : ${String(finalSeats.length).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ’° Total     : ${chalk.white(toRp(totalPrice)).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));

    // Check auto-confirm setting
    const AUTO_CONFIRM_SEAT_BOOKING = String(process.env.AUTO_CONFIRM_SEAT_BOOKING || 'false').toLowerCase() === 'true';

    let confirmSeats = true;
    if (AUTO_CONFIRM_SEAT_BOOKING) {
      log.info('ğŸš€ Auto-confirm: Langsung booking kursi...');
    } else {
      const answer = await inquirer.prompt([{
        type: 'confirm',
        name: 'confirmSeats',
        message: 'ğŸ¯ Konfirmasi booking kursi ini?',
        default: true
      }]);
      confirmSeats = answer.confirmSeats;
    }

    if (!confirmSeats) {
      continue;
    }

    // --- Book seats ---
    log.process('Booking seats...');
    const bookPayload = {
      order_id: '',
      movie_schedule_id: selectedSchedule.schedule_id,
      date: dateYmd,
      movie_id: selectedMovie.id,
      seats: finalSeats.map(s=>({id: s.id}))
    };
    const bookRes = await bookSeats(bookPayload, token);
    
if (bookRes?.status_code !== 200) {
  const msg = bookRes?.message || '';
  const statusCode = bookRes?.status_code || 0;
  log.error(`âŒ Booking gagal: ${msg || 'Unknown error'}`);
  await appendJsonLog({ event: 'book_failed', message: msg || 'unknown', response: bookRes });

  // ğŸ”„ AUTO-RETRY untuk 429 (rate limit) atau kursi sudah terisi
  if (statusCode === 429 || msg.toLowerCase().includes('already') || msg.toLowerCase().includes('taken')) {
    log.warning('âš ï¸  Kursi terisi atau rate limit. Auto-retry kursi yang sama...');

    // PHASE 1: Coba kursi ORIGINAL 1-5x dalam 15 detik
    const originalLabels = finalSeats.map(s => s.label).join(', ');
    const maxOriginalRetries = 5;
    const retryTimeout = 15000; // 15 detik
    const startTime = Date.now();

    for (let attempt = 1; attempt <= maxOriginalRetries; attempt++) {
      // Check timeout
      if (Date.now() - startTime > retryTimeout) {
        log.warning(`â±ï¸  15 detik berlalu. Kursi ${originalLabels} masih terisi. Auto pindah kursi terdekat...`);
        break;
      }

      log.process(`ğŸ”„ Mencoba kursi ${originalLabels} (${attempt}/${maxOriginalRetries})...`);

      // Delay sebelum retry (3 detik untuk attempt pertama, 2 detik untuk selanjutnya)
      await delay(attempt === 1 ? 3000 : 2000);

      const retryOriginalRes = await bookSeats(bookPayload, token);

      if (retryOriginalRes?.status_code === 200) {
        od = retryOriginalRes.data || {};
        seatsPick = finalSeats;
        bookingSuccess = true;
        log.success(`âœ… Berhasil booking kursi original: ${originalLabels}`);
        break;
      } else if (retryOriginalRes?.status_code === 429) {
        log.warning('âš ï¸  Rate limit, tunggu 3 detik...');
        await delay(3000);
      } else {
        const retryMsg = retryOriginalRes?.message || '';
        if (retryMsg.toLowerCase().includes('already') || retryMsg.toLowerCase().includes('taken')) {
          log.warning(`âŒ Kursi ${originalLabels} masih terisi...`);
        } else {
          log.warning(`âŒ Gagal: ${retryMsg}`);
        }
      }
    }

    // PHASE 2: Jika masih gagal, auto pindah ke kursi terdekat
    if (!bookingSuccess) {
      log.info('ğŸ” Mencari kursi terdekat yang kosong...');

      // Fetch fresh seat data
      let freshSeatsRes = null;
      try {
        freshSeatsRes = await fetchSeats(selectedSchedule.schedule_id, token);
      } catch {}

      if (freshSeatsRes?.status_code === 200) {
        // Update available seats
        availableSeats.length = 0;
        (freshSeatsRes?.data?.rows||[]).forEach(r=>{
          (r.seats||[]).forEach(s=>{
            if (s.is_seat && s.is_available) {
              const label = `${s.row_name}${s.number||''}`;
              availableSeats.push({ id: s.id, label, price: s.price, grade: s.grade });
            }
          });
        });

        if (availableSeats.length > 0) {
          // Find adjacent seats matching original count
          const originalCount = finalSeats.length;
          const originalRow = finalSeats[0]?.label.match(/^[A-Z]+/)?.[0];

          const smartSeats = findAdjacentSeats(availableSeats, originalCount, originalRow);

          if (smartSeats.length >= originalCount) {
            log.info(`ğŸ¯ Menemukan ${originalCount} kursi kosong berdekatan: ${smartSeats.map(s=>s.label).join(', ')}`);

            // Auto-retry booking dengan kursi baru (max 3x)
            for (let retryCount = 1; retryCount <= 3; retryCount++) {
              log.process(`ğŸ”„ Booking kursi baru (${retryCount}/3)...`);

              const retryPayload = {
                order_id: '',
                movie_schedule_id: selectedSchedule.schedule_id,
                date: dateYmd,
                movie_id: selectedMovie.id,
                seats: smartSeats.map(s=>({id: s.id}))
              };

              const retryRes = await bookSeats(retryPayload, token);

              if (retryRes?.status_code === 200) {
                od = retryRes.data || {};
                seatsPick = smartSeats;
                bookingSuccess = true;
                log.success(`âœ… Berhasil pindah ke kursi terdekat: ${smartSeats.map(s=>s.label).join(', ')}`);
                break;
              } else if (retryRes?.status_code === 429) {
                log.warning('âš ï¸  Rate limit, tunggu 5 detik...');
                await delay(5000);
              } else {
                log.warning(`âŒ Retry ${retryCount} gagal: ${retryRes?.message || 'Unknown'}`);
                await delay(2000);
              }
            }

            if (bookingSuccess) break; // Exit while loop
          } else {
            log.warning(`âš ï¸  Tidak ditemukan ${originalCount} kursi berdekatan.`);
          }
        } else {
          log.warning('âš ï¸  Tidak ada kursi tersedia.');
        }
      }
    }

    // Jika auto-retry gagal, continue ke prompt manual
    if (!bookingSuccess) {
      log.warning('âš ï¸  Auto-retry gagal. Silakan pilih kursi lain secara manual.');
      continue; // Back to seat input
    }
  }

  // 1) Jika 422 single-seat rule â†’ AUTO-FIX cerdas (parkir warned â†’ rebook intended)
  if (!bookingSuccess && bookRes?.status_code === 422) {
    const warned = parseWarnedSeatMsg(msg);
    if (warned?.label) {
      log.warning(`âš ï¸  Server memperingatkan jangan biarkan kursi kosong: ${warned.label}`);

      // â¤µï¸ ambil seat map TERBARU supaya mapping id kursi akurat
      let seatsResFresh = seatsRes;
      try {
        seatsResFresh = await fetchSeats(selectedSchedule.schedule_id, token);
      } catch {}

      const auto = await smartAutoFixAfter422({
        seatRes: seatsResFresh, // seat map terbaru
        warnedLabel: warned.label,
        intendedLabels: finalSeats.map(s => s.label), // contoh: ["E6","E5"]
        basePayload: {
          order_id: '',
          movie_schedule_id: selectedSchedule.schedule_id,
          date: dateYmd,
          movie_id: selectedMovie.id
        },
        bookSeatsFn: (payload) => bookSeats(payload, token),
        fetchSeatsFn: (scheduleId, tok) => fetchSeats(scheduleId, tok),
        context: {
          schedule_id: selectedSchedule.schedule_id,
          token,
          date: dateYmd,
          movie_id: selectedMovie.id,
          selectedMovie,
          selectedCinema
        },
        enablePolling: true,   // aktif: tunggu sebentar bila ingin rebook intended
        pollEvery: 3000,
        pollMs: 20000
      });

      if (auto.ok) {
        bookingSuccess = true;
        od = auto.res?.data || null;
        const gotLabels = auto.labels || [];
        // tampilkan status sesuai mode
        switch (auto.mode) {
          case 'RESERVE_THEN_REBOOK_INTENDED':
            log.success(`âœ… Parkir ${warned.label} lalu rebook ke niat awal sukses: ${gotLabels.join(', ')}`);
            break;
          case 'POLLING_INTENDED':
            log.success(`âœ… Rebook ke niat awal berhasil (setelah polling): ${gotLabels.join(', ')}`);
            break;
          case 'AUTO_FIX':
            log.success(`âœ… Auto-fix (warned + tetangga) berhasil: ${gotLabels.join(', ')}`);
            break;
          default:
            log.success(`âœ… Auto-fix sukses: ${gotLabels.join(', ')}`);
        }
        break; // selesai; jangan lanjut ke prompt
      } else {
        // Auto-fix gagal â†’ tampilkan alasan
        const reason = auto.reason || 'unknown';
        const cancelledInfo = auto.cancelledParkir || auto.cancelledAutoFix ? ' (order parkir/auto-fix sudah dibatalkan)' : '';

        switch (reason) {
          case 'rebook_failed_after_retries':
            log.error(`âŒ Rebook ke kursi niat awal gagal setelah beberapa retry${cancelledInfo}.`);
            break;
          case 'polling_timeout':
            log.error(`âŒ Polling timeout. Kursi niat awal tidak tersedia${cancelledInfo}.`);
            break;
          case 'fallback_rebook_failed':
            log.error(`âŒ Fallback rebook gagal setelah beberapa retry${cancelledInfo}.`);
            break;
          case 'fallback_timeout':
            log.error(`âŒ Fallback polling timeout${cancelledInfo}.`);
            break;
          case 'no_neighbor_available':
            log.error(`âŒ Tidak ada kursi tetangga yang tersedia untuk auto-fix.`);
            break;
          case 'fallback_booking_failed':
            log.error(`âŒ Auto-fix gagal menemukan kombinasi valid.`);
            break;
          default:
            log.error(`âŒ Auto-fix 422 gagal: ${reason}${cancelledInfo}`);
        }

        log.info('â„¹ï¸  Silakan pilih kursi lain atau coba lagi.');
      }
    }
  }

  // 2) Kalau bukan 422 atau auto-fix gagal â†’ fallback ke alur lama (prompt)
  const { retryAction } = await inquirer.prompt([{
    type: 'list',
    name: 'retryAction',
    message: 'ğŸ¤” Apa yang ingin dilakukan?',
    choices: [
      { name: 'ğŸ”„ Input ulang kursi', value: 'retry' },
      { name: 'âš¡ Auto-retry sampai sukses (smart fill)', value: 'auto' },
      { name: 'âŒ Batalkan', value: 'cancel' }
    ]
  }]);

  if (retryAction === 'cancel') {
    log.info('Booking dibatalkan oleh user.');
    return;
      } else if (retryAction === 'auto') {
        // Auto retry with smart seat finding
        console.log(chalk.cyan('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
        console.log(chalk.cyan('â”‚') + chalk.white.bold('              AUTO RETRY BOOKING (SMART FILL)              ') + chalk.cyan('â”‚'));
        console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
        console.log(chalk.cyan('â”‚') + ' Sistem akan mencari kursi berdekatan secara otomatis      ' + chalk.cyan('â”‚'));
        console.log(chalk.cyan('â”‚') + ' sesuai jumlah kursi yang Anda inginkan...                 ' + chalk.cyan('â”‚'));
        console.log(chalk.cyan('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));

        let attempts = 0;
        const maxAttempts = 10;
        const originalCount = finalSeats.length;
        const originalRow = finalSeats[0]?.label.match(/^[A-Z]+/)?.[0];

        // Refresh seat data first
        try {
          log.process('ğŸ”„ Memuat data kursi terbaru...');
          const freshSeatsRes = await fetchSeats(selectedSchedule.schedule_id, token);
          if (freshSeatsRes?.status_code === 200) {
            availableSeats.length = 0;
            (freshSeatsRes?.data?.rows||[]).forEach(r=>{
              (r.seats||[]).forEach(s=>{
                if (s.is_seat && s.is_available) {
                  const label = `${s.row_name}${s.number||''}`;
                  availableSeats.push({ id: s.id, label, price: s.price, grade: s.grade });
                }
              });
            });
          }
        } catch {}

        while (attempts < maxAttempts && !bookingSuccess) {
          attempts++;
          console.log(chalk.yellow(`âš¡ Percobaan ${attempts}/${maxAttempts} - Mencari ${originalCount} kursi berdekatan...`));

          // Smart find: prioritas baris yang sama, lalu baris lain
          const smartSeats = findAdjacentSeats(availableSeats, originalCount, attempts === 1 ? originalRow : null);

          if (smartSeats.length < originalCount) {
            console.log(chalk.red(`   âŒ Tidak ditemukan ${originalCount} kursi berdekatan. Kursi tersedia: ${availableSeats.length}`));
            break;
          }

          console.log(chalk.gray(`   Mencoba kursi: ${smartSeats.map(s=>s.label).join(', ')}`));

          const autoPayload = {
            order_id: '',
            movie_schedule_id: selectedSchedule.schedule_id,
            date: dateYmd,
            movie_id: selectedMovie.id,
            seats: smartSeats.map(s=>({id: s.id}))
          };

          const autoBookRes = await bookSeats(autoPayload, token);
          if (autoBookRes?.status_code === 200) {
            od = autoBookRes.data || {};
            seatsPick = smartSeats;
            bookingSuccess = true;
            console.log(chalk.green('\nğŸ‰ AUTO-BOOKING BERHASIL!'));
            console.log(chalk.green(`âœ… Kursi final: ${chalk.white(smartSeats.map(s=>s.label).join(', '))}`));
            break;
          } else if (autoBookRes?.status_code === 429) {
            console.log(chalk.yellow(`   âš ï¸  Rate limit. Tunggu 5 detik...`));
            await delay(5000);
          } else {
            console.log(chalk.gray(`   âŒ Gagal: ${autoBookRes?.message || 'Unknown error'}`));
            // Remove tried seats from available pool
            smartSeats.forEach(tried => {
              const idx = availableSeats.findIndex(s => s.id === tried.id);
              if (idx !== -1) availableSeats.splice(idx, 1);
            });
          }

          await delay(2000);
        }
        
        if (!bookingSuccess) {
          console.log(chalk.red('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
          console.log(chalk.red('â”‚') + chalk.white.bold('                    AUTO RETRY GAGAL                       ') + chalk.red('â”‚'));
          console.log(chalk.red('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
          console.log(chalk.red('â”‚') + ` Auto booking gagal setelah ${maxAttempts} percobaan.                ` + chalk.red('â”‚'));
          console.log(chalk.red('â”‚') + ' Kemungkinan semua kursi sudah terisi atau terkena         ' + chalk.red('â”‚'));
          console.log(chalk.red('â”‚') + ' aturan single seat yang ketat.                            ' + chalk.red('â”‚'));
          console.log(chalk.red('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
          console.log(chalk.red('â”‚') + chalk.yellow(' Saran:') + '                                                  ' + chalk.red('â”‚'));
          console.log(chalk.red('â”‚') + ' â€¢ Coba pilih kursi di baris lain (A,B,C,etc)             ' + chalk.red('â”‚'));
          console.log(chalk.red('â”‚') + ' â€¢ Pilih kursi bersebelahan tanpa jarak                    ' + chalk.red('â”‚'));
          console.log(chalk.red('â”‚') + ' â€¢ Atau pilih jadwal/tanggal lain                          ' + chalk.red('â”‚'));
          console.log(chalk.red('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
          return;
        }
      }
      // If retry, continue the loop
    } else {
      od = bookRes.data || {};
      bookingSuccess = true;
      seatsPick = finalSeats;
      log.success('âœ… Booking berhasil!');
    }
  }

  await appendJsonLog({ event: 'book_ok', order: od });

  const orderContext = { selectedAccount, chosenLocation, selectedCinema, selectedMovie, dateYmd, selectedSchedule, seatsPick };


  // Order Summary (Enhanced)
  console.log();
  log.section('ğŸ“‹ ORDER SUMMARY');
  console.log(chalk.cyan('â•­' + 'â”€'.repeat(75) + 'â•®'));
  console.log(chalk.cyan('â”‚') + '  ' + pad(chalk.white.bold('ORDER DETAILS'), 73) + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”œ' + 'â”€'.repeat(75) + 'â”¤'));
  console.log(chalk.cyan('â”‚') + `  Account  : ${chalk.yellow(pad(selectedAccount.email, 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Location : ${chalk.yellow(pad(chosenLocation.location_name, 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Cinema   : ${chalk.yellow(pad(selectedCinema.name, 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Movie    : ${chalk.yellow(pad(selectedMovie.name.slice(0, 57), 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Genre    : ${chalk.yellow(pad(`${selectedMovie.genre} | Rating: ${selectedMovie.rating}`, 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Duration : ${chalk.yellow(pad(selectedMovie.duration, 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Status   : ${pad(selectedMovie.status==='PLAYING'?chalk.green('SEDANG TAYANG'):chalk.cyan('AKAN TAYANG'), 57)}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Date     : ${chalk.yellow(pad(`${dateYmd.slice(6,8)}/${dateYmd.slice(4,6)}/${dateYmd.slice(0,4)}`, 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Time     : ${chalk.yellow(pad(`${selectedSchedule.start_time} - ${selectedSchedule.end_time}`, 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Theater  : ${chalk.yellow(pad(`${selectedSchedule.auditorium_name} (${selectedSchedule.movie_format})`, 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Seats    : ${chalk.yellow(pad(seatsPick.map(s=>s.label).join(', '), 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Order ID : ${chalk.yellow(pad(od.id||'-', 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Booking  : ${chalk.yellow(pad(od.booking_code||'-', 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Total    : ${chalk.yellow(pad(toRp(od.total_amount||0), 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + `  Expires  : ${chalk.yellow(pad(od.expired_date||'-', 57))}` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â•°' + 'â”€'.repeat(75) + 'â•¯'));

  // --- Voucher flow ---
  let applied = null; // ğŸ”§ Declare applied here so it's accessible in auto payment check

  // Check auto-use voucher setting
  const AUTO_USE_VOUCHER = String(process.env.AUTO_USE_VOUCHER || 'false').toLowerCase() === 'true';

  let wantVoucher = true;
  if (AUTO_USE_VOUCHER) {
    log.info('ğŸŸï¸  Auto-voucher: Mencoba gunakan voucher...');
    wantVoucher = true;
  } else {
    const { useVoucher } = await inquirer.prompt([{
      type: 'input',
      name: 'useVoucher',
      message: 'ğŸŸï¸  Gunakan voucher? (Enter=Ya / ketik n untuk Tidak):',
      filter: (s)=>String(s||'').trim()
    }]);
    wantVoucher = useVoucher.toLowerCase() !== 'n';
  }

  if (wantVoucher) {
    log.process('Menyiapkan voucher list...');
    const selectRes = await couponSelect(od.id, token);

    // ğŸ Ambil voucher GIFT dari membership/info
    const memberInfo = await getMemberInfo(token);
    const giftListFromMember = Array.isArray(memberInfo?.RESULTS?.ds_GFT_LIST) ? memberInfo.RESULTS.ds_GFT_LIST : [];

    if (selectRes?.status_code !== 200) {
      log.warning('Gagal memuat daftar voucher.');
      await appendJsonLog({ event: 'coupon_select_failed', response: selectRes });
    } else {
      // ğŸ”¹ Ambil kupon biasa dari API
      const rawCoupons  = Array.isArray(selectRes?.data?.coupons)  ? selectRes.data.coupons  : [];

      // ğŸ”¹ Ambil E-Voucher (gift) dari API kalau ada
      const rawVouchers = Array.isArray(selectRes?.data?.vouchers) ? selectRes.data.vouchers : [];

      // ğŸ” Map E-Voucher â†’ format mirip coupon biar 1 flow
      const mappedVouchers = rawVouchers.map(v => {
        const code = v.number || v.code || '';

        return {
          // info sumber
          kind: 'gift',
          _source: 'voucher',

          // agar tryApply & tabel bisa pakai
          code,
          discount: code,
          number: code,

          // type = kode asli dari API (mis. "01")
          type: v.type || '01',

          // nama & catatan
          name: v.name || '',
          note: v.note || '',

          // kalau mau nanti di-log lagi
          expired_date: v.expired_date,
          value: v.value
        };
      });

      // ğŸ” Map gift dari ds_GFT_LIST (member info) â†’ format yang sama
      const mappedGiftListFromMember = giftListFromMember.map(g => {
        const code = g.GFTCERT_NO || g.DSC_CD || g.discount || g.code || '';

        return {
          kind: 'gift',
          _source: 'gift_memberinfo',

          code,
          discount: code,
          number: code,

          type: g.GFTCERT_TYPE || g.type || '01',

          name: g.GFTCERT_NM || g.DSC_NM || g.name || '',
          note: g.ON_CUST_NOTY_CONT || g.note || '',

          expired_date: g.EXPR_DY || g.expired_date,
          value: g.GFTCERT_AMT || g.value
        };
      });

      // ğŸ”¹ Gabungkan coupon + vouchers + gifts dari member info
      const coupons = [...rawCoupons, ...mappedVouchers, ...mappedGiftListFromMember];

      // ğŸ”§ NORMALISASI TANPA UBAH STRUKTUR FLOW
      for (const c of coupons) {
        // isi discount & number dari code kalau kosong (buat coupon & gift)
        if (!c.discount && c.code) c.discount = c.code;
        if (!c.number   && c.code) c.number   = c.code;

        // kalau ada `kind` (coupon/gift) tapi `type` kosong, pakai kind
        if (!c.type && c.kind) c.type = c.kind;
      }

      await appendJsonLog({
        event: 'coupon_list',
        count: coupons.length,
        coupons
      });

      // ğŸ« Array khusus untuk tampilan tabel: Type = COUPON / GIFT (+ kode tipe kalau ada)
      const couponsForDisplay = coupons.map((c) => {
        const kindRaw  = String(c.kind || '').toLowerCase();
        const srcLabel = kindRaw === 'gift' ? 'GIFT' : 'COUPON'; // asal: gift atau coupon

        const rawType  = c.type ? String(c.type).toUpperCase() : '';
        const typeLabel =
          rawType && rawType !== 'GIFT' && rawType !== 'COUPON'
            ? `${srcLabel} (${rawType})`  // contoh: COUPON (02), GIFT (01)
            : srcLabel;                    // cuma COUPON / GIFT

        return {
          ...c,
          _source_kind: srcLabel,
          type: typeLabel          // ini yang dipakai renderCouponsTable & list pilihan
        };
      });

      async function tryApply(discountCode, couponNumber, couponName, couponType, couponSource){
        if (isB1G1(couponName||'') && seatsPick.length < 2) {
          log.warning(`Voucher "${couponName}" adalah B1G1. Minimal pilih 2 kursi. Kamu pilih ${seatsPick.length}.`);
          await appendJsonLog({ event: 'coupon_b1g1_blocked', seats: seatsPick.length, name: couponName });
          return { ok:false, reason: 'b1g1-need-2-seats' };
        }

        log.process(`Mencoba apply voucher: ${discountCode || couponNumber || '(unknown)'} (${couponName || 'No name'})`);

        // Detect if this is a GIFT voucher
        // Check _source field OR pattern match for E-Voucher codes (A032..., E002...)
        const isGift = couponSource === 'gift_memberinfo' ||
                       couponSource === 'vouchers' ||
                       /^[A-Z]\d{12,}/.test(couponNumber || discountCode || '');

        if (isGift) {
          // GIFT VOUCHER FLOW: select â†’ validate â†’ pay
          const voucherNum = couponNumber || discountCode || '';

          // Step 1: Select voucher
          const sel = await voucherSelect(od.id, voucherNum, token);
          if (sel?.status_code !== 200) {
            log.warning(`Select gagal (${sel?.status_code || '-'}) ${sel?.message || ''}`);
            await appendJsonLog({ event: 'voucher_select_failed', number: voucherNum, response: sel });
            return { ok:false, response: sel };
          }

          // Step 2: Validate voucher
          const v = await voucherValidate(od.id, voucherNum, token);
          if (v?.status_code !== 200) {
            log.warning(`Validate gagal (${v?.status_code || '-'}) ${v?.message || ''}`);
            await appendJsonLog({ event: 'voucher_validate_failed', number: voucherNum, response: v });
            return { ok:false, response: v };
          }
          await appendJsonLog({ event: 'voucher_validated', number: voucherNum, data: v?.data });
          await delay(2000);

          // Step 3: Pay with voucher
          const p = await voucherPay(od.id, voucherNum, token, memberInfo);
          if (p?.status_code !== 200) {
            log.warning(`Pay gagal (${p?.status_code || '-'}) ${p?.message || ''}`);
            await appendJsonLog({ event: 'voucher_pay_failed', number: voucherNum, response: p });
            return { ok:false, response: p };
          }
          await appendJsonLog({ event: 'voucher_pay_ok', data: p?.data });
          return { ok:true, data: p?.data };
        } else {
          // COUPON FLOW: validate â†’ pay
          const v = await couponValidate(od.id, discountCode||'', couponNumber||'', token);
          if (v?.status_code !== 200) {
            log.warning(`Validate gagal (${v?.status_code || '-'}) ${v?.message || ''}`);
            await appendJsonLog({ event: 'coupon_validate_failed', code: discountCode, number: couponNumber, response: v });
            return { ok:false, response: v };
          }
          await appendJsonLog({ event: 'coupon_validated', code: discountCode, number: couponNumber, data: v?.data });
          await delay(2000);
          const p = await couponPay(od.id, discountCode||'', couponNumber||'', token);
          if (p?.status_code !== 200) {
            log.warning(`Pay gagal (${p?.status_code || '-'}) ${p?.message || ''}`);
            await appendJsonLog({ event: 'coupon_pay_failed', code: discountCode, number: couponNumber, response: p });
            return { ok:false, response: p };
          }
          await appendJsonLog({ event: 'coupon_pay_ok', data: p?.data });
          return { ok:true, data: p?.data };
        }
      }

      // ğŸ“‹ TAMPILKAN TABEL VOUCHER DULU
      log.section('ğŸŸï¸ DAFTAR VOUCHER TERSEDIA');
      renderCouponsTable(couponsForDisplay);
      console.log();

      // ğŸ“… CEK HARI INI
      const today = new Date();
      const dayNames = ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'];
      const dayName = dayNames[today.getDay()];
      const isFriday = today.getDay() === 5;
      console.log(chalk.cyan(`ğŸ“… Hari ini: ${dayName} (${today.toLocaleDateString('id-ID')})`));
      if (isFriday) {
        console.log(chalk.yellow('ğŸ‰ Hari Jumat! Prioritas voucher Telkomsel 10K Flat diaktifkan.'));
      }
      console.log();

      // ğŸ Cek apakah ada voucher "2D ALL DAYS Complimentary Member Rewards"
      const allDaysVoucher = coupons.find(c =>
        /2D ALL DAYS.*Complimentary Member Rewards/i.test(c.name || '')
      );

      // ğŸ”¥ PRIORITAS 1 (JUMAT ONLY): AUTO-APPLY TELKOMSEL 10K FLAT PRICE
      if (isFriday && !applied) {
        const telkomselVouchers = coupons.filter(c => {
          if (isFnBVoucher(c)) return false;
          return /TELKOMSEL.*10K.*FLAT.*PRICE/i.test(c.name || '');
        });

        if (telkomselVouchers.length > 0) {
          log.info(`ğŸ“± [JUMAT] Menemukan ${telkomselVouchers.length} voucher TELKOMSEL 10K FLAT PRICE. Auto-apply...`);
          for (const c of telkomselVouchers) {
            const res = await tryApply(c.discount, c.number, c.name, c.type, c._source);
            if (res.ok) {
              applied = { type: 'auto_friday_telkomsel_10k', coupon: c, data: res.data };
              od = res.data;
              log.success(`âœ… [JUMAT] Voucher TELKOMSEL 10K FLAT PRICE berhasil diterapkan!`);
              break;
            }
            await delay(2000);
          }

          if (!applied && telkomselVouchers.length > 0) {
            log.warning(`âš ï¸  [JUMAT] Gagal apply voucher Telkomsel. Lanjut ke prioritas berikutnya...`);
          }
        }
      }

      // Helper: Check if voucher is F&B only
      const isFnBVoucher = (c) => {
        if (/combo|solo|popcorn|snack|drink|f&b|birthday treat|visit free|flazz card/i.test(c.name || '')) {
          return true;
        }
        if (c.type === '02' && c._rawType === '02') {
          return true;
        }
        return false;
      };

      // ğŸ¬ PRIORITAS 2: AUTO-APPLY voucher yang cocok dengan nama film (untuk hari non-Jumat)
      if (!applied && !isFriday) {
        const movieName = od.movie_name || selectedMovie.name;
        const exactByMovie = coupons.filter(c => {
          if (c === allDaysVoucher) return false;
          if (isFnBVoucher(c)) return false;
          return includesIgnoreCase(c.name||'', movieName);
        });

        if (exactByMovie.length > 0) {
          log.info(`ğŸ¬ Menemukan ${exactByMovie.length} voucher yang cocok dengan film "${movieName}". Auto-apply...`);
          for (const c of exactByMovie) {
            const res = await tryApply(c.discount, c.number, c.name, c.type, c._source);
            if (res.ok) {
              applied = { type: 'auto_exact_movie', coupon: c, data: res.data };
              od = res.data;
              log.success(`âœ… Voucher berhasil diterapkan!`);
              break;
            }
            await delay(2000);
          }

          if (!applied) {
            log.warning(`âš ï¸  Semua voucher dengan nama film gagal. Lanjut ke fallback...`);
          }
        }
      }

      // ğŸŸï¸ PRIORITAS 3: AUTO-APPLY B1G1 dari 3rd Visit (jika booking >= 2 kursi, untuk hari non-Jumat)
      let b1g1Vouchers = [];
      if (!applied && !isFriday) {
        b1g1Vouchers = coupons.filter(c => {
          if (c === allDaysVoucher) return false;
          if (isFnBVoucher(c)) return false;
          return isB1G1(c.name || '') && /3rd visit|buy 1 get 1/i.test(c.name || '');
        });

        if (b1g1Vouchers.length > 0 && seatsPick.length >= 2) {
          log.info(`ğŸŸï¸  Menemukan ${b1g1Vouchers.length} B1G1 voucher (3rd Visit, min 2 kursi). Auto-apply...`);
          for (const c of b1g1Vouchers) {
            const res = await tryApply(c.discount, c.number, c.name, c.type, c._source);
            if (res.ok) {
              applied = { type: 'auto_b1g1_3rdvisit', coupon: c, data: res.data };
              od = res.data;
              log.success(`âœ… B1G1 voucher berhasil diterapkan!`);
              break;
            }
            await delay(2000);
          }
        } else if (b1g1Vouchers.length > 0 && seatsPick.length < 2) {
          log.info(`â­ï¸  Skip ${b1g1Vouchers.length} B1G1 voucher (membutuhkan min. 2 kursi, kamu pilih ${seatsPick.length})`);
        }
      }

      // ğŸ”¥ PRIORITAS 4: AUTO-APPLY Voucher 2D ALL DAYS (jika ada, untuk hari non-Jumat)
      if (!applied && !isFriday && allDaysVoucher) {
        log.info(`ğŸ Menemukan voucher "${allDaysVoucher.name}". Auto-apply...`);
        const res = await tryApply(allDaysVoucher.discount, allDaysVoucher.number, allDaysVoucher.name, allDaysVoucher.type, allDaysVoucher._source);
        if (res.ok) {
          applied = { type: 'auto_2d_all_days', coupon: allDaysVoucher, data: res.data };
          od = res.data;
          log.success(`âœ… Voucher berhasil diterapkan!`);
        } else {
          log.warning(`âš ï¸  Gagal apply voucher 2D ALL DAYS. Lanjut ke auto-apply berikutnya...`);
        }
      }

      // ğŸ PRIORITAS 5: GIFT VOUCHER (2D Rewards) - Dengan konfirmasi atau auto-apply
      let giftVouchers = [];
      if (!applied && !isFriday) {
        giftVouchers = coupons.filter(c => {
          if (c === allDaysVoucher) return false;
          if (isFnBVoucher(c)) return false;
          if (isB1G1(c.name || '')) return false;
          // Gift voucher dari source gift_memberinfo dengan pattern 2D rewards
          return (c._source === 'gift_memberinfo' || c._source === 'vouchers') &&
                 /2D.*rewards|complimentary.*2D/i.test(c.name || '');
        });
      }

      // Helper: Deteksi E-Coupon (Coupon Value - tidak butuh PIN)
      const isECoupon = (c) => {
        const name = String(c.name || '').toLowerCase();
        const code = String(c.number || c.code || '').toUpperCase();
        // E-Coupon: "Coupon Value" atau code prefix "MORE"
        return /coupon\s*value/i.test(name) || /^MORE/i.test(code);
      };

      // Helper: Deteksi E-Voucher (Gift - butuh PIN, tapi di autoOrder sudah tersimpan tanpa PIN)
      const isEVoucher = (c) => {
        const name = String(c.name || '').toLowerCase();
        const code = String(c.number || c.code || '').toUpperCase();
        // E-Voucher: "E-Voucher" atau "Voucher Value" atau code prefix "A0"
        return /e[-\s]?voucher/i.test(name) ||
               (/voucher\s*value/i.test(name) && !/coupon\s*value/i.test(name)) ||
               /^A0\d+/i.test(code);
      };

      // ğŸŸï¸ PRIORITAS 6: SPECIAL VOUCHERS (Gift 2D Rewards, E-Coupon, E-Voucher)
      // Dengan konfirmasi atau auto-apply berdasarkan env AUTO_APPLY_SPECIAL_VOUCHERS
      let eCoupons = [];
      let eVouchers = [];
      if (!applied && !isFriday) {
        // Filter E-Coupon
        eCoupons = coupons.filter(c => {
          if (c === allDaysVoucher) return false;
          if (isFnBVoucher(c)) return false;
          if (isB1G1(c.name || '')) return false;
          if (giftVouchers.includes(c)) return false;
          return isECoupon(c);
        });

        // Filter E-Voucher
        eVouchers = coupons.filter(c => {
          if (c === allDaysVoucher) return false;
          if (isFnBVoucher(c)) return false;
          if (isB1G1(c.name || '')) return false;
          if (giftVouchers.includes(c)) return false;
          if (eCoupons.includes(c)) return false;
          return isEVoucher(c) ||
                 c._source === 'gift_memberinfo' ||
                 c._source === 'vouchers';
        });

        const totalSpecialVouchers = giftVouchers.length + eCoupons.length + eVouchers.length;

        // Check env untuk auto-apply
        const autoApplySpecial = (process.env.AUTO_APPLY_SPECIAL_VOUCHERS || 'false').toLowerCase() === 'true';

        // Jika ada special vouchers (Gift 2D Rewards, E-Coupon, atau E-Voucher)
        if (totalSpecialVouchers > 0) {

          // MODE 1: AUTO-APPLY (jika env = true)
          if (autoApplySpecial) {
            // Prioritas: Gift 2D Rewards > E-Coupon > E-Voucher
            const allSpecialVouchers = [...giftVouchers, ...eCoupons, ...eVouchers];

            log.info(`âœ¨ Auto-apply mode: Menemukan ${totalSpecialVouchers} special vouchers (${giftVouchers.length} Gift, ${eCoupons.length} E-Coupon, ${eVouchers.length} E-Voucher)`);

            for (const c of allSpecialVouchers) {
              let vType = 'unknown';
              let vIcon = 'ğŸ';
              if (giftVouchers.includes(c)) {
                vType = 'Gift Voucher (2D Rewards)';
                vIcon = 'ğŸ';
              } else if (eCoupons.includes(c)) {
                vType = 'E-Coupon';
                vIcon = 'ğŸ«';
              } else if (eVouchers.includes(c)) {
                vType = 'E-Voucher';
                vIcon = 'âœ¨';
              }

              log.info(`${vIcon} Mencoba ${vType}: ${c.name || c.number}`);
              const res = await tryApply(c.discount, c.number, c.name, c.type, c._source);
              if (res.ok) {
                applied = { type: `auto_special_${vType.toLowerCase().replace(/[^a-z]/g, '_')}`, coupon: c, data: res.data };
                od = res.data;
                log.success(`âœ… ${vType} berhasil diterapkan!`);
                break;
              }
              await delay(2000);
            }
          }
          // MODE 2: KONFIRMASI (jika env = false atau tidak diset)
          else {
            // Case 1: Hanya ada 1 voucher
            if (totalSpecialVouchers === 1) {
              let theVoucher, voucherType, icon;

              if (giftVouchers.length > 0) {
                theVoucher = giftVouchers[0];
                voucherType = 'Gift Voucher (2D Rewards)';
                icon = 'ğŸ';
              } else if (eCoupons.length > 0) {
                theVoucher = eCoupons[0];
                voucherType = 'E-Coupon';
                icon = 'ğŸ«';
              } else {
                theVoucher = eVouchers[0];
                voucherType = 'E-Voucher';
                icon = 'âœ¨';
              }

              log.info(`${icon} Menemukan 1 ${voucherType}: "${theVoucher.name || theVoucher.number}"`);

              const { useVoucher } = await inquirer.prompt([{
                type: 'input',
                name: 'useVoucher',
                message: `Ingin menggunakan voucher "${theVoucher.name || theVoucher.number}"? (Enter=Tidak / ketik y=Ya):`,
                filter: (s) => String(s || '').trim().toLowerCase(),
                default: ''
              }]);

              if (useVoucher === 'y' || useVoucher === 'yes') {
                const res = await tryApply(theVoucher.discount, theVoucher.number, theVoucher.name, theVoucher.type, theVoucher._source);
                if (res.ok) {
                  applied = { type: `manual_special_${voucherType.toLowerCase().replace(/[^a-z]/g, '_')}`, coupon: theVoucher, data: res.data };
                  od = res.data;
                  log.success(`âœ… ${voucherType} berhasil diterapkan!`);
                } else {
                  log.error(`âŒ Gagal menerapkan ${voucherType}: ${res?.response?.message || res?.reason || 'Unknown error'}`);
                }
              } else {
                log.info(`â„¹ï¸  Melewati ${voucherType}. Lanjut ke voucher lain...`);
              }
            }
            // Case 2: Ada lebih dari 1 voucher
            else {
              log.info(`ğŸ Menemukan ${giftVouchers.length} Gift Voucher, ${eCoupons.length} E-Coupon, dan ${eVouchers.length} E-Voucher`);

              // Build choices
              const voucherChoices = [];

              // Tambahkan Gift Voucher (2D Rewards)
              giftVouchers.forEach(c => {
                voucherChoices.push({
                  name: `ğŸ Gift Voucher: ${c.name || c.number} (${c.discount || '-'})`,
                  value: { voucher: c, type: 'gift', label: 'Gift Voucher (2D Rewards)' }
                });
              });

              // Tambahkan E-Coupon
              eCoupons.forEach(c => {
                voucherChoices.push({
                  name: `ğŸ« E-Coupon: ${c.name || c.number} (${c.discount || '-'})`,
                  value: { voucher: c, type: 'ecoupon', label: 'E-Coupon' }
                });
              });

              // Tambahkan E-Voucher
              eVouchers.forEach(c => {
                voucherChoices.push({
                  name: `âœ¨ E-Voucher: ${c.name || c.number} (${c.discount || '-'})`,
                  value: { voucher: c, type: 'evoucher', label: 'E-Voucher' }
                });
              });

              // Tambahkan opsi skip
              voucherChoices.push({
                name: 'â­ï¸  Lewati semua, lanjut ke voucher lain',
                value: null
              });

              const { selectedVoucher } = await inquirer.prompt([{
                type: 'list',
                name: 'selectedVoucher',
                message: 'Pilih voucher yang ingin digunakan:',
                choices: voucherChoices,
                pageSize: 12
              }]);

              if (selectedVoucher) {
                const v = selectedVoucher.voucher;
                const vType = selectedVoucher.type;
                const vLabel = selectedVoucher.label;
                const res = await tryApply(v.discount, v.number, v.name, v.type, v._source);

                if (res.ok) {
                  applied = { type: `manual_special_${vType}`, coupon: v, data: res.data };
                  od = res.data;
                  log.success(`âœ… ${vLabel} berhasil diterapkan!`);
                } else {
                  log.error(`âŒ Gagal menerapkan voucher: ${res?.response?.message || res?.reason || 'Unknown error'}`);
                }
              } else {
                log.info(`â„¹ï¸  Melewati semua special vouchers. Lanjut ke voucher lain...`);
              }
            }
          }
        }
      }

      // â„¹ï¸ INFO: TELKOMSEL 10K FLAT PRICE (hanya untuk Jumat, tampilkan info jika ada)
      if (!isFriday) {
        const telkomselVouchers = coupons.filter(c => {
          if (isFnBVoucher(c)) return false;
          return /TELKOMSEL.*10K.*FLAT.*PRICE/i.test(c.name || '');
        });

        if (telkomselVouchers.length > 0) {
          log.info(`â„¹ï¸  Tersedia ${telkomselVouchers.length} voucher TELKOMSEL 10K FLAT PRICE (khusus hari Jumat)`);
        }
      }

      // ğŸ” PRIORITAS 7: FALLBACK - Voucher lain (dengan konfirmasi)
      if (!applied) {
        const otherVouchers = coupons.filter(c => {
          if (c === allDaysVoucher) return false;
          if (isFnBVoucher(c)) return false;
          if (eCoupons && eCoupons.includes(c)) return false;
          if (eVouchers && eVouchers.includes(c)) return false;
          if (giftVouchers && giftVouchers.includes(c)) return false;
          if (b1g1Vouchers && b1g1Vouchers.includes(c)) return false;
          return true;
        });

        // Jika masih belum applied dan ada voucher lain, baru tanya konfirmasi
        if (!applied && otherVouchers.length > 0) {
          // Check AUTO_SKIP_VOUCHER_FALLBACK dari .env
          const autoSkipVoucherFallback = (process.env.AUTO_SKIP_VOUCHER_FALLBACK || 'false').toLowerCase() === 'true';

          let autoTry = '';
          if (autoSkipVoucherFallback) {
            autoTry = ''; // Skip, tidak coba voucher lain
            log.info(`â„¹ï¸  Auto-skip voucher fallback (tidak ada voucher yang cocok). Lanjut ke pembayaran.`);
          } else {
            const response = await inquirer.prompt([{
              type: 'input',
              name: 'autoTry',
              message: `ğŸ”„ Tidak ada voucher yang cocok. Coba test ${otherVouchers.length} voucher lainnya? (Enter=Tidak / ketik y atau 1=Ya):`,
              default: ''
            }]);
            autoTry = response.autoTry;
          }

          if (autoTry === 'y' || autoTry === '1') {
            log.info(`Mencoba auto-apply ${otherVouchers.length} voucher yang tersedia...`);
            for (const c of otherVouchers) {
              const res = await tryApply(c.discount, c.number, c.name, c.type, c._source);
              if (res.ok) {
                applied = { type: 'auto_fallback', coupon: c, data: res.data };
                od = res.data;
                log.success(`âœ… Voucher berhasil diterapkan!`);
                break;
              }
              await delay(5000);
            }

            if (!applied) {
              log.warning(`âš ï¸  Semua voucher gagal di-apply secara otomatis. Lanjut ke pilihan manual...`);
            }
          } else {
            log.info(`â„¹ï¸  Auto-fallback dibatalkan. Lanjut ke pilihan manual...`);
          }
        }

        if (!applied &&
            (!eCoupons || eCoupons.length === 0) &&
            (!eVouchers || eVouchers.length === 0) &&
            (!giftVouchers || giftVouchers.length === 0) &&
            (!b1g1Vouchers || b1g1Vouchers.length === 0) &&
            otherVouchers.length === 0) {
          log.info(`â„¹ï¸  Tidak ada voucher lain yang cocok untuk film ini.`);
        }
      }

      // ğŸ“ PRIORITAS 8: MANUAL SELECTION (jika belum ada voucher yang diterapkan)
      if (!applied) {

        // ğŸ” Loop supaya user bisa coba beberapa voucher/manual code
        while (!applied) {
          // Check AUTO_SKIP_VOUCHER_MANUAL dari .env
          const autoSkipVoucherManual = (process.env.AUTO_SKIP_VOUCHER_MANUAL || 'false').toLowerCase() === 'true';

          let pickVoucherAction = '';
          if (autoSkipVoucherManual) {
            pickVoucherAction = ''; // Skip manual selection
            log.info('â„¹ï¸  â­ï¸  Auto-skip voucher manual selection. Lanjut ke pembayaran tanpa voucher.');
          } else {
            const response = await inquirer.prompt([{
              type: 'input',
              name: 'pickVoucherAction',
              message: 'Pilih opsi voucher: (Enter=Lewati / ketik y=Pilih dari daftar)',
              filter: (s)=>String(s||'').trim().toLowerCase(),
              default: ''
            }]);
            pickVoucherAction = response.pickVoucherAction;
          }

          // Enter (kosong) = skip
          if (!pickVoucherAction || pickVoucherAction === '' || pickVoucherAction === 'n') {
            log.info('â„¹ï¸  Lewati voucher. Lanjut ke pembayaran.');
            break; // Exit loop tanpa apply voucher
          }

          // y atau yes = pick from list
          if (pickVoucherAction === 'y' || pickVoucherAction === 'yes' || pickVoucherAction === 'pick') {
            const { chosenVoucher } = await inquirer.prompt([{
              type: 'list',
              name: 'chosenVoucher',
              message: 'Pilih voucher:',
              pageSize: 12,
              // ğŸ‘‰ pakai couponsForDisplay biar labelnya sama dengan tabel
              choices: couponsForDisplay.map((c,i)=>({
                name: `${String(i+1).padStart(2,'0')}) ${c.discount || c.number || c.code || '-'} | ${c.type || '-'} | ${c.name || '-'}`,
                value: c
              }))
            }]);

            const res = await tryApply(chosenVoucher.discount, chosenVoucher.number, chosenVoucher.name, chosenVoucher.type, chosenVoucher._source);
            if (res.ok) {
              applied = { type: 'manual_pick', coupon: chosenVoucher, data: res.data };
              od = res.data;
              log.success(`Voucher diterapkan: ${chosenVoucher.discount || chosenVoucher.number || '(unknown)'}`);
              break; // âœ… Berhasil â†’ keluar loop
            } else {
              log.error(`Voucher gagal diterapkan: ${res?.response?.message || res?.reason || 'Unknown error'}`);
              continue;
            }
          } else {
            // Unknown input, treat as skip
            log.info('â„¹ï¸  Input tidak valid. Lewati voucher.');
            break;
          }
        }
      } else {
        log.success(`âœ… Voucher diterapkan: ${applied.coupon?.name || '(unknown)'}`);
      }



      // Summary setelah voucher
      if (applied && od) {
        log.section('ğŸ“‹ ORDER SUMMARY (setelah voucher)');
        console.log(chalk.cyan('â•­' + 'â”€'.repeat(75) + 'â•®'));
        console.log(chalk.cyan('â”‚') + '  ' + pad(chalk.white.bold('ORDER DETAILS (UPDATED)'), 73) + chalk.cyan('â”‚'));
        console.log(chalk.cyan('â”œ' + 'â”€'.repeat(75) + 'â”¤'));
        console.log(chalk.cyan('â”‚') + `  Order ID : ${chalk.yellow(pad(od.id||'-', 57))}` + chalk.cyan('â”‚'));
        console.log(chalk.cyan('â”‚') + `  Booking  : ${chalk.yellow(pad(od.booking_code||'-', 57))}` + chalk.cyan('â”‚'));

        // Show voucher info from applied object
        const voucherName = applied.coupon?.name || od.discount_name || '-';
        const voucherCode = applied.coupon?.discount || applied.coupon?.number || od.discount_code || '-';
        console.log(chalk.cyan('â”‚') + `  Voucher  : ${chalk.green(pad(voucherName, 57))}` + chalk.cyan('â”‚'));

        // Calculate discount amount
        const subtotal = od.sub_total_amount || 0;
        const total = od.total_amount || 0;
        const discountAmount = subtotal - total;

        console.log(chalk.cyan('â”‚') + `  Subtotal : ${chalk.white(pad(toRp(subtotal), 57))}` + chalk.cyan('â”‚'));
        console.log(chalk.cyan('â”‚') + `  Diskon   : ${chalk.green(pad(`-${toRp(discountAmount)}`, 57))}` + chalk.cyan('â”‚'));
        console.log(chalk.cyan('â”‚') + `  Total    : ${chalk.yellow.bold(pad(toRp(total), 57))}` + chalk.cyan('â”‚'));
        console.log(chalk.cyan('â•°' + 'â”€'.repeat(75) + 'â•¯'));
      }
    }
  } else {
    log.info('Lewati voucher (permintaan pengguna).');
  }

  // --- Next action (payment / cancel / save) ---

  // Helper: Build payment summary lines with voucher info
  function buildPaymentSummaryLines(pdata, methodLabel) {
    const lines = [];
    lines.push(`Film       : ${selectedMovie.name}`);
    lines.push(`Tanggal    : ${dateYmd.slice(6,8)}/${dateYmd.slice(4,6)}/${dateYmd.slice(0,4)} pukul ${selectedSchedule.start_time}`);
    lines.push(`Kursi      : ${seatsPick.map(s=>s.label).join(', ')}`);
    lines.push(`Studio     : ${selectedSchedule.auditorium_name} (${selectedSchedule.movie_format})`);
    lines.push(`Metode     : ${methodLabel}`);
    lines.push(`Order ID   : ${pdata.id || '-'}`);
    lines.push(`Booking    : ${pdata.booking_code || '-'}`);

    // Show subtotal
    lines.push(`Subtotal   : ${toRp(pdata.sub_total_amount||0)}`);

    // Show voucher info if applied
    if (applied && applied.coupon) {
      const voucherName = applied.coupon.name || applied.coupon.discount || applied.coupon.number || '-';
      const discountAmt = (pdata.sub_total_amount || 0) - (pdata.total_amount || 0) - (pdata.convenience_fee || 0);
      if (discountAmt > 0) {
        lines.push(`Voucher    : ${voucherName}`);
        lines.push(`Diskon     : -${toRp(discountAmt)}`);
      }
    }

    // Show admin fee
    if (pdata.convenience_fee) lines.push(`Admin Fee  : ${toRp(pdata.convenience_fee||0)}`);

    // Show total
    lines.push(`Total      : ${toRp(pdata.total_amount||0)}`);
    lines.push(`Batas Waktu: ${pdata.expired_date || '-'}`);

    return lines;
  }

  // Helper: Get voucher info for telegram
  function getVoucherInfo(pdata) {
    if (!applied || !applied.coupon) return { voucherName: null, voucherCode: null, discountAmount: 0 };

    const voucherName = applied.coupon.name || applied.coupon.discount || applied.coupon.number || null;
    const voucherCode = applied.coupon.discount || applied.coupon.number || null;
    const discountAmount = (pdata.sub_total_amount || 0) - (pdata.total_amount || 0) - (pdata.convenience_fee || 0);

    return { voucherName, voucherCode, discountAmount };
  }

  // Ringkas helper ringkasan VA
  function renderVASummary(pdata) {
    const lines = [];
    lines.push(`Film       : ${selectedMovie.name}`);
    lines.push(`Tanggal    : ${dateYmd.slice(6,8)}/${dateYmd.slice(4,6)}/${dateYmd.slice(0,4)} ${selectedSchedule.start_time}`);
    lines.push(`Kursi      : ${seatsPick.map(s=>s.label).join(', ')}`);
    lines.push(`Metode     : ${pdata.virtual_account_bank_name || 'Bank Transfer'}`);
    lines.push(`Order ID   : ${pdata.id || '-'}`);
    lines.push(`Booking    : ${pdata.booking_code || '-'}`);
    if (pdata.virtual_account_bank_number || pdata.payment_code) {
      lines.push(`VA Number  : ${pdata.virtual_account_bank_number || pdata.payment_code}`);
    }
    lines.push(`Subtotal   : ${toRp(pdata.sub_total_amount||0)}`);

    // Show voucher info if applied
    if (applied && applied.coupon) {
      const voucherName = applied.coupon.name || applied.coupon.discount || applied.coupon.number || '-';
      const discountAmt = (pdata.sub_total_amount || 0) - (pdata.total_amount || 0) - (pdata.convenience_fee || 0);
      if (discountAmt > 0) {
        lines.push(`Voucher    : ${voucherName}`);
        lines.push(`Diskon     : -${toRp(discountAmt)}`);
      }
    }

    lines.push(`Convenience fee : ${toRp(pdata.convenience_fee||0)}`);
    if (pdata.insurance_fee) lines.push(`Insurance  : ${toRp(pdata.insurance_fee||0)}`);
    lines.push(`Total      : ${toRp(pdata.total_amount||0)}`);
    lines.push(`Expires    : ${pdata.expired_date || '-'}`);
    console.log(multilineBox(lines));
  }

  // â¬‡ï¸ STATE MONITOR (dipakai di zero-total & semua jalur pembayaran)
  let monitorResult = null;
  let telegramPaymentMessageId = null;

  // âœ… [NEW] Cek dulu: kalau total order Rp 0, auto handle & SKIP flow pembayaran
  const zeroHandled = await autoHandleZeroTotalOrderIfAny({
    order: od,
    token,
    context: {
      orderContext,
      selectedAccount,
      selectedMovie,
      dateYmd,
      selectedSchedule,
      seatsPick
    }
  });

  if (zeroHandled && zeroHandled.monitorResult) {
    monitorResult = zeroHandled.monitorResult;
    telegramPaymentMessageId = zeroHandled.telegramPaymentMessageId || null;
  }

  // âš ï¸ Hanya kalau belum ke-handle (bukan / belum dianggap Rp 0) â†’ lanjut tanya nextAction
  if (!monitorResult) {
    // ğŸš€ AUTO PAYMENT: Cek apakah voucher berhasil diterapkan dan AUTO_PAYMENT_AFTER_VOUCHER enabled
    const AUTO_PAYMENT_AFTER_VOUCHER = String(process.env.AUTO_PAYMENT_AFTER_VOUCHER || 'false').toLowerCase() === 'true';
    const AUTO_PAYMENT_WITHOUT_VOUCHER = String(process.env.AUTO_PAYMENT_WITHOUT_VOUCHER || 'false').toLowerCase() === 'true';
    let nextAction = '';

    if (applied && AUTO_PAYMENT_AFTER_VOUCHER) {
      // Jika voucher berhasil diterapkan dan auto payment enabled, langsung ke pembayaran
      log.info('ğŸ’³ Voucher berhasil diterapkan. Auto payment enabled. Lanjut ke pembayaran...');
      nextAction = 'pay';
    } else if (!applied && AUTO_PAYMENT_WITHOUT_VOUCHER) {
      // Jika tidak ada voucher dan auto payment without voucher enabled, langsung ke pembayaran
      log.info('ğŸ’³ Tidak ada voucher. Auto payment enabled. Lanjut ke pembayaran...');
      nextAction = 'pay';
    } else {
      // Jika auto payment disabled, tanya konfirmasi
      const answer = await inquirer.prompt([{
        type: 'list',
        name: 'nextAction',
        message: 'Langkah berikutnya?',
        choices: [
          { name: 'ğŸ’³ Lanjut ke pembayaran', value: 'pay' },
          { name: 'ğŸ›‘ Batalkan pesanan (cancel order)', value: 'cancel' },
          { name: 'ğŸ’¾ Simpan saja (bayar nanti)', value: 'save' }
        ]
      }]);
      nextAction = answer.nextAction;
    }

    if (nextAction === 'pay') {
      log.process('Memuat metode pembayaran...');
      const payRes = await fetchPaymentMethods(token);
      if (payRes?.status_code !== 200) {
        log.error('Gagal ambil metode pembayaran.');
        await appendJsonLog({ event: 'payments_failed', response: payRes });
      } else {

        // === MINI HELPER: cari GOPAY & QRIS di daftar metode ===
        const findGopay = (resp) => {
          const data = resp?.data || [];
          for (const cat of data) {
            const catId = String(cat?.category_id ?? cat?.id ?? cat?.categoryId ?? cat?.categoryID ?? '');
            if (catId !== '2') continue; // E-WALLET
            for (const it of (cat.items || [])) {
              if (!it?.status) continue; // hanya yg aktif
              const name = String(it.name || '');
              const id   = String(it.id   || '');
              const up   = name.toUpperCase();
              if (up.includes('GOPAY') || id === '1') {
                return {
                  ...it,
                  payment_id: String(it.payment_id || it.id),
                  category_id: catId,
                  category_name: cat.name
                };
              }
            }
          }
          return null;
        };

        const findQris = (resp) => {
          const data = resp?.data || [];
          for (const cat of data) {
            const catId = String(cat?.category_id ?? cat?.id ?? cat?.categoryId ?? cat?.categoryID ?? '');
            if (catId !== '2') continue; // E-WALLET
            for (const it of (cat.items || [])) {
              if (!it?.status) continue; // hanya yg aktif
              const name = String(it.name || '');
              const id   = String(it.id   || '');
              const up   = name.toUpperCase();
              if (up.includes('QRIS') || id === '2') {
                return {
                  ...it,
                  payment_id: String(it.payment_id || it.id),
                  category_id: catId,
                  category_name: cat.name
                };
              }
            }
          }
          return null;
        };

        const findShopeePay = (resp) => {
          const data = resp?.data || [];
          for (const cat of data) {
            const catId = String(cat?.category_id ?? cat?.id ?? cat?.categoryId ?? cat?.categoryID ?? '');
            if (catId !== '2') continue; // E-WALLET
            for (const it of (cat.items || [])) {
              if (!it?.status) continue; // hanya yg aktif
              const name = String(it.name || '');
              const id   = String(it.id   || '');
              const up   = name.toUpperCase();
              if (up.includes('SHOPEE') || up.includes('SHOPEEPAY') || id === '13') {
                return {
                  ...it,
                  payment_id: String(it.payment_id || it.id),
                  category_id: catId,
                  category_name: cat.name
                };
              }
            }
          }
          return null;
        };

        // Baca konfigurasi default payment dari .env
        const defaultPaymentMethod = (process.env.DEFAULT_PAYMENT || 'DANA').toUpperCase();
        const AUTO_PAYMENT_AFTER_VOUCHER = String(process.env.AUTO_PAYMENT_AFTER_VOUCHER || 'false').toLowerCase() === 'true';
        const AUTO_PAYMENT_WITHOUT_VOUCHER = String(process.env.AUTO_PAYMENT_WITHOUT_VOUCHER || 'false').toLowerCase() === 'true';

        let selectedMethod = '';
        let cgvPointFailed = false;
        let cgvPointSuccess = false;

        // ğŸš€ AUTO PAYMENT: Jika voucher berhasil dan auto payment enabled, langsung pakai DEFAULT_PAYMENT
        if (applied && AUTO_PAYMENT_AFTER_VOUCHER) {
          // Langsung set selectedMethod berdasarkan DEFAULT_PAYMENT tanpa prompt
          if (defaultPaymentMethod === 'POINT' || defaultPaymentMethod === 'CGV_POINT' || defaultPaymentMethod === 'CGVPOINT') {
            selectedMethod = 'p';
            log.info('ğŸš€ Auto payment: menggunakan CGV Point...');
          } else if (defaultPaymentMethod === 'GOPAY') {
            selectedMethod = 'g';
            log.info('ğŸš€ Auto payment: menggunakan GOPAY...');
          } else if (defaultPaymentMethod === 'SHOPEEPAY') {
            selectedMethod = 's';
            log.info('ğŸš€ Auto payment: menggunakan SHOPEEPAY...');
          } else {
            selectedMethod = 'd';
            log.info('ğŸš€ Auto payment: menggunakan DANA...');
          }
        } else if (!applied && AUTO_PAYMENT_WITHOUT_VOUCHER) {
          // ğŸš€ AUTO PAYMENT TANPA VOUCHER: Langsung pakai DEFAULT_PAYMENT
          if (defaultPaymentMethod === 'POINT' || defaultPaymentMethod === 'CGV_POINT' || defaultPaymentMethod === 'CGVPOINT') {
            selectedMethod = 'p';
            log.info('ğŸš€ Auto payment (tanpa voucher): menggunakan CGV Point...');
          } else if (defaultPaymentMethod === 'GOPAY') {
            selectedMethod = 'g';
            log.info('ğŸš€ Auto payment (tanpa voucher): menggunakan GOPAY...');
          } else if (defaultPaymentMethod === 'SHOPEEPAY') {
            selectedMethod = 's';
            log.info('ğŸš€ Auto payment (tanpa voucher): menggunakan SHOPEEPAY...');
          } else {
            selectedMethod = 'd';
            log.info('ğŸš€ Auto payment (tanpa voucher): menggunakan DANA...');
          }
        } else {
          // Prompt user untuk pilih payment method
          // Dynamic prompt message based on env config
          let promptMessage;
          if (defaultPaymentMethod === 'POINT' || defaultPaymentMethod === 'CGV_POINT' || defaultPaymentMethod === 'CGVPOINT') {
            promptMessage = 'Auto CGV POINT? (Enter=CGV Point / ketik d untuk DANA / ketik g untuk GOPAY / ketik s untuk SHOPEEPAY / ketik q untuk QRIS / ketik y untuk pilih metode lain):';
          } else if (defaultPaymentMethod === 'GOPAY') {
            promptMessage = 'Auto GOPAY (E-WALLET)? (Enter=GOPAY / ketik d untuk DANA / ketik s untuk SHOPEEPAY / ketik q untuk QRIS / ketik y untuk pilih metode lain / ketik p untuk CGV Point):';
          } else if (defaultPaymentMethod === 'SHOPEEPAY') {
            promptMessage = 'Auto SHOPEEPAY (E-WALLET)? (Enter=SHOPEEPAY / ketik d untuk DANA / ketik g untuk GOPAY / ketik q untuk QRIS / ketik y untuk pilih metode lain / ketik p untuk CGV Point):';
          } else {
            promptMessage = 'Auto DANA (E-WALLET) dengan nomor tersimpan? (Enter=DANA / ketik g untuk GOPAY / ketik s untuk SHOPEEPAY / ketik q untuk QRIS / ketik y untuk pilih metode lain / ketik p untuk CGV Point):';
          }

          const { useDefaultDana } = await inquirer.prompt([{
            type: 'input',
            name: 'useDefaultDana',
            filter: (s)=>String(s||'').trim().toLowerCase(),
            message: promptMessage
          }]);

          // Determine payment method based on env config and user input
          if (useDefaultDana === 'y' || useDefaultDana === 'p' || useDefaultDana === 'g' || useDefaultDana === 'd' || useDefaultDana === 'q' || useDefaultDana === 's') {
            selectedMethod = useDefaultDana;
          } else {
            // Enter pressed - use default from env
            if (defaultPaymentMethod === 'POINT' || defaultPaymentMethod === 'CGV_POINT' || defaultPaymentMethod === 'CGVPOINT') {
              selectedMethod = 'p';
            } else if (defaultPaymentMethod === 'GOPAY') {
              selectedMethod = 'g';
            } else if (defaultPaymentMethod === 'SHOPEEPAY') {
              selectedMethod = 's';
            } else {
              selectedMethod = 'd';
            }
          }
        }

        const defaultDana = (selectedMethod === 'd');

        // === Jalur cepat CGV POINT (shortcut "p") ===
        if (selectedMethod === 'p') {
          log.section('ğŸ’  PEMBAYARAN â€” CGV POINT (shortcut p)');

          // --- Ensure helper tersedia (hindari ReferenceError) ---
          // Pakai global kalau sudah diexpose; jika tidak, pakai shim lokal di bawah.
          const cgvPointSelectFn = globalThis.cgvPointSelect || (async function cgvPointSelectLocal(orderId, token) {
            const url = `${baseURL}/api/orders/cgv-point/select`;
            const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
            const body = [
              `--${boundary}`,
              `Content-Disposition: form-data; name="order_id"`,
              ``,
              String(orderId),
              `--${boundary}--`
            ].join('\r\n');
            const { json } = await requestJson('POST', url, {
              headers: {
                Authorization: `Bearer ${token}`,
                'content-type': `multipart/form-data; boundary=${boundary}`
              },
              body,
              note: 'cgv-point-select'
            });
            return json || { status_code: 500, data: null };
          });

          const cgvPointPayFn = globalThis.cgvPointPay || (async function cgvPointPayLocal(orderId, fields, token) {
            const url = `${baseURL}/api/orders/cgv-point/pay`;
            const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
            const payload = {
              order_id: String(orderId),
              pin: String(fields.pin || ''),
              member_grade_id: String(fields.member_grade_id || '03'),
              member_tier_id:  String(fields.member_tier_id  || '03'),
              customer_name:    String(fields.customer_name   || ''),
              customer_phone:   String(fields.customer_phone  || ''),
              customer_email:   String(fields.customer_email  || ''),
              customer_address: String(fields.customer_address|| ''),
              customer_city:    String(fields.customer_city   || ''),
              customer_post_code: String(fields.customer_post_code || '')
            };
            const parts = [];
            Object.entries(payload).forEach(([k,v])=>{
              parts.push(`--${boundary}`, `Content-Disposition: form-data; name="${k}"`, '', v);
            });
            parts.push(`--${boundary}--`);
            const body = parts.join('\r\n');
            const { json } = await requestJson('POST', url, {
              headers: { Authorization: `Bearer ${token}`, 'content-type': `multipart/form-data; boundary=${boundary}` },
              body,
              note: 'cgv-point-pay'
            });
            return json || { status_code: 500, data: null };
          });

          // (opsional) Ambil profil & saldo point via getMemberInfo jika tersedia
          let pointBalance = null, memberCtx = null;
          try {
            if (typeof getMemberInfo === 'function') {
              const info = await getMemberInfo(token);
              const m = info?.RESULTS?.ds_mbrList || null;
              if (m) {
                pointBalance = Number(m.ACCU_POINT ?? m.MILEAGE_AMT ?? 0);
                memberCtx = {
                  name: m.MBR_NM || null,
                  gradeId: m.MBR_GRD_CD || null,
                  tierId:  m.MBR_TIER_CD || null,
                  phone: (m.MOBILE_NO || '').replace(/[^0-9]/g,''),
                  email: m.EMAIL_ID || null,
                  city:  m.ADDR_REGION_NM || null
                };
              }
            }
          } catch {}

          if (pointBalance != null) {
            console.log(multilineBox([
              `Saldo Point : ${pointBalance}`,
              `Sumber      : getMemberInfo()`
            ]));
          }

          // Select CGV Point
          const selPt = await cgvPointSelectFn(od.id, token);
          if (selPt?.status_code !== 200) {
            log.error(`Select CGV Point gagal: ${selPt?.message || 'Unknown error'}`);
            console.log(chalk.gray(JSON.stringify(selPt, null, 2)));
            await appendJsonLog({ event: 'payment_point_select_failed', order_id: od.id, response: selPt });
          } else {
            await appendJsonLog({ event: 'payment_point_select_ok', order_id: od.id, data: selPt?.data });
            const pdataSel = selPt.data || od;

            // Ringkasan order (sebelum PIN)
            log.section('ğŸ§¾ PAYMENT SUMMARY');
            const preLines = buildPaymentSummaryLines(pdataSel, 'CGV Point');
            console.log(multilineBox(preLines));

            // Payload customer (best-effort; aman kalau kosong)
            const cname = memberCtx?.name || (orderContext?.account?.name) || (orderContext?.account?.email?.split('@')[0]) || 'CGV Member';
            const cphone = (memberCtx?.phone || orderContext?.account?.phone || '').replace(/[^0-9]/g, '');
            const caddr  = orderContext?.account?.address || '-';
            const ccity  = memberCtx?.city || orderContext?.account?.city || '-';
            const czip   = orderContext?.account?.post_code || '00000';
            const cemail = orderContext?.account?.email || memberCtx?.email || '';

            const gradeId = memberCtx?.gradeId || orderContext?.account?.member_grade_id || '03';
            const tierId  = memberCtx?.tierId  || orderContext?.account?.member_tier_id  || '03';

            // PIN Strategy: 1x auto ENV, then 2x manual input, then fallback
            const defaultPin = process.env.SET_PIN || '121212';
            let pinRetryCount = 0;
            const maxPinRetry = 3; // Total 3 attempts: 1 auto + 2 manual
            let payPt = null;
            let cgvPointFailed = false;
            let currentPin = defaultPin;

            while (pinRetryCount < maxPinRetry) {
              // Attempt 1: Auto dari ENV (silent)
              if (pinRetryCount === 0) {
                log.info(`ğŸ” Menggunakan PIN otomatis dari ENV: ${currentPin}`);
              }
              // Attempt 2 & 3: Prompt user manual
              else {
                const { manualPin } = await inquirer.prompt([{
                  type: 'password',
                  name: 'manualPin',
                  message: `Masukkan PIN CGV Point yang benar (attempt ${pinRetryCount + 1}/${maxPinRetry}):`,
                  mask: '*',
                  filter: s => String(s || '').trim()
                }]);
                currentPin = manualPin || currentPin;
                log.info(`ğŸ” Menggunakan PIN manual: ${currentPin}`);
              }

              payPt = await cgvPointPayFn(od.id, {
                pin: currentPin,
                member_grade_id: gradeId,
                member_tier_id:  tierId,
                customer_name: cname,
                customer_phone: cphone,
                customer_email: cemail,
                customer_address: caddr,
                customer_city: ccity,
                customer_post_code: czip
              }, token);

              const sc = payPt?.status_code;
              const msg = String(payPt?.message || '').trim();

              // Success
              if (sc === 200) {
                break;
              }

              // Invalid PIN
              if (sc === 422 && /invalid\s*pin/i.test(msg)) {
                pinRetryCount++;
                console.log(chalk.red(`\nâŒ PIN CGV Point salah (attempt ${pinRetryCount}/${maxPinRetry})`));
                console.log(multilineBox([
                  `Status Code   : ${sc}`,
                  `Message       : ${msg}`,
                  `PIN Digunakan : ${currentPin}`
                ]));

                if (pinRetryCount >= maxPinRetry) {
                  log.warning(`âš ï¸  PIN salah setelah ${maxPinRetry}x percobaan.`);
                  log.info('ğŸ”„ Fallback ke metode pembayaran cadangan.');

                  cgvPointFailed = true;
                  const fallbackPayment = (process.env.FALLBACK_PAYMENT || 'GOPAY').toUpperCase();
                  log.info(`ğŸ”„ Fallback ke: ${fallbackPayment}`);

                  await appendJsonLog({
                    event: 'payment_point_invalid_pin_fallback',
                    order_id: od.id,
                    fallback_method: fallbackPayment
                  });

                  // Set ke fallback method
                  if (fallbackPayment === 'GOPAY') {
                    selectedMethod = 'g';
                  } else if (fallbackPayment === 'SHOPEEPAY') {
                    selectedMethod = 's';
                  } else if (fallbackPayment === 'QRIS') {
                    selectedMethod = 'q';
                  } else {
                    selectedMethod = 'd'; // DANA
                  }
                  break;
                }
              } else {
                // Other errors (insufficient balance, dll) - tidak retry
                break;
              }
            }

            // Handle success atau fallback ke method lain
            if (cgvPointFailed) {
              // Skip CGV Point, akan masuk ke fallback method di bawah
            } else if (payPt?.status_code === 200) {
              const pdata = payPt.data || {};
              od = pdata;
              await appendJsonLog({ event: 'payment_point_pay_ok', order_id: od?.id, data: pdata });

              console.log(chalk.green('\nâœ… CGV Point Pay OK'));
              console.log(multilineBox([
                `Sales ID : ${pdata.sales_id || '-'}`,
                `Booking  : ${pdata.booking_code || '-'}`,
                `Pass Key : ${pdata.pass_key || '-'}`,
                `Total    : ${toRp(pdata.total_amount || 0)}`
              ]));

              // ğŸ”” Telegram summary CGV Point
              telegramPaymentMessageId = await sendTelegramPaymentSummary({
                order: od,
                movie: selectedMovie,
                dateYmd,
                schedule: selectedSchedule,
                seats: seatsPick,
                methodLabel: 'CGV Point',
                checkoutUrl: null
              });

              // âœ… AUTO SCREENSHOT SETELAH CGV POINT PAYMENT BERHASIL
              try {
                const accForLogin = selectedAccount || {};
                const salesId = pdata.sales_id;
                if (salesId && accForLogin?.email && accForLogin?.password) {
                  console.log(chalk.cyan('\nğŸŒ Auto login m.cgv.id mobile & screenshot tiket (CGV Point)...'));
                  const screenshotResult = await loginAndScreenshotTicket({
                    salesId,
                    email: accForLogin.email,
                    password: accForLogin.password,
                    bookingCode: pdata.booking_code,
                    passKey: pdata.pass_key,
                    outDir: 'orders',
                    headless: true,
                    sendToTelegram: (process.env.SEND_SCREENSHOT_TO_TELEGRAM || 'true').toLowerCase() === 'true',
                    accountName: accForLogin.name || accForLogin.fullName || accForLogin.customer_name || '',
                    accountEmail: accForLogin.email,
                    accountPassword: accForLogin.password,
                    movieTitle: pdata.movie_name || '',
                    cinemaName: pdata.cinema_name || '',
                    seatsLabel: pdata.seats?.map(s => `${s.row_name}${s.number}`).join('-') || '',
                    showDate: pdata.show_date || pdata.complete_date?.split(' ')[0] || '',
                    showTime: pdata.show_time || ''
                  });
                  
                  if (screenshotResult.success) {
                    console.log(chalk.green(`ğŸ“¸ CGV Point Screenshot berhasil: ${screenshotResult.path}`));
                    await appendJsonLog({ 
                      event: 'cgv_point_mobile_screenshot_success', 
                      file: screenshotResult.path,
                      sales_id: salesId,
                      booking_code: pdata.booking_code
                    });
                  } else {
                    console.log(chalk.yellow(`âš ï¸ CGV Point Screenshot gagal: ${screenshotResult.error}`));
                    await appendJsonLog({ 
                      event: 'cgv_point_mobile_screenshot_failed', 
                      error: screenshotResult.error,
                      sales_id: salesId
                    });
                  }
                } else {
                  console.log(chalk.yellow('â„¹ï¸ Skip screenshot CGV Point (butuh salesId + email + password).'));
                }
              } catch (e) {
                console.log(chalk.red(`âŒ CGV Point Screenshot error: ${e.message}`));
                await appendJsonLog({ 
                  event: 'cgv_point_mobile_screenshot_error', 
                  error: e.message,
                  sales_id: pdata.sales_id
                });
              }

              console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran real-time...'));
              renderFullOrderSummaryBox(od, 'Pembayaran Diproses', orderContext);
              await appendJsonLog({ event: 'pre_monitor_summary', order_id: od.id });

              monitorResult = await monitorPaymentLoop({
                orderId: od.id,
                token,
                methodLabel: 'CGV Point',
                movieName: selectedMovie.name,
                seats: seatsPick.map(s=>s.label).join(', '),
                intervalSec: 1,
                confirmEverySec: 60,
                initialRapidSec: 20,
                rapidIntervalSec: 1,
                orderContext,
                telegramMessageId: telegramPaymentMessageId
              });

              od = monitorResult?.order || od;
              const finalStatusLabel = statusLabelFromResult(monitorResult?.status, od);
              renderFullOrderSummaryBox(od, finalStatusLabel, orderContext);
              await appendJsonLog({ event: 'post_monitor_summary', order_id: od?.id, status: monitorResult?.status });

              cgvPointSuccess = true;

            } else {
              // Error handling untuk kasus selain success/invalid PIN (yang sudah di-handle di retry loop)
              const sc = payPt?.status_code;
              const msg = String(payPt?.message || '').trim();

              log.error(`CGV Point Pay gagal: ${payPt?.message || 'Unknown error'}`);
              console.log(chalk.gray('ğŸ” FULL JSON (debug):'));
              console.log(chalk.gray(JSON.stringify(payPt, null, 2)));
              await appendJsonLog({ event: 'payment_point_pay_failed', order_id: od.id, response: payPt });

              // Jika CGV Point gagal (insufficient balance), fallback ke metode lain
              if (sc === 422 && /insufficient\s*balance/i.test(msg)) {
                cgvPointFailed = true;

                const fallbackPayment = (process.env.FALLBACK_PAYMENT || 'GOPAY').toUpperCase();

                log.warning('âš ï¸  CGV Point gagal (saldo tidak cukup).');
                log.info(`ğŸ”„ Fallback ke metode pembayaran cadangan: ${fallbackPayment}`);

                // Set selected method ke fallback payment
                if (fallbackPayment === 'GOPAY') {
                  selectedMethod = 'g';
                } else if (fallbackPayment === 'SHOPEEPAY') {
                  selectedMethod = 's';
                } else if (fallbackPayment === 'QRIS') {
                  selectedMethod = 'q';
                } else {
                  selectedMethod = 'd'; // Default DANA
                }
              } else {
                log.error('âŒ CGV Point gagal dengan error lain.');
              }
            }
          }

        }

        // Continue with fallback payment if CGV Point failed
        if (!cgvPointSuccess && selectedMethod === 'g') {
          log.section('ğŸ’³ PEMBAYARAN â€” GOPAY (shortcut g)');
          const gopay = findGopay(payRes);

          if (!gopay) {
            log.warning('Metode GOPAY tidak tersedia saat ini. Tampilkan daftar metode sebagai alternatif.');
            log.section('ğŸ’³ METODE PEMBAYARAN');
            renderPaymentMethodsTable(payRes);
          } else {
            log.process('Menyiapkan payment partner (select)...');
            const sel = await paymentPartnerSelect(
              od.id,
              gopay.category_id,
              gopay.payment_id,
              token
            );

            if (sel?.status_code !== 200) {
              log.error(`Select payment partner GOPAY gagal: ${sel?.message || 'Unknown error'}`);
              await appendJsonLog({
                event: 'payment_partner_select_failed',
                response: sel,
                order_id: od.id,
                method: gopay
              });
            } else {
              await appendJsonLog({
                event: 'payment_partner_selected',
                order_id: od.id,
                method: gopay,
                data: sel?.data
              });

              log.process('Memproses pembayaran (pay) via GOPAY...');
              const pay = await paymentPartnerPay(od.id, token);

              if (pay?.status_code !== 200) {
                log.error(`Payment init GOPAY gagal: ${pay?.message || 'Unknown error'}`);
                await appendJsonLog({
                  event: 'payment_partner_pay_failed',
                  response: pay,
                  order_id: od.id
                });
              } else {
                const pdata = pay.data || {};
                od = pdata;
                await appendJsonLog({
                  event: 'payment_partner_pay_ok',
                  order_id: od.id,
                  data: pdata
                });

                // Get order detail untuk ambil payment_gateway_transaction_id
                let checkoutUrl = '';
                let qrString = '';
                let qrDataUrl = '';

                // RETRY LOGIC: Coba sampai dapat transaction_id (max 10x dengan delay)
                let transactionId = null;
                let retryCount = 0;
                const maxRetries = 10;
                const retryDelay = 1000; // 1 detik

                while (!transactionId && retryCount < maxRetries) {
                  try {
                    const orderDetail = await fetchOrderDetail(od.id, token);
                    if (orderDetail?.status_code === 200 && orderDetail?.data) {
                      const detailData = orderDetail.data;

                      // Update od with detail data (termasuk booking_code jika ada)
                      if (detailData.booking_code) {
                        od.booking_code = detailData.booking_code;
                      }

                      transactionId = detailData.payment_gateway_transaction_id;

                      if (transactionId) {
                        console.log(chalk.green(`âœ… Transaction ID ditemukan: ${transactionId}`));
                        break; // Keluar dari loop
                      } else {
                        retryCount++;
                        if (retryCount < maxRetries) {
                          console.log(chalk.yellow(`â³ Transaction ID belum tersedia, retry ${retryCount}/${maxRetries}...`));
                          await delay(retryDelay);
                        }
                      }
                    } else {
                      retryCount++;
                      if (retryCount < maxRetries) {
                        console.log(chalk.yellow(`â³ Order detail belum siap, retry ${retryCount}/${maxRetries}...`));
                        await delay(retryDelay);
                      }
                    }
                  } catch (err) {
                    retryCount++;
                    if (retryCount < maxRetries) {
                      console.log(chalk.yellow(`âš ï¸ Error fetch order detail: ${err.message}, retry ${retryCount}/${maxRetries}...`));
                      await delay(retryDelay);
                    }
                  }
                }

                // Process transaction_id if found
                if (transactionId) {
                  // Buat URL Midtrans QR Code dari transaction ID
                  checkoutUrl = `${MIDTRANS_GOPAY_API_URL}/${transactionId}/qr-code`;
                  await appendJsonLog({
                    event: 'gopay_midtrans_qr_generated',
                    order_id: od.id,
                    transaction_id: transactionId,
                    qr_url: checkoutUrl,
                    booking_code: od.booking_code || null
                  });

                  // RETRY LOGIC: Decode QR dari Midtrans dengan retry sampai berhasil
                  const maxQrRetries = 3; // Reduce retry count (3 is enough)
                  let qrRetryCount = 0;

                  while (!qrString && qrRetryCount < maxQrRetries) {
                    qrRetryCount++;
                    console.log(chalk.cyan(`âš¡ Mencoba decode QR (attempt ${qrRetryCount}/${maxQrRetries})...`));

                    // ğŸ†• Add cache-busting untuk force fresh fetch dari server
                    // Retry ke-2 dan seterusnya: tambah timestamp untuk bypass cache
                    let fetchUrl = checkoutUrl;
                    if (qrRetryCount > 1) {
                      const separator = checkoutUrl.includes('?') ? '&' : '?';
                      fetchUrl = `${checkoutUrl}${separator}_t=${Date.now()}`;
                      console.log(chalk.gray(`â„¹ï¸  Cache-busting: ${fetchUrl}`));
                    }

                    const result = await decodeQRFromMidtrans(fetchUrl);

                    // Check if result is string (success) or error object
                    if (typeof result === 'string') {
                      qrString = result;
                      console.log(chalk.green('âœ… QR Code berhasil didecode!'));

                      // Generate QR code image dari string
                      qrDataUrl = await generateQRCodeImage(qrString);

                      // Display QR code in terminal
                      displayQRInTerminal(qrString);

                      await appendJsonLog({
                        event: 'gopay_qr_decoded',
                        order_id: od.id,
                        qr_length: qrString.length
                      });
                      break; // Berhasil, keluar dari loop
                    }

                    // Failed - retry with increasing delay + re-fetch URL
                    if (qrRetryCount < maxQrRetries) {
                      const retryDelay = Math.min(1000 + (qrRetryCount * 500), 4000); // Progressive delay: 1.5s, 2s, 2.5s, 3s, 3.5s, 4s max
                      const errorMsg = (result && result.error) ? result.error : 'Unknown error';
                      console.log(chalk.yellow(`âš ï¸ Gagal decode QR (${errorMsg}), retry dalam ${retryDelay/1000}s...`));
                      console.log(chalk.gray('â„¹ï¸  Menunggu server memuat image dengan benar...'));
                      await delay(retryDelay);

                      // ğŸ†• Re-fetch URL untuk mendapatkan fresh image
                      // Kadang image belum termuat dengan benar di server
                      if (qrRetryCount > 1) {
                        console.log(chalk.cyan('âš¡ Re-fetch QR URL untuk mendapatkan image yang fresh...'));
                        // URL sama, tapi request baru bisa dapat image yang sudah termuat
                        // Tambah delay ekstra untuk memberi waktu server
                        await delay(1000);
                      }
                    } else {
                      console.log(chalk.red('âŒ Gagal decode QR setelah semua retry, fallback ke link Midtrans'));
                      console.log(chalk.yellow('â„¹ï¸  Jangan khawatir, Anda tetap bisa bayar via link yang dikirim ke Telegram'));
                    }
                  }
                } else {
                  // Fallback jika setelah retry masih gagal
                  console.log(chalk.red('âŒ Gagal mendapatkan transaction_id setelah retry, gunakan fallback link'));
                  try {
                    const orderDetail = await fetchOrderDetail(od.id, token);
                    if (orderDetail?.status_code === 200 && orderDetail?.data) {
                      const detailData = orderDetail.data;
                      checkoutUrl = htmlDecode(
                        detailData.gopay_deeplink || detailData.payment_checkouturl || ''
                      );
                    }
                  } catch (err) {
                    // Final fallback ke pdata
                    checkoutUrl = htmlDecode(
                      pdata.payment_checkouturl || pdata.dana_checkouturl || ''
                    );
                  }
                }

                log.section('ğŸ§¾ PAYMENT SUMMARY');
                const lines = buildPaymentSummaryLines(pdata, 'GOPAY (E-WALLET)');
                console.log(multilineBox(lines));

                if (qrString) {
                  console.log(chalk.green('\nâœ… QR Code siap di-scan (lihat di atas atau di Telegram)'));
                  console.log(chalk.gray(`Midtrans URL: ${checkoutUrl}`));
                } else if (checkoutUrl) {
                  console.log(chalk.yellow('\nğŸ’¡ Buka link berikut untuk membayar:'));
                  console.log(chalk.blue(checkoutUrl));
                }

                // ğŸ”” Telegram summary GOPAY + QR Code (gabung jadi 1 pesan)
                const voucherInfo = getVoucherInfo(pdata);

                // Build comprehensive caption for QR code
                if (qrDataUrl) {
                  const seatLabels = seatsPick.map(s => (s.label || s)).join(', ');
                  const tgl = `${dateYmd.slice(6,8)}/${dateYmd.slice(4,6)}/${dateYmd.slice(0,4)}`;
                  const jam = selectedSchedule?.start_time || '';

                  // Gabungkan semua info dalam 1 caption
                  const qrCaption =
                    `ğŸ¬ <b>CGV Auto Order â€” Payment Init</b>\n\n` +
                    `<b>Film:</b> ${selectedMovie.name}\n` +
                    `<b>Tanggal:</b> ${tgl} ${jam}\n` +
                    `<b>Kursi:</b> ${seatLabels}\n` +
                    `<b>Metode:</b> GOPAY (E-WALLET)\n\n` +
                    `<b>Order ID:</b> ${od.id}\n` +
                    `<b>Booking:</b> ${od.booking_code || pdata.booking_code || '-'}\n\n` +
                    `<b>Subtotal:</b> ${toRp((od.total_amount || 0) - (od.admin_fee || 0))}\n` +
                    `<b>Admin Fee:</b> ${toRp(od.admin_fee || 0)}\n` +
                    `<b>Total:</b> ${toRp(od.total_amount || 0)}\n` +
                    `<b>Expire:</b> ${od.expired_date || '-'}\n\n` +
                    `ğŸ”— <a href="${checkoutUrl}">Link Pembayaran</a>\n\n` +
                    `ğŸ“± <b>Scan QR Code di atas untuk membayar</b>\n` +
                    `ğŸ“Š Status akan dimonitor otomatis oleh bot`;

                  telegramPaymentMessageId = await sendTelegramQRCode(qrDataUrl, qrCaption);
                } else {
                  // Fallback: jika tidak ada QR, kirim text summary saja
                  telegramPaymentMessageId = await sendTelegramPaymentSummary({
                    order: od,
                    movie: selectedMovie,
                    dateYmd,
                    schedule: selectedSchedule,
                    seats: seatsPick,
                    methodLabel: 'GOPAY (E-WALLET)',
                    checkoutUrl,
                    ...voucherInfo
                  });
                }

                console.log(chalk.green('\nâœ… Pembayaran via GOPAY berhasil diinisialisasi!'));
                console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran real-time...'));

                renderFullOrderSummaryBox(od, 'Pembayaran Diproses', orderContext);
                await appendJsonLog({ event: 'pre_monitor_summary', order_id: od.id });

                monitorResult = await monitorPaymentLoop({
                  orderId: od.id,
                  token,
                  methodLabel: 'GOPAY',
                  movieName: selectedMovie.name,
                  seats: seatsPick.map(s=>s.label).join(', '),
                  intervalSec: 1,
                  confirmEverySec: 60,
                  initialRapidSec: 20,
                  rapidIntervalSec: 1,
                  orderContext,
                  telegramMessageId: telegramPaymentMessageId
                });

                od = monitorResult?.order || od;
                const finalStatusLabel = statusLabelFromResult(monitorResult?.status, od);
                renderFullOrderSummaryBox(od, finalStatusLabel, orderContext);
                await appendJsonLog({
                  event: 'post_monitor_summary',
                  order_id: od?.id,
                  status: monitorResult?.status
                });
              }
            }
          }

        // === Jalur cepat QRIS (shortcut "q") ===
        } else if (selectedMethod === 'q') {
          log.section('ğŸ’³ PEMBAYARAN â€” QRIS (shortcut q)');
          const qris = findQris(payRes);

          if (!qris) {
            log.warning('Metode QRIS belum tersedia / tidak aktif. Silakan pilih metode lain.');
            log.section('ğŸ’³ METODE PEMBAYARAN');
            renderPaymentMethodsTable(payRes);
          } else {
            log.process('Menyiapkan payment partner (select)...');
            const sel = await paymentPartnerSelect(
              od.id,
              qris.category_id,
              qris.payment_id,
              token
            );

            if (sel?.status_code !== 200) {
              log.error(`Select payment partner QRIS gagal: ${sel?.message || 'Unknown error'}`);
              await appendJsonLog({
                event: 'payment_partner_select_failed',
                response: sel,
                order_id: od.id,
                method: qris
              });
            } else {
              await appendJsonLog({
                event: 'payment_partner_selected',
                order_id: od.id,
                method: qris,
                data: sel?.data
              });

              log.process('Memproses pembayaran (pay) via QRIS...');
              const pay = await paymentPartnerPay(od.id, token);

              if (pay?.status_code !== 200) {
                log.error(`Payment init QRIS gagal: ${pay?.message || 'Unknown error'}`);
                await appendJsonLog({
                  event: 'payment_partner_pay_failed',
                  response: pay,
                  order_id: od.id
                });
              } else {
                const pdata = pay.data || {};
                od = pdata;
                await appendJsonLog({
                  event: 'payment_partner_pay_ok',
                  order_id: od.id,
                  data: pdata
                });

                const checkoutUrl = htmlDecode(
                  pdata.payment_checkouturl || pdata.dana_checkouturl || ''
                );

                log.section('ğŸ§¾ PAYMENT SUMMARY');
                const lines = buildPaymentSummaryLines(pdata, 'QRIS (E-WALLET)');
                console.log(multilineBox(lines));

                // ğŸ”” Telegram summary QRIS
                const voucherInfo = getVoucherInfo(pdata);
                telegramPaymentMessageId = await sendTelegramPaymentSummary({
                  order: od,
                  movie: selectedMovie,
                  dateYmd,
                  schedule: selectedSchedule,
                  seats: seatsPick,
                  methodLabel: 'QRIS (E-WALLET)',
                  checkoutUrl,
                  ...voucherInfo
                });

                if (checkoutUrl) {
                  console.log(chalk.yellow('\nğŸ’¡ Silakan scan / buka link QRIS berikut untuk menyelesaikan pembayaran:'));
                  console.log(chalk.blue(checkoutUrl));
                }

                console.log(chalk.green('\nâœ… Pembayaran via QRIS berhasil diinisialisasi!'));
                console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran real-time...'));

                renderFullOrderSummaryBox(od, 'Pembayaran Diproses', orderContext);
                await appendJsonLog({ event: 'pre_monitor_summary', order_id: od.id });

                monitorResult = await monitorPaymentLoop({
                  orderId: od.id,
                  token,
                  methodLabel: 'QRIS',
                  movieName: selectedMovie.name,
                  seats: seatsPick.map(s=>s.label).join(', '),
                  intervalSec: 1,
                  confirmEverySec: 60,
                  initialRapidSec: 20,
                  rapidIntervalSec: 1,
                  orderContext,
                  telegramMessageId: telegramPaymentMessageId
                });

                od = monitorResult?.order || od;
                const finalStatusLabel = statusLabelFromResult(monitorResult?.status, od);
                renderFullOrderSummaryBox(od, finalStatusLabel, orderContext);
                await appendJsonLog({
                  event: 'post_monitor_summary',
                  order_id: od?.id,
                  status: monitorResult?.status
                });
              }
            }
          }

        } else if (selectedMethod === 's') {
          log.section('ğŸ’³ PEMBAYARAN â€” SHOPEEPAY (shortcut s)');
          const shopeepay = findShopeePay(payRes);

          if (!shopeepay) {
            log.warning('Metode SHOPEEPAY tidak tersedia saat ini. Tampilkan daftar metode sebagai alternatif.');
            log.section('ğŸ’³ METODE PEMBAYARAN');
            renderPaymentMethodsTable(payRes);
          } else {
            log.process('Menyiapkan payment partner (select)...');
            const sel = await paymentPartnerSelect(
              od.id,
              shopeepay.category_id,
              shopeepay.payment_id,
              token
            );

            if (sel?.status_code !== 200) {
              log.error(`Select payment partner SHOPEEPAY gagal: ${sel?.message || 'Unknown error'}`);
              await appendJsonLog({
                event: 'payment_partner_select_failed',
                response: sel,
                order_id: od.id,
                method: shopeepay
              });
            } else {
              await appendJsonLog({
                event: 'payment_partner_selected',
                order_id: od.id,
                method: shopeepay,
                data: sel?.data
              });

              log.process('Memproses pembayaran (pay)...');
              const pay = await paymentPartnerPay(od.id, token);

              if (pay?.status_code !== 200) {
                log.error(`Pay gagal: ${pay?.message || 'Unknown error'}`);
                await appendJsonLog({
                  event: 'payment_partner_pay_failed',
                  response: pay,
                  order_id: od.id
                });
              } else {
                const pdata = pay.data || {};
                od = pdata;
                await appendJsonLog({
                  event: 'payment_partner_pay_ok',
                  order_id: od.id,
                  data: pdata
                });

                const checkoutUrl = htmlDecode(
                  pdata.payment_checkouturl || pdata.shopeepay_checkouturl || ''
                );

                log.section('ğŸ§¾ PAYMENT SUMMARY');
                const lines = buildPaymentSummaryLines(pdata, 'SHOPEEPAY (E-WALLET)');
                console.log(multilineBox(lines));

                // ğŸ”” Telegram summary SHOPEEPAY
                const voucherInfo = getVoucherInfo(pdata);
                telegramPaymentMessageId = await sendTelegramPaymentSummary({
                  order: od,
                  movie: selectedMovie,
                  dateYmd,
                  schedule: selectedSchedule,
                  seats: seatsPick,
                  methodLabel: 'SHOPEEPAY (E-WALLET)',
                  checkoutUrl,
                  ...voucherInfo
                });

                if (checkoutUrl) {
                  console.log(chalk.yellow('\nğŸ’¡ Silakan buka link SHOPEEPAY berikut secara manual:'));
                  console.log(chalk.blue(checkoutUrl));
                }

                console.log(chalk.green('\nâœ… Pembayaran via SHOPEEPAY berhasil diinisialisasi!'));
                console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran real-time...'));

                renderFullOrderSummaryBox(od, 'Pembayaran Diproses', orderContext);
                await appendJsonLog({ event: 'pre_monitor_summary', order_id: od.id });

                monitorResult = await monitorPaymentLoop({
                  orderId: od.id,
                  token,
                  methodLabel: 'SHOPEEPAY',
                  movieName: selectedMovie.name,
                  seats: seatsPick.map(s=>s.label).join(', '),
                  intervalSec: 1,
                  confirmEverySec: 60,
                  initialRapidSec: 20,
                  rapidIntervalSec: 1,
                  orderContext,
                  telegramMessageId: telegramPaymentMessageId
                });

                od = monitorResult?.order || od;
                const finalStatusLabel = statusLabelFromResult(monitorResult?.status, od);
                renderFullOrderSummaryBox(od, finalStatusLabel, orderContext);
                await appendJsonLog({
                  event: 'post_monitor_summary',
                  order_id: od?.id,
                  status: monitorResult?.status
                });
              }
            }
          }

        } else if (defaultDana) {
          const dana = findDana(payRes);
          if (!dana) {
            log.warning('Metode DANA tidak tersedia saat ini. Tampilkan daftar metode sebagai alternatif.');
            log.section('ğŸ’³ METODE PEMBAYARAN');
            renderPaymentMethodsTable(payRes);
          } else {
            // Select partner (tanpa bank_id untuk DANA)
            log.process('Menyiapkan payment partner (select)...');
            const sel = await paymentPartnerSelect(od.id, dana.category_id, dana.payment_id, token);
            if (sel?.status_code !== 200) {
              log.error(`Select payment partner gagal: ${sel?.message || 'Unknown error'}`);
              await appendJsonLog({ event: 'payment_partner_select_failed', response: sel, order_id: od.id, method: dana });
            } else {
              await appendJsonLog({ event: 'payment_partner_selected', order_id: od.id, method: dana, data: sel?.data });
              // Pay
              log.process('Memproses pembayaran (pay)...');
              const pay = await paymentPartnerPay(od.id, token);
              if (pay?.status_code !== 200) {
                const errorMsg = pay?.message || 'Unknown error';
                console.log(chalk.red('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
                console.log(chalk.red('â”‚') + chalk.white.bold('                    PAYMENT ERROR                          ') + chalk.red('â”‚'));
                console.log(chalk.red('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
                console.log(chalk.red('â”‚') + ` Error: ${errorMsg.slice(0,50).padEnd(50)} ` + chalk.red('â”‚'));
                if (/timeout|timed out/i.test(errorMsg)) {
                  console.log(chalk.red('â”‚') + ' Kemungkinan masalah jaringan atau server CGV sedang sibuk.  ' + chalk.red('â”‚'));
                  console.log(chalk.red('â”‚') + ' Sistem sudah mencoba retry otomatis.                       ' + chalk.red('â”‚'));
                }
                console.log(chalk.red('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
                console.log(chalk.red('â”‚') + chalk.yellow(' Pilihan:') + '                                               ' + chalk.red('â”‚'));
                console.log(chalk.red('â”‚') + ' â€¢ Coba lagi dengan metode pembayaran yang sama            ' + chalk.red('â”‚'));
                console.log(chalk.red('â”‚') + ' â€¢ Pilih metode pembayaran lain                            ' + chalk.red('â”‚'));
                console.log(chalk.red('â”‚') + ' â€¢ Simpan order dan bayar manual nanti                     ' + chalk.red('â”‚'));
                console.log(chalk.red('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
                await appendJsonLog({ event: 'payment_partner_pay_failed', response: pay, order_id: od.id });
              } else {
                const pdata = pay.data || {};
                od = pdata;
                await appendJsonLog({ event: 'payment_partner_pay_ok', order_id: od.id, data: pdata });

                const danaUrlRaw = pdata.dana_checkouturl || '';
                const genericUrlRaw = pdata.payment_checkouturl || '';
                const checkoutUrl = htmlDecode(danaUrlRaw || genericUrlRaw);

                log.section('ğŸ§¾ PAYMENT SUMMARY');
                const lines = buildPaymentSummaryLines(pdata, `${dana.payment_name} (${dana.category_name})`);
                console.log(multilineBox(lines));

                // ğŸ”” Kirim ringkasan + link DANA ke Telegram
                const voucherInfo = getVoucherInfo(pdata);
                telegramPaymentMessageId = await sendTelegramPaymentSummary({
                  order: od,
                  movie: selectedMovie,
                  dateYmd,
                  schedule: selectedSchedule,
                  seats: seatsPick,
                  methodLabel: `${dana.payment_name} (${dana.category_name})`,
                  checkoutUrl,
                  ...voucherInfo
                });

                if (checkoutUrl) {
                  await requestJson('GET', checkoutUrl, {
                    headers: {
                      'user-agent': 'Mozilla/5.0 (Linux; Android 9; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/124.0 Mobile Safari/537.36',
                      accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
                      'accept-language': getRandomLang(),
                      'X-Requested-With': 'com.blitz.blitzandapp1'
                    },
                    note: 'open: dana checkout'
                  });

                  // Try Puppeteer Full Automation first, fallback to manual
                  let automationSuccess = false;
                  try {
                    console.log(chalk.yellow('ğŸ”„ Membuka DANA dengan full automation...'));
                    // ğŸ”’ Pastikan tidak ada browser serupa yang masih terbuka (termasuk instance Puppeteer pertama)
                    await waitForSameBrowserFree({ label: 'DANA Checkout' });
                    
                    const puppeteer = (await import('puppeteer')).default;
                    
                    const browser = await launchBrowser({
                      headless: false,
                      defaultViewport: null,
                      args: [
                        '--incognito',
                        '--no-sandbox',
                        '--disable-setuid-sandbox',
                        '--disable-dev-shm-usage',
                        '--disable-blink-features=AutomationControlled',
                        '--disable-features=VizDisplayCompositor',
                        '--disable-web-security',
                        '--no-first-run',
                        '--no-default-browser-check',
                        '--disable-extensions',
                        '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                      ]
                    });

                    
                    const page = await browser.newPage();
                    
                    // Override webdriver detection
                    await page.evaluateOnNewDocument(() => {
                      Object.defineProperty(navigator, 'webdriver', {
                        get: () => undefined,
                      });
                    });
                    
                    console.log(chalk.gray('ğŸ“± Loading DANA page...'));
                    await page.goto(checkoutUrl, { waitUntil: 'networkidle2', timeout: 30000 });
                    
                    // Wait for phone input field
                    console.log(chalk.gray('ğŸ” Looking for phone input field...'));
                    await page.waitForSelector('input[type="tel"], input[placeholder*="nomor"], input[id*="phone"], input[name*="phone"]', { timeout: 10000 });
                    
                    // Fill phone number
                    console.log(chalk.gray(`ğŸ“ Filling phone number: ${DANA_PHONE_OVERRIDE}`));
                    const phoneSelector = 'input[type="tel"], input[placeholder*="nomor"], input[id*="phone"], input[name*="phone"]';
                    await page.focus(phoneSelector);
                    await page.evaluate((selector) => {
                      const input = document.querySelector(selector);
                      if (input) input.value = '';
                    }, phoneSelector);
                    await page.type(phoneSelector, DANA_PHONE_OVERRIDE, { delay: 100 });
                    
                    // Wait a bit for validation
                    await delay(2000);
                    
                    // Look for and click continue button
                    console.log(chalk.gray('ğŸ”˜ Looking for continue button...'));
                    let buttonFound = false;
                    
                    // Try XPath for text content
                    try {
                      const [button] = await page.$x(`//button[contains(text(), 'LANJUTKAN') or contains(text(), 'Lanjutkan') or contains(text(), 'CONTINUE')]`);
                      if (button) {
                        console.log(chalk.gray('âœ… Found continue button, clicking...'));
                        await button.click();
                        buttonFound = true;
                      }
                    } catch (e) {
                      // Try CSS selectors
                      const continueSelectors = [
                        '.btn-continue',
                        '#continue-btn',
                        '[data-testid="continue"]',
                        'button[type="submit"]'
                      ];
                      
                      for (const selector of continueSelectors) {
                        try {
                          const button = await page.$(selector);
                          if (button) {
                            console.log(chalk.gray('âœ… Found continue button, clicking...'));
                            await button.click();
                            buttonFound = true;
                            break;
                          }
                        } catch (e) {
                          continue;
                        }
                      }
                    }
                    
                    if (!buttonFound) {
                      console.log(chalk.yellow('âš ï¸  Continue button not found, please click manually'));
                    }
                    
                    console.log(chalk.green('âœ… DANA automation berhasil!'));
                    console.log(chalk.white(`ğŸ“± Nomor HP ${DANA_PHONE_OVERRIDE} sudah diisi otomatis`));
                    console.log(chalk.white('ğŸ”’ Mode penyamaran aktif - bypass bot detection'));
                    console.log(chalk.gray('ğŸ”„ Lanjutkan proses pembayaran di browser'));

                    automationSuccess = true;

                    // ğŸ§¹ Auto-close setelah sukses, beri jeda 25 detik agar proses finalisasi di DANA kelar
                    const AUTO_CLOSE_DELAY_MS = 25000;
                    console.log(chalk.gray(`ğŸ§¹ Menutup browser otomatis dalam ${AUTO_CLOSE_DELAY_MS/1000}s...`));
                    await delay(AUTO_CLOSE_DELAY_MS);

                    try { await page.close({ runBeforeUnload: true }); } catch {}
                    try { await browser.close(); } catch {}
                    console.log(chalk.green('âœ… Browser Puppeteer ditutup otomatis.'));

                  } catch (automationError) {
                    console.log(chalk.yellow(`âš ï¸  Full automation gagal: ${automationError.message}`));
                  }

                  // Final fallback to manual
                  if (!automationSuccess) {
                    console.log(chalk.yellow('\nğŸ’¡ Silakan buka link DANA berikut secara manual:'));
                    console.log(chalk.blue(checkoutUrl));
                    console.log(chalk.gray(`ğŸ“± Isi nomor HP: ${DANA_PHONE_OVERRIDE} kemudian klik LANJUTKAN`));
                  }
                }

                log.success('Init pembayaran selesai. Monitoring status pembayaran dimulai.');

                // [NEW] â€” Tampilkan ringkasan lengkap SEBELUM monitoring
                renderFullOrderSummaryBox(od, 'Pembayaran Diproses', orderContext);
                await appendJsonLog({ event: 'pre_monitor_summary', order_id: od.id });

                // Monitoring
                monitorResult = await monitorPaymentLoop({
                  orderId: od.id,
                  token,
                  methodLabel: 'DANA',
                  movieName: selectedMovie.name,
                  seats: seatsPick.map(s=>s.label).join(', '),
                  intervalSec: 1,
                  confirmEverySec: 60,
                  initialRapidSec: 20,
                  rapidIntervalSec: 1,
                  orderContext,
                  telegramMessageId: telegramPaymentMessageId
                });

                // [NEW] â€” Tampilkan ringkasan lengkap SESUDAH monitoring (status sesuai)
                od = monitorResult?.order || od;
                const finalStatusLabel = statusLabelFromResult(monitorResult?.status, od);
                renderFullOrderSummaryBox(od, finalStatusLabel, orderContext);
                await appendJsonLog({ event: 'post_monitor_summary', order_id: od?.id, status: monitorResult?.status });
              }
            }
          }
        } else if (selectedMethod === 'y') {
          // User ingin pilih metode lain
          log.section('ğŸ’³ METODE PEMBAYARAN');
          renderPaymentMethodsTable(payRes);

          // Flatten active methods dgn category_id
          const activeMethods = [];
          (payRes.data||[]).forEach(cat=>{
            const catId = (cat?.category_id ?? cat?.id ?? cat?.categoryId ?? cat?.categoryID);
            (cat.items||[]).forEach(it=>{
              if (it.status) activeMethods.push({
                id: it.id,
                name: it.name,
                category_id: catId,
                category: cat.name,
              });
            });
          });
          if (!activeMethods.length) {
            log.warning('Tidak ada metode pembayaran aktif yang tersedia saat ini.');
          } else {
            const { chosenPayment } = await inquirer.prompt([{
              type: 'list',
              name: 'chosenPayment',
              message: `Pilih metode pembayaran (Total: ${toRp(od.total_amount||0)}):`,
              choices: activeMethods.map(m=>({ name: `${m.name} (${m.category})`, value: m }))
            }]);
            await appendJsonLog({ event: 'payment_chosen', method: chosenPayment, amount: od.total_amount||0 });

            // Select partner (untuk VA sertakan bank_id)
            log.process('Menyiapkan payment partner (select)...');
            const needBankId = String(chosenPayment.category_id) === '6'; // BANK TRANSFER
            const extra = needBankId ? { bank_id: String(chosenPayment.id) } : {};
            const sel = await paymentPartnerSelect(od.id, chosenPayment.category_id, chosenPayment.id, token, extra);
            if (sel?.status_code !== 200) {
              log.error(`Select payment partner gagal: ${sel?.message || 'Unknown error'}`);
              await appendJsonLog({ event: 'payment_partner_select_failed', response: sel, order_id: od.id, method: chosenPayment });
            } else {
              await appendJsonLog({ event: 'payment_partner_selected', order_id: od.id, method: chosenPayment, data: sel?.data });

              // Pay
              log.process('Memproses pembayaran (pay)...');
              const pay = await paymentPartnerPay(od.id, token);
              if (pay?.status_code !== 200) {
                log.error(`Payment init gagal: ${pay?.message || 'Unknown error'}`);
                await appendJsonLog({ event: 'payment_partner_pay_failed', response: pay, order_id: od.id });
              } else {
                const pdata = pay.data || {};
                od = pdata;
                await appendJsonLog({ event: 'payment_partner_pay_ok', order_id: od.id, data: pdata });

                const isDana = includesWord(chosenPayment.name, 'DANA') || String(chosenPayment.id) === '5';
                if (isDana) {
                  const danaUrlRaw = pdata.dana_checkouturl || '';
                  const genericUrlRaw = pdata.payment_checkouturl || '';
                  const checkoutUrl = htmlDecode(danaUrlRaw || genericUrlRaw);

                  log.section('ğŸ§¾ PAYMENT SUMMARY');
                  const lines = buildPaymentSummaryLines(pdata, `${chosenPayment.name} (${chosenPayment.category})`);
                  console.log(multilineBox(lines));

                  // ğŸ”” Kirim ringkasan + link payment ke Telegram
                  const voucherInfo = getVoucherInfo(pdata);
                  telegramPaymentMessageId = await sendTelegramPaymentSummary({
                    order: od,
                    movie: selectedMovie,
                    dateYmd,
                    schedule: selectedSchedule,
                    seats: seatsPick,
                    methodLabel: `${chosenPayment.name} (${chosenPayment.category})`,
                    checkoutUrl,
                    ...voucherInfo
                  });

                  if (checkoutUrl) {
                    await requestJson('GET', checkoutUrl, {
                      headers: {
                        'user-agent': 'Mozilla/5.0 (Linux; Android 9; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/124.0 Mobile Safari/537.36',
                        accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
                        'accept-language': getRandomLang(),
                        'X-Requested-With': 'com.blitz.blitzandapp1'
                      },
                      note: 'open: payment checkout'
                    });

                    // Try Puppeteer Full Automation first, fallback to manual
                    let automationSuccess = false;
                    try {
                      console.log(chalk.yellow('ğŸ”„ Membuka DANA dengan full automation...'));
                      // ğŸ”’ Pastikan tidak ada browser serupa yang masih terbuka (termasuk instance Puppeteer pertama)
                      await waitForSameBrowserFree({ label: 'DANA Checkout' });
                      
                      const puppeteer = (await import('puppeteer')).default;
                      
                      const browser = await launchBrowser({
                        headless: false,
                        defaultViewport: null,
                        args: [
                          '--incognito',
                          '--no-sandbox',
                          '--disable-setuid-sandbox',
                          '--disable-dev-shm-usage',
                          '--disable-blink-features=AutomationControlled',
                          '--disable-features=VizDisplayCompositor',
                          '--disable-web-security',
                          '--no-first-run',
                          '--no-default-browser-check',
                          '--disable-extensions',
                          '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                        ]
                      });

                      
                      const page = await browser.newPage();
                      
                      // Override webdriver detection
                      await page.evaluateOnNewDocument(() => {
                        Object.defineProperty(navigator, 'webdriver', {
                          get: () => undefined,
                        });
                      });
                      
                      console.log(chalk.gray('ğŸ“± Loading DANA page...'));
                      await page.goto(checkoutUrl, { waitUntil: 'networkidle2', timeout: 30000 });
                      
                      // Wait for phone input field
                      console.log(chalk.gray('ğŸ” Looking for phone input field...'));
                      await page.waitForSelector('input[type="tel"], input[placeholder*="nomor"], input[id*="phone"], input[name*="phone"]', { timeout: 10000 });
                      
                      // Fill phone number
                      console.log(chalk.gray(`ğŸ“ Filling phone number: ${DANA_PHONE_OVERRIDE}`));
                      const phoneSelector = 'input[type="tel"], input[placeholder*="nomor"], input[id*="phone"], input[name*="phone"]';
                      await page.focus(phoneSelector);
                      await page.evaluate((selector) => {
                        const input = document.querySelector(selector);
                        if (input) input.value = '';
                      }, phoneSelector);
                      await page.type(phoneSelector, DANA_PHONE_OVERRIDE, { delay: 100 });
                      
                      // Wait a bit for validation
                      await delay(2000);
                      
                      // Look for and click continue button
                      console.log(chalk.gray('ğŸ”˜ Looking for continue button...'));
                      let buttonFound = false;
                      
                      // Try XPath for text content
                      try {
                        const [button] = await page.$x(`//button[contains(text(), 'LANJUTKAN') or contains(text(), 'Lanjutkan') or contains(text(), 'CONTINUE')]`);
                        if (button) {
                          console.log(chalk.gray('âœ… Found continue button, clicking...'));
                          await button.click();
                          buttonFound = true;
                        }
                      } catch (e) {
                        // Try CSS selectors
                        const continueSelectors = [
                          '.btn-continue',
                          '#continue-btn',
                          '[data-testid="continue"]',
                          'button[type="submit"]'
                        ];
                        
                        for (const selector of continueSelectors) {
                          try {
                            const button = await page.$(selector);
                            if (button) {
                              console.log(chalk.gray('âœ… Found continue button, clicking...'));
                              await button.click();
                              buttonFound = true;
                              break;
                            }
                          } catch (e) {
                            continue;
                          }
                        }
                      }
                      
                      if (!buttonFound) {
                        console.log(chalk.yellow('âš ï¸  Continue button not found, please click manually'));
                      }
                      
                      console.log(chalk.green('âœ… DANA automation berhasil!'));
                      console.log(chalk.white(`ğŸ“± Nomor HP ${DANA_PHONE_OVERRIDE} sudah diisi otomatis`));
                      console.log(chalk.white('ğŸ”’ Mode penyamaran aktif - bypass bot detection'));
                      console.log(chalk.gray('ğŸ”„ Lanjutkan proses pembayaran di browser'));

                      automationSuccess = true;

                      // ğŸ§¹ Auto-close + jeda
                      const AUTO_CLOSE_DELAY_MS = 3000;
                      console.log(chalk.gray(`ğŸ§¹ Menutup browser otomatis dalam ${AUTO_CLOSE_DELAY_MS/1000}s...`));
                      await delay(AUTO_CLOSE_DELAY_MS);

                      try { await page.close({ runBeforeUnload: true }); } catch {}
                      try { await browser.close(); } catch {}
                      console.log(chalk.green('âœ… Browser Puppeteer ditutup otomatis.'));

                    } catch (automationError) {
                      console.log(chalk.yellow(`âš ï¸  Full automation gagal: ${automationError.message}`));
                    }

                    // Final fallback to manual
                    if (!automationSuccess) {
                      console.log(chalk.yellow('\nğŸ’¡ Silakan buka link DANA berikut secara manual:'));
                      console.log(chalk.blue(checkoutUrl));
                      console.log(chalk.gray(`ğŸ“± Isi nomor HP: ${DANA_PHONE_OVERRIDE} kemudian klik LANJUTKAN`));
                    }
                  }

                  console.log(chalk.green('\nâœ… Pembayaran berhasil diinisialisasi!'));
                  console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran real-time...'));

                  // [NEW] â€” Ringkasan lengkap SEBELUM monitoring
                  renderFullOrderSummaryBox(od, 'Pembayaran Diproses', orderContext);
                  await appendJsonLog({ event: 'pre_monitor_summary', order_id: od.id });

                  // Monitoring
                  monitorResult = await monitorPaymentLoop({
                    orderId: od.id,
                    token,
                    methodLabel: 'DANA',
                    movieName: selectedMovie.name,
                    seats: seatsPick.map(s=>s.label).join(', '),
                    intervalSec: 1,
                    confirmEverySec: 60,
                    initialRapidSec: 20,
                    rapidIntervalSec: 1,
                    orderContext,
                    telegramMessageId: telegramPaymentMessageId
                  });

                  // [NEW] â€” Ringkasan lengkap SESUDAH monitoring (status sesuai)
                  od = monitorResult?.order || od;
                  const finalStatusLabel = statusLabelFromResult(monitorResult?.status, od);
                  renderFullOrderSummaryBox(od, finalStatusLabel, orderContext);
                  await appendJsonLog({ event: 'post_monitor_summary', order_id: od?.id, status: monitorResult?.status });

                } else {
                  // BANK TRANSFER / lainnya
                  log.section('ğŸ§¾ PAYMENT SUMMARY');
                  renderVASummary(pdata);

                  // ğŸ”” Telegram summary untuk metode lain (GOPAY/OVO/VA/dll)
                  const checkoutUrl = htmlDecode(
                    pdata.payment_checkouturl || pdata.dana_checkouturl || ''
                  );
                  const voucherInfo = getVoucherInfo(pdata);
                  telegramPaymentMessageId = await sendTelegramPaymentSummary({
                    order: od,
                    movie: selectedMovie,
                    dateYmd,
                    schedule: selectedSchedule,
                    seats: seatsPick,
                    methodLabel: `${chosenPayment.name} (${chosenPayment.category})`,
                    checkoutUrl,
                    ...voucherInfo
                  });

                  if (String(chosenPayment.category_id) === '6') {
                    // Ambil detail metode (how_to_use) â€” opsional (hanya log)
                    const detail = await fetchPaymentDetail(chosenPayment.category_id, chosenPayment.id, token);
                    await appendJsonLog({ event: 'payment_detail_va', method: chosenPayment, detail });
                  }

                  log.info('Init pembayaran selesai. Monitoring status pembayaran dimulai.');

                  // [NEW] â€” Ringkasan lengkap SEBELUM monitoring
                  renderFullOrderSummaryBox(od, 'Pembayaran Diproses', orderContext);
                  await appendJsonLog({ event: 'pre_monitor_summary', order_id: od.id });

                  // Monitoring
                  monitorResult = await monitorPaymentLoop({
                    orderId: od.id,
                    token,
                    methodLabel: chosenPayment.name,
                    movieName: selectedMovie.name,
                    seats: seatsPick.map(s=>s.label).join(', '),
                    intervalSec: 1,
                    confirmEverySec: 60,
                    initialRapidSec: 20,
                    rapidIntervalSec: 1,
                    orderContext,
                    telegramMessageId: telegramPaymentMessageId
                  });

                  // [NEW] â€” Ringkasan lengkap SESUDAH monitoring
                  od = monitorResult?.order || od;
                  const finalStatusLabel = statusLabelFromResult(monitorResult?.status, od);
                  renderFullOrderSummaryBox(od, finalStatusLabel, orderContext);
                  await appendJsonLog({ event: 'post_monitor_summary', order_id: od?.id, status: monitorResult?.status });
                }
              }
            }
          }
        } else {
          // Handle unexpected payment method selection
          log.warning('Metode pembayaran tidak valid. Gunakan opsi yang tersedia.');
        }
      }
    } else if (nextAction === 'cancel') {
      log.process('Mencoba membatalkan pesanan...');
      const cancelRes = await cancelOrder(od.id, token);
      if (cancelRes?.status_code === 200) {
        log.success(`Order ${od.id} dibatalkan (server OK).`);
        await appendJsonLog({ event: 'order_canceled', order_id: od.id, response: cancelRes });
        monitorResult = { status: 'canceled', order: od };
      } else {
        log.error(`Gagal cancel order: ${cancelRes?.message || 'Unknown error'}`);
        await appendJsonLog({ event: 'order_cancel_failed', order_id: od.id, response: cancelRes });
        monitorResult = { status: 'pending', order: od };
      }
    } else {
      log.info('Pesanan disimpan. Kamu bisa lanjutkan pembayaran nanti selama belum expired.');
      await appendJsonLog({ event: 'order_saved_for_later', order_id: od.id });
      monitorResult = { status: 'pending', order: od };
    }
  } // end if (!monitorResult)

  // ===== Final comprehensive summary (menggunakan status terbaru) =====
  const finalStatusForSummary = statusLabelFromResult(
    monitorResult?.status,
    monitorResult?.order || od
  );
  renderFullOrderSummaryBox(monitorResult?.order || od, finalStatusForSummary, orderContext);

  // ğŸ”„ Auto hapus pesan Telegram untuk SEMUA status akhir
  if (telegramPaymentMessageId && monitorResult && monitorResult.status) {
    await deleteTelegramPaymentMessage(telegramPaymentMessageId);
    await appendJsonLog({
      event: 'telegram_payment_message_deleted',
      message_id: telegramPaymentMessageId,
      final_status: monitorResult.status,
      order_id: (monitorResult.order || od)?.id
    });
  }

  await appendJsonLog({
    event: 'session_end',
    reason: 'normal',
    final_order: monitorResult?.order || od,
    final_status: monitorResult?.status
  });

  await inquirer.prompt([{ type: 'input', name: 'pause', message: 'Press Enter to return to menu...' }]);
}

// Export untuk digunakan
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { autoOrder };
} else if (typeof window !== 'undefined') {
  window.autoOrder = autoOrder;
}

//================================================================
// ğŸ¿ AUTO ORDER F&B (CGV) â€” Complete F&B Ordering System
// - Account selection dengan table display
// - City input + Cinema selection
// - F&B categories & items browsing
// - Item customization (combo solo dll)
// - Quantity selection (default 1)
// - Shopping cart system
// - Booking & payment flow
//================================================================

async function autoOrderFnb(options = {}) {
  const {
    baseURL = 'https://v2-api.cgv.id',
    accountJsonPath = 'account.json',
    logJsonPath = 'log.json'
  } = options;

  const DANA_PHONE_OVERRIDE = '082296813933'; // tidak ditampilkan/di-log

  // ---------- PAYMENT GATEWAY SETTINGS ----------
  const MIDTRANS_GOPAY_API_URL = process.env.MIDTRANS_GOPAY_API_URL || 'https://api.midtrans.com/v2/gopay';

  // ---------- FALLBACK MODULES ----------
const chalk = (globalThis.chalk && globalThis.chalk.green) ? globalThis.chalk : (await import('chalk')).default;
const fs = (globalThis.fs && globalThis.fs.readFile) ? globalThis.fs : (await import('fs/promises'));
const inquirer = (globalThis.inquirer && globalThis.inquirer.prompt) ? globalThis.inquirer : (await import('inquirer')).default;
const path = (await import('path')).default;  // ğŸ‘ˆ TAMBAHKAN INI

  // ---------- QR CODE UTILS ----------
  const QRCode = await import('qrcode');
  const QRTerminal = await import('qrcode-terminal');
  const axios = (await import('axios')).default;
  const Jimp = (await import('jimp')).Jimp;
  const QrCodeReader = (await import('qrcode-reader')).default;

  // Decode QR Code dari Midtrans URL (fetch PNG â†’ decode) with multiple strategies
  async function decodeQRFromMidtrans(qrCodeUrl) {
    try {
      // 1. Fetch PNG dari Midtrans dengan validasi content-type
      console.log(chalk.cyan('âš¡ Mengambil QR image dari Midtrans...'));
      const response = await axios.get(qrCodeUrl, {
        responseType: 'arraybuffer',
        timeout: 25000,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          'Accept': 'image/png,image/*;q=0.9,*/*;q=0.8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache',
          'Expires': '0'
        }
      });

      // Validate content-type (seperti script yang berhasil)
      const contentType = response.headers['content-type'] || '';
      console.log(chalk.gray(`â„¹ï¸  Content-Type: ${contentType}`));

      if (!contentType.includes('image')) {
        throw new Error('Midtrans tidak return image (mungkin HTML/JSON error)');
      }

      // Validate response data
      if (!response.data || response.data.length < 100) {
        throw new Error('Invalid or empty image data received');
      }

      // Convert to Buffer (penting untuk compatibility)
      const buffer = Buffer.from(response.data);

      // Wait to ensure image is fully loaded
      await delay(500);

      // 2. Load image dengan Jimp
      console.log(chalk.cyan('âš¡ Memproses QR image...'));

      // 3. Try multiple preprocessing strategies (seperti script yang berhasil)
      const preprocessStrategies = [
        { name: 'greyscale+contrast', fn: (img) => img.greyscale().contrast(1) }, // Strategy yang berhasil
        { name: 'original', fn: null },
        { name: 'greyscale', fn: (img) => img.greyscale() },
        { name: 'greyscale+high-contrast', fn: (img) => img.greyscale().contrast(0.8) },
        { name: 'contrast+brightness', fn: (img) => img.contrast(0.5).brightness(0.1) },
        { name: 'high-contrast', fn: (img) => img.contrast(0.7) },
        { name: 'normalized', fn: (img) => img.normalize() },
        { name: 'normalized+contrast', fn: (img) => img.normalize().contrast(0.5) },
        { name: 'brightness', fn: (img) => img.brightness(0.2) },
        { name: 'invert', fn: (img) => img.invert() }
      ];

      console.log(chalk.cyan('âš¡ Mencoba decode QR dengan multiple strategies...'));

      for (const strategy of preprocessStrategies) {
        try {
          // Re-read image untuk setiap strategy (fresh copy)
          const img = await Jimp.read(buffer);

          // Apply preprocessing (mutate langsung seperti script yang berhasil)
          if (strategy.fn) {
            strategy.fn(img);
          }

          const { bitmap } = img;
          const qr = new QrCodeReader();

          const result = await Promise.race([
            new Promise((resolve) => {
              qr.callback = (err, value) => {
                if (err) {
                  // Silent fail (terlalu verbose)
                  resolve(null);
                  return;
                }
                if (!value || !value.result) {
                  // Silent fail (terlalu verbose)
                  resolve(null);
                  return;
                }
                resolve(value.result);
              };

              try {
                qr.decode(bitmap);
              } catch (decodeErr) {
                // Silent fail (terlalu verbose)
                resolve(null);
              }
            }),
            new Promise((resolve) => setTimeout(() => {
              // Timeout (tidak perlu log karena terlalu verbose)
              resolve(null);
            }, 5000))
          ]);

          if (result) {
            console.log(chalk.green(`âœ… QR decoded berhasil dengan strategy: ${strategy.name}`));
            return result;
          }
        } catch (strategyErr) {
          // Silent fail (terlalu verbose)
          continue;
        }
      }

      // Semua strategies gagal dari memory buffer
      // ğŸ†• FALLBACK: Download ke file lokal dan decode dari file
      console.log(chalk.yellow('âš ï¸ Decode dari memory gagal, mencoba download ke file...'));

      try {
        const fs = require('fs');
        const os = require('os');
        const path = require('path');

        // Generate temp filename
        const tempDir = os.tmpdir();
        const tempFile = path.join(tempDir, `qr_fnb_${Date.now()}.png`);

        // Save buffer to file
        console.log(chalk.cyan(`âš¡ Menyimpan QR ke: ${tempFile}`));
        fs.writeFileSync(tempFile, buffer);

        // Decode dari file (lebih reliable)
        console.log(chalk.cyan('âš¡ Decode QR dari file...'));

        for (const strategy of preprocessStrategies) {
          try {
            // Read dari file
            const img = await Jimp.read(tempFile);

            // Apply preprocessing
            if (strategy.fn) {
              strategy.fn(img);
            }

            const { bitmap } = img;
            const qr = new QrCodeReader();

            const result = await Promise.race([
              new Promise((resolve) => {
                qr.callback = (err, value) => {
                  if (err) {
                    resolve(null);
                    return;
                  }
                  if (!value || !value.result) {
                    resolve(null);
                    return;
                  }
                  resolve(value.result);
                };

                try {
                  qr.decode(bitmap);
                } catch (decodeErr) {
                  resolve(null);
                }
              }),
              new Promise((resolve) => setTimeout(() => resolve(null), 5000))
            ]);

            if (result) {
              console.log(chalk.green(`âœ… QR decoded dari file dengan strategy: ${strategy.name}`));
              // Cleanup file
              try {
                fs.unlinkSync(tempFile);
                console.log(chalk.gray('ğŸ—‘ï¸  Temp file cleaned up'));
              } catch (cleanupErr) {
                console.log(chalk.gray(`âš ï¸ Gagal hapus temp file: ${cleanupErr.message}`));
              }
              return result;
            }
          } catch (strategyErr) {
            continue;
          }
        }

        // Cleanup file jika semua gagal
        try {
          fs.unlinkSync(tempFile);
          console.log(chalk.gray('ğŸ—‘ï¸  Temp file cleaned up (no decode success)'));
        } catch (cleanupErr) {
          console.log(chalk.gray(`âš ï¸ Gagal hapus temp file: ${cleanupErr.message}`));
        }

      } catch (fileErr) {
        console.log(chalk.yellow(`âš ï¸ Fallback file decode gagal: ${fileErr.message}`));
      }

      // Jika semua gagal (memory + file)
      return { error: 'decode_failed', retriable: true };

    } catch (err) {
      console.log(chalk.yellow(`âš ï¸ Gagal fetch/decode QR dari Midtrans: ${err.message}`));
      console.log(chalk.yellow('â„¹ï¸  Skip QR decode, gunakan link Midtrans saja.'));
      return { error: err.message, retriable: true }; // Bisa retry (network issue)
    }
  }

  // Generate QR Code image (base64 data URL) dari string
  async function generateQRCodeImage(text) {
    try {
      const dataUrl = await QRCode.toDataURL(text, {
        width: 512,
        margin: 2,
        color: {
          dark: '#000000',
          light: '#FFFFFF'
        }
      });
      return dataUrl;
    } catch (err) {
      console.log(chalk.yellow(`âš ï¸ Gagal generate QR image: ${err.message}`));
      return null;
    }
  }

  // Display QR Code di terminal
  function displayQRInTerminal(text) {
    try {
      console.log('\n' + chalk.cyan('â•'.repeat(60)));
      console.log(chalk.cyan.bold('  ğŸ“± SCAN QR CODE GOPAY (MIDTRANS) DI BAWAH INI'));
      console.log(chalk.cyan('â•'.repeat(60)) + '\n');
      QRTerminal.default.generate(text, { small: true });
      console.log('\n' + chalk.cyan('â•'.repeat(60)));
      console.log(chalk.yellow('ğŸ’¡ Scan QR Code di atas untuk membayar'));
      console.log(chalk.cyan('â•'.repeat(60)));
    } catch (err) {
      console.log(chalk.yellow(`âš ï¸ Gagal tampilkan QR di terminal: ${err.message}`));
    }
  }

  // HTML entity decoder
  function htmlDecode(input) {
    const s = String(input || '');
    return s
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&#x2F;/g, '/')
      .replace(/&#(\d+);/g, (_,n)=>String.fromCharCode(Number(n)))
      .replace(/&#x([0-9a-fA-F]+);/g, (_,h)=>String.fromCharCode(parseInt(h,16)));
  }

  // Send QR Code to Telegram
  async function sendTelegramQRCode(qrDataUrl, caption = '') {
    try {
      const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
      const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID;

      if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) {
        console.log(chalk.yellow('âš ï¸ Telegram credentials missing'));
        return null;
      }

      if (!qrDataUrl) {
        console.log(chalk.yellow('âš ï¸ QR data URL is empty'));
        return null;
      }

      console.log(chalk.cyan('ğŸ“¤ Mengirim QR Code ke Telegram...'));

      // Convert data URL to buffer
      const base64Data = qrDataUrl.replace(/^data:image\/\w+;base64,/, '');
      const buffer = Buffer.from(base64Data, 'base64');

      console.log(chalk.gray(`   Buffer size: ${(buffer.length / 1024).toFixed(2)} KB`));

      const FormData = (await import('form-data')).default;
      const form = new FormData();
      form.append('chat_id', TELEGRAM_CHAT_ID);
      form.append('photo', buffer, { filename: 'gopay-qr.png' });
      if (caption) {
        form.append('caption', caption);
        form.append('parse_mode', 'HTML');
      }

      const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;

      // Use axios instead of fetch for better compatibility with form-data
      const response = await axios.post(url, form, {
        headers: form.getHeaders()
      });

      if (response.data && response.data.ok) {
        console.log(chalk.green('âœ… QR Code berhasil dikirim ke Telegram!'));
        return response.data.result?.message_id || null;
      } else {
        console.log(chalk.red(`âŒ Telegram response not OK: ${response.data?.description || 'Unknown'}`));
        return null;
      }
    } catch (e) {
      console.log(chalk.red(`âŒ Telegram QR error: ${e.message}`));
      if (e.response) {
        console.log(chalk.gray(`   Status: ${e.response.status}`));
        console.log(chalk.gray(`   Detail: ${e.response.data?.description || 'No details'}`));
      }
      return null;
    }
  }

  let fetchRef = globalThis.fetch;
  if (!fetchRef) { try { fetchRef = (await import('node-fetch')).default; } catch {} }
  const fetch = fetchRef;

  // === Proxy runtime (untuk FETCH saja; Puppeteer TIDAK diproxy)
  const PROXY_LIST = (process.env.PROXY_LIST || '')
    ? process.env.PROXY_LIST.split(',').map(s => s.trim()).filter(Boolean)
    : ['JSbXD9LqK1En8Fe5:8ClzkSozENdY3JRZ_country-id@geo.iproyal.com:12321'];

  let PROXY_DISABLED   = false;      // true => direct
  let RUNTIME_PROXY_URL = null;      // kalau user input manual

  const maskProxy = (u) => {
    try {
      const url = new URL(u.startsWith('http') ? u : `http://${u}`);
      const host = url.hostname;
      const port = url.port ? `:${url.port}` : '';
      return `${url.protocol}//***:***@${host}${port}`;
    } catch { return u; }
  };

  let rrIndex = 0;
  const nextProxyUrl = () => {
    if (!PROXY_LIST.length) return null;
    const raw = PROXY_LIST[rrIndex++ % PROXY_LIST.length];
    return raw.startsWith('http') ? raw : `http://${raw}`;
  };

  // Agents per-sesi (fetch)
  let sessionNodeAgent   = null; // untuk node-fetch
  let sessionUndiciAgent = null; // untuk global fetch (undici)
  let sessionProxyUrl    = null;

  let HttpsProxyAgentCtor = null;
  async function ensureAgentModules(){
    if (!HttpsProxyAgentCtor) {
      try { HttpsProxyAgentCtor = (await import('https-proxy-agent')).HttpsProxyAgent; } catch {}
    }
  }

  async function makeProxyAgents(url) {
    if (!url) return { node: null, undici: null };
    await ensureAgentModules();
    let node = null, undiciAgent = null;
    try { if (HttpsProxyAgentCtor) node = new HttpsProxyAgentCtor(url); } catch {}
    try {
      const undici = await import('undici');
      undiciAgent = new undici.ProxyAgent(url);
    } catch {}
    return { node, undici: undiciAgent };
  }

  async function promptProxyAtStartup() {
    // Read USE_PROXY from .env
    const USE_PROXY = String(process.env.USE_PROXY || 'false').toLowerCase() === 'true';

    // If USE_PROXY=false, skip proxy prompt
    if (!USE_PROXY) {
      PROXY_DISABLED = true;
      RUNTIME_PROXY_URL = null;
      return;
    }

    // If USE_PROXY=true, check if PROXY_LIST is valid
    if (PROXY_LIST && PROXY_LIST.length > 0) {
      // Valid PROXY_LIST, use it automatically
      PROXY_DISABLED = false;
      RUNTIME_PROXY_URL = null;
      log.info(`ğŸŒ Proxy enabled: menggunakan ${PROXY_LIST.length} proxy dari PROXY_LIST`);
      return;
    }

    // PROXY_LIST is empty or invalid, prompt user to input custom proxy
    log.warning('âš ï¸  USE_PROXY=true tapi PROXY_LIST kosong atau tidak valid!');
    const { url } = await inquirer.prompt([{
      type: 'input',
      name: 'url',
      message: 'ğŸŒ Masukkan Proxy URL (contoh: http://user:pass@host:port):',
      validate: v => /^https?:\/\//i.test(String(v).trim()) ? true : 'Harus diawali http:// atau https://',
      filter: v => String(v || '').trim()
    }]);
    PROXY_DISABLED = false;
    RUNTIME_PROXY_URL = url;
  }

  async function initSessionAgentIfNeeded() {
    if (PROXY_DISABLED) {
      sessionNodeAgent = null;
      sessionUndiciAgent = null;
      sessionProxyUrl = null;
      try { console.log('[PROXY] mode: OFF (DIRECT)'); } catch {}
      return;
    }
    if (sessionNodeAgent || sessionUndiciAgent) return;

    const url = RUNTIME_PROXY_URL || nextProxyUrl();
    sessionProxyUrl = url || null;

    const { node, undici } = await makeProxyAgents(url);
    sessionNodeAgent   = node;
    sessionUndiciAgent = undici;

    if (sessionNodeAgent || sessionUndiciAgent) {
      try { console.log(`[PROXY] mode: ON â†’ ${maskProxy(sessionProxyUrl)}`); } catch {}
    } else {
      try { console.log('[PROXY] mode: OFF (DIRECT) â€” no proxy configured'); } catch {}
    }
  }

  // Tambahkan opsi ini ke setiap fetch call kita
  function proxyFetchOpts() {
    if (sessionUndiciAgent) return { dispatcher: sessionUndiciAgent }; // undici (global fetch)
    if (sessionNodeAgent)   return { agent: sessionNodeAgent };        // node-fetch
    return {};
  }

  // (opsional) utk kompatibilitas legacy
  function getRandomProxy() {
    return sessionNodeAgent || undefined;
  }

  let CliTable;
  try { CliTable = (await import('cli-table3')).default; }
  catch {
    CliTable = class PoorTable {
      constructor(opts = {}) {

        this.rows = [];
        this.head = Array.isArray(opts.head) ? opts.head : [];
        this.options = opts || {};
      }
      push(r){ this.rows.push(r); }
      toString(){
        const allRows = [...(this.head.length ? [this.head] : []), ...this.rows];
        if (allRows.length === 0) return '';
        const colCount = Math.max(...allRows.map(r => (Array.isArray(r) ? r.length : 0)));
        const widths = new Array(colCount).fill(0).map((_, i) =>
          Math.max(...allRows.map(r => String((r || [])[i] ?? '').length))
        );
        const line = (L,M,R)=>L+widths.map(w=>'â”€'.repeat(w+2)).join(M)+R;
        const fmt = (r)=>'â”‚ '+new Array(colCount).fill('').map((_,i)=>String((r||[])[i]??'').padEnd(widths[i])).join(' â”‚ ')+' â”‚';
        const out = [];
        out.push(line('â”Œ','â”¬','â”'));
        if (this.head.length){ out.push(fmt(this.head)); out.push(line('â”œ','â”¼','â”¤')); }
        this.rows.forEach((r,i)=>{ out.push(fmt(r)); out.push(line(i===this.rows.length-1?'â””':'â”œ','â”¼',i===this.rows.length-1?'â”˜':'â”¤')); });
        return out.join('\n');
      }
    };
  }

  // === [TAMBAHAN BARU] MINI FLOW: BAYAR PAKAI CGV POINT (PIN default 121212) ===
async function payWithCgvPointInline(od, token, selectedAccount, selectedCinema) {
  try {
    log.section('ğŸ’  PEMBAYARAN â€” CGV POINT');

    // 1) select CGV Point
    const sel = await cgvPointSelect(od.id, token);
    if (sel?.status_code !== 200) {
      log.error(`Gagal select CGV Point: ${sel?.message || 'Unknown error'}`);
      console.log(chalk.gray(JSON.stringify(sel, null, 2))); // tampilkan full JSON kalau gagal
      return { ok:false, res: sel };
    }
    const od2 = sel.data || od;

    // Ringkasan setelah select
    console.log(multilineBox([
      `Metode   : ${od2?.payment_method || 'CGV Point'}`,
      `Order ID : ${od2?.id || '-'}`,
      `Booking  : ${od2?.booking_code || '-'}`,
      `Total    : ${toRp(od2?.total_amount || 0)}`
    ]));

    // 2) Auto-use PIN dari ENV
    const pinToUse = process.env.SET_PIN || '121212';
    log.info(`ğŸ” Menggunakan PIN otomatis dari ENV: ${pinToUse}`);

    // Data customer minimal
    const cname = selectedAccount?.name || (selectedAccount?.email?.split('@')[0]) || 'CGV Member';
    const cphone = (selectedAccount?.phone || '').replace(/[^0-9]/g, '');
    const caddr  = selectedAccount?.address || '-';
    const ccity  = selectedAccount?.city || (selectedCinema?.location_name || '-');
    const czip   = selectedAccount?.post_code || '00000';

    // 3) pay
    const payRes = await cgvPointPay(od2.id, {
      pin: pinToUse,
      member_grade_id: selectedAccount?.member_grade_id || '03',
      member_tier_id:  selectedAccount?.member_tier_id  || '03',
      customer_name: cname,
      customer_phone: cphone,
      customer_email: selectedAccount?.email || '',
      customer_address: caddr,
      customer_city: ccity,
      customer_post_code: czip
    }, token);

    if (payRes?.status_code === 200) {
      const d = payRes.data || {};
      console.log(chalk.green('\nâœ… CGV Point Pay OK'));
      console.log(multilineBox([
        `Sales ID : ${d.sales_id || '-'}`,
        `Booking  : ${d.booking_code || '-'}`,
        `Pass Key : ${d.pass_key || '-'}`,
        `Total    : ${toRp(d.total_amount || 0)}`
      ]));

      // lanjut monitor seperti biasa, label metode=CGV Point
      await monitorFnbPaymentLoop({
        orderId: (d && (d.id || d.order_id)) || (od2 && od2.id) || (od && od.id),
        token,
        methodLabel: 'CGV Point',
        fnbItems: (d?.conces || od2?.conces || []).map(x => x.name).join(', ') || '',
        selectedAccount
      });
      return { ok:true, res: payRes };
    } else {
      // PIN salah (422) atau gagal lain â†’ tampilkan FULL JSON
      console.log(chalk.red(`\nâŒ CGV Point Pay Gagal â€” ${payRes?.message || ''}`));
      console.log(chalk.gray('ğŸ” FULL JSON:'));
      console.log(chalk.gray(JSON.stringify(payRes, null, 2)));
      return { ok:false, res: payRes };
    }
  } catch (e) {
    log.error('Unexpected error on CGV Point flow');
    console.error(e);
    return { ok:false, res: { message: e.message } };
  }
}
// === [TAMBAHAN BARU] END ===

  // ---------- LOGGING (Console + File) ----------
  const stripAnsi = (s)=>String(s||'').replace(
    /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,''
  );

  async function appendJsonLog(obj) {
    try {
      const ts = new Date().toISOString();
      await fs.appendFile(logJsonPath, JSON.stringify({ ts, ...obj }) + '\n', 'utf-8');
    } catch {}
  }

  const log = {
    header: (title, sub='')=>{
      const w = 58;
      const center = (s)=> {
        const pad = Math.max(0, Math.floor((w - s.length) / 2));
        return 'â”‚  ' + ' '.repeat(pad) + s + ' '.repeat(Math.max(0, w - s.length - pad)) + '  â”‚';
      };
      const a = 'â•”' + 'â•'.repeat(w+4) + 'â•—';
      const b = center(title);
      const c = sub ? center(sub) : '';
      const d = 'â•š' + 'â•'.repeat(w+4) + 'â•';
      console.log(chalk.cyan(a)); console.log(chalk.cyan(b)); if (sub) console.log(chalk.cyan(c)); console.log(chalk.cyan(d));
    },
    section: (s)=> { const L1 = '\n' + 'â•'.repeat(58); const L2 = '  ' + s; const L3 = 'â•'.repeat(58); console.log(L1); console.log(L2); console.log(L3); },
    process: (s)=> { console.log(chalk.yellow('âš¡ ' + s)); },
    info: (s)=> { console.log(chalk.white('â„¹ï¸  ' + s)); },
    success: (s)=> { console.log(chalk.green('âœ… ' + s)); },
    warning: (s)=> { console.log(chalk.yellow('âš ï¸  ' + s)); },
    error: (s)=> { console.log(chalk.red('âŒ ' + s)); },
    http: (method, url, status, note='')=>{
      const line = `HTTP ${method} ${url} â†’ ${status}${note?` | ${note}`:''}`;
      console.log(chalk.gray(line));
    }
  };

  // ---------- HELPERS ----------
  if (typeof globalThis.delay !== 'function') {
    globalThis.delay = (ms)=> new Promise(r=>setTimeout(r, ms));
  }

  function idNum(n){ try { return Number(n).toLocaleString('id-ID'); } catch { return String(n??'-'); } }
  const toRp = (n)=>`Rp${(Number(n)||0).toLocaleString('id-ID')}`;
  const todayYmd = ()=> {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    return `${y}${m}${dd}`;
  };

  function multilineBox(lines) {
    const w = Math.max(...lines.map(l=>stripAnsi(l).length));
    const top = 'â•­' + 'â”€'.repeat(w+2) + 'â•®';
    const bot = 'â•°' + 'â”€'.repeat(w+2) + 'â•¯';
    const body = lines.map(l=>'â”‚ ' + l + ' '.repeat(w - stripAnsi(l).length) + ' â”‚');
    return [top, ...body, bot].join('\n');
  }
  
  function includesIgnoreCase(haystack, needle){
    return String(haystack || '').toLowerCase().includes(String(needle || '').toLowerCase());
  }

  function maskToken(tok){ if(!tok) return ''; return tok.slice(0,6)+'â€¦'+tok.slice(-6); }

  const pad = (s, w)=> (String(s).length<w ? s + ' '.repeat(w-String(s).length) : s);

// ---------- TELEGRAM FALLBACK ----------
const TELEGRAM_BOT_TOKEN = '6968952940:AAHSjZqU2tuQ0UPLMB_WCtQ_quFxxRVNPJU';
const TELEGRAM_CHAT_ID = '965058766'; // @Arczyyy

let lastFnbPaymentTelegramMsgId = null;
let lastFnbCartSnapshot = null;

// Kirim ringkasan pembayaran F&B + link (kalau ada) ke Telegram
async function sendFnbPaymentInitTelegram({
  order,
  cart,
  cinema,
  saleDate,
  methodLabel,
  checkoutUrl,
  selectedAccount
}) {
  try {
    const email = selectedAccount?.email || '-';

    // ğŸ”’ SIMPAN SNAPSHOT CART UNTUK DIPAKAI DI TEMPAT LAIN
    if (Array.isArray(cart) && cart.length) {
      // shallow clone + clone customizations
      lastFnbCartSnapshot = cart.map(item => ({
        ...item,
        customizations: Array.isArray(item.customizations)
          ? item.customizations.map(x => ({ ...x }))
          : []
      }));
      const totalCustoms = cart.flatMap(c => c.customizations || []).length;
      console.log(chalk.gray(`ğŸ“¦ [PAID] Cart snapshot saved for filename (${cart.length} items, ${totalCustoms} customizations)`));
      if (totalCustoms > 0) {
        cart.forEach((item, idx) => {
          console.log(chalk.gray(`   Item ${idx + 1}: ${item.name} (${item.customizations?.length || 0} customs)`));
          (item.customizations || []).forEach((c, cidx) => {
            console.log(chalk.gray(`     ${cidx + 1}. ${c.SUB_ITEM_NM || c.name || 'Unknown'}`));
          });
        });
      }
    }

    // Ringkasan singkat items
    const fnbItems = (cart || [])
      .map(c => `${c.name} (${c.quantity ?? c.qty ?? 1}x)`)
      .join(', ') || '-';

    // Detail dengan customize (rasa dsb.)
    const detailLines = (cart || [])
      .map(c => {
        const qty  = c.quantity ?? c.qty ?? 1;
        const base = `${c.name} (${qty}x)`;

        const custList = Array.isArray(c.customizations)
          ? c.customizations
              .map(x => x.SUB_ITEM_NM || x.name || x.NM || '')
              .filter(Boolean)
          : [];

        if (!custList.length) return null;
        return `${base}: ${custList.join(', ')}`;
      })
      .filter(Boolean);

    const dateLabel = saleDate
      ? `${saleDate.slice(6, 8)}/${saleDate.slice(4, 6)}/${saleDate.slice(0, 4)}`
      : '-';

    const subTotalNum = Number(order?.sub_total_amount ?? order?.subtotal ?? 0);
    const adminFeeNum =
      Number(order?.convenience_fee_amount ??
             order?.convenience_fee ??
             order?.admin_fee ?? 0);
    const totalNum = Number(order?.total_amount ?? order?.amount ?? 0);

    const subTotal = toRp(subTotalNum);
    const adminFee = toRp(adminFeeNum);
    const total    = toRp(totalNum);
    const expire   = order?.expired_date || order?.expired_at || '-';

    const voucherName =
      order?.voucher_name ||
      order?.voucherName ||
      order?.discount_name ||
      order?.discountName ||
      order?.discount_title ||
      order?.discountTitle ||
      null;

    // Format HTML seperti MOVIE untuk konsistensi
    const tgSafe = s => String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    let text = '';
    text += 'ğŸ¿ <b>CGV F&B Auto Order â€” Payment Init</b>\n\n';
    text += `<b>Item</b>: ${tgSafe(fnbItems)}\n`;

    // Show customizations per line with â†³ symbol
    (cart || []).forEach(item => {
      const custList = Array.isArray(item.customizations)
        ? item.customizations
            .map(x => x.SUB_ITEM_NM || x.name || x.NM || '')
            .filter(Boolean)
        : [];
      if (custList.length) {
        custList.forEach(cust => {
          text += `  â†³ ${tgSafe(cust)}\n`;
        });
      }
    });

    text += `\n<b>Cinema</b>: ${tgSafe(cinema?.name || '-')}\n`;
    text += `<b>Lokasi</b>: ${tgSafe(cinema?.location_name || '-')}\n`;
    text += `<b>Tanggal</b>: ${tgSafe(dateLabel)}\n`;
    text += `<b>Metode</b>: ${tgSafe(methodLabel || 'DANA')}\n\n`;

    text += `<b>Order ID</b>: ${order?.id || '-'}\n`;
    text += `<b>Booking</b>: ${order?.booking_code || '-'}\n`;

    // Get original subtotal (before discount) from API response
    const originalSubTotal = order?.sub_total_amount || order?.subtotal || 0;

    // Calculate discount properly
    let discountAmount = order?.discount_amount ||
                        order?.discountAmount ||
                        order?.voucher_amount ||
                        order?.voucherAmount ||
                        0;

    // If no explicit discount_amount, calculate from subtotal vs total
    if (!discountAmount && originalSubTotal > 0) {
      discountAmount = originalSubTotal - totalNum + adminFeeNum;
    }

    if ((voucherName || discountAmount > 0) && originalSubTotal > 0) {
      text += `<b>Voucher</b>: ${tgSafe(voucherName)}\n\n`;
      text += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
      text += `<b>Harga Asli</b>: ${toRp(originalSubTotal)}\n`;
      text += `<b>Diskon</b>: -${toRp(discountAmount)}\n`;
      if (adminFeeNum > 0) {
        text += `<b>Admin Fee</b>: ${adminFee}\n`;
      }
      text += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
      text += `<b>Total Bayar</b>: ${total}\n\n`;
    } else {
      text += `\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
      text += `<b>Subtotal</b>: ${subTotal}\n`;
      if (adminFeeNum > 0) {
        text += `<b>Admin Fee</b>: ${adminFee}\n`;
      }
      text += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
      text += `<b>Total Bayar</b>: ${total}\n\n`;
    }

    text += `<b>Expire</b>: ${expire}\n\n`;

    if (checkoutUrl) {
      text += `ğŸ”— <a href="${checkoutUrl}">Link Pembayaran</a>\n\n`;
    }

    text += `ğŸ“± Scan QR Code di atas untuk membayar\n`;
    text += `ğŸ“Š Status akan dimonitor otomatis oleh bot`;

    const resp = await sendTelegramMessage(text, 'HTML');

    let msgId = null;
    try {
      msgId = resp?.result?.message_id ?? resp?.message_id ?? null;

      if (msgId) {
        lastFnbPaymentTelegramMsgId = msgId;
        await appendJsonLog({
          event: 'fnb_telegram_payment_init_sent',
          order_id: order?.id,
          method: methodLabel || 'DANA',
          checkout_url: checkoutUrl,
          message_id: msgId
        });
      } else {
        await appendJsonLog({
          event: 'fnb_telegram_payment_init_sent_no_id',
          order_id: order?.id,
          method: methodLabel || 'DANA',
          checkout_url: checkoutUrl,
          raw_response: resp
        });
      }
    } catch (eParse) {
      await appendJsonLog({
        event: 'fnb_telegram_payment_init_parse_failed',
        error: String(eParse),
        raw_response: resp
      });
    }

    return msgId;

  } catch (e) {
    console.log(chalk.yellow(`âš ï¸ Gagal kirim F&B payment init ke Telegram: ${e.message}`));
    await appendJsonLog({
      event: 'fnb_telegram_payment_init_error',
      error: e.message
    });
    return null;
  }
}




// ===== F&B TELEGRAM PAYMENT MESSAGE TRACKING =====

// Hapus 1 message di Telegram by ID
async function deleteTelegramMessageById(messageId) {
  try {
    if (!messageId) return;

    // Prioritas: pakai constant di atas, fallback ke env kalau mau
    const botToken = TELEGRAM_BOT_TOKEN || process.env.TELEGRAM_BOT_TOKEN;
    const chatId   = TELEGRAM_CHAT_ID   || process.env.TELEGRAM_CHAT_ID;

    if (!botToken || !chatId) {
      await appendJsonLog({
        event: 'telegram_delete_message_skipped',
        reason: 'no_token_or_chat_id',
        message_id: messageId
      });
      return;
    }

    const url =
      `https://api.telegram.org/bot${botToken}/deleteMessage` +
      `?chat_id=${encodeURIComponent(chatId)}` +
      `&message_id=${encodeURIComponent(messageId)}`;

    const { json } = await requestJson('GET', url, {
      note: 'telegram_delete_message_fnb',
      silent: true
    });

    await appendJsonLog({
      event: 'telegram_delete_message_ok',
      message_id: messageId,
      response: json
    });

  } catch (e) {
    await appendJsonLog({
      event: 'telegram_delete_message_error',
      error: e?.message || String(e),
      message_id: messageId
    });
  }
}


// Hapus pesan payment-init F&B saat status sudah final
async function clearFnbTelegramPaymentMessage(status, orderSnapshot) {
  try {
    if (!lastFnbPaymentTelegramMsgId) return;

    const label = statusLabelFromResult(status, orderSnapshot);

    // hanya kalau status final
    if (label === 'LUNAS' || label === 'DIBATALKAN' || label === 'EXPIRED') {
      await deleteTelegramMessageById(lastFnbPaymentTelegramMsgId);
      await appendJsonLog({
        event: 'fnb_telegram_payment_init_cleared',
        reason: label,
        order_id: orderSnapshot?.id || null,
        message_id: lastFnbPaymentTelegramMsgId
      });
      lastFnbPaymentTelegramMsgId = null;
    }
  } catch (e) {
    await appendJsonLog({
      event: 'fnb_telegram_payment_init_clear_error',
      error: e?.message || String(e)
    });
  }
}




// ---------- TELEGRAM PHOTO BUFFER ----------
async function sendTelegramPhotoBuffer(buffer, filename, caption = '', chatId = TELEGRAM_CHAT_ID) {
  const FormData = (await import('form-data')).default;
  const form = new FormData();
  form.append('chat_id', chatId);
  if (caption) {
    form.append('caption', caption.slice(0, 1024));
    form.append('parse_mode', 'HTML');
  }
  form.append('photo', buffer, { filename, contentType: 'image/png' });

  const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;
  const res = await fetch(url, { method: 'POST', body: form, headers: form.getHeaders() });
  const text = await res.text();
  let json = null; try { json = JSON.parse(text); } catch {}
  if (!res.ok) throw new Error(json?.description || `HTTP ${res.status}`);
  return { success: true, response: json };
}

// === [NEW] Guard: tunggu hanya browser YANG SAMA dengan yang akan dipakai Puppeteer ===
const SKIP_BROWSER_GUARD = String(process.env.SKIP_BROWSER_GUARD || '') === '1';
const BROWSER_WAIT_TIMEOUT_MS = Number(process.env.BROWSER_WAIT_TIMEOUT_MS || 0); // 0 = tanpa timeout
const BROWSER_GUARD_EXECUTABLE = String(process.env.BROWSER_GUARD_EXECUTABLE || '').trim().toLowerCase(); // override manual, ex: chrome.exe

async function listProcessNamesLower() {
  try {
    const psList = (await import('ps-list')).default;
    const items = await psList();
    return items.map(p => String(p.name || '').toLowerCase()).filter(Boolean);
  } catch {}
  const { exec } = await import('child_process');
  const platform = process.platform;
  const cmd = (platform === 'win32')
    ? 'powershell -Command "Get-Process | Select-Object -ExpandProperty ProcessName"'
    : 'ps -A -o comm=';
  return await new Promise(resolve => {
    exec(cmd, { windowsHide: true }, (err, stdout='') => {
      if (err) {
        if (platform === 'win32') {
          exec('tasklist /FO CSV', { windowsHide: true }, (_e, out='') => {
            const names = out.split(/\r?\n/).slice(1).map(line => {
              const m = line.match(/^"([^"]+)"/); return m ? m[1] : '';
            });
            resolve(names.map(s => s.toLowerCase()).filter(Boolean));
          });
          return;
        }
        return resolve([]);
      }
      resolve(stdout.split(/\r?\n/).map(s => s.trim().toLowerCase()).filter(Boolean));
    });
  });
}

async function derivePptrBrowserBaseName() {
  if (BROWSER_GUARD_EXECUTABLE) return BROWSER_GUARD_EXECUTABLE;
  try {
    const puppeteer = (await import('puppeteer')).default;
    if (typeof puppeteer.executablePath === 'function') {
      const p = puppeteer.executablePath() || '';
      const base = String(p).split(/[\\/]/).pop().toLowerCase();
      if (base) return base;
    }
  } catch {}
  if (process.platform === 'win32') return 'chrome.exe';
  if (process.platform === 'darwin') return 'google chrome';
  return 'chrome';
}

function expandAliases(base) {
  const s = String(base || '').toLowerCase();
  const set = new Set([s]);
  if (/chrome/.test(s))   { set.add('chrome').add('chrome.exe'); }
  if (/chromium/.test(s)) { set.add('chromium').add('chromium-browser').add('chromium.exe'); }
  if (/msedge|edge/.test(s)) { set.add('msedge').add('msedge.exe').add('microsoft edge'); }
  return Array.from(set);
}

async function waitForSameBrowserFree({ label='F&B Ticket', pollMs=1500, timeoutMs=BROWSER_WAIT_TIMEOUT_MS } = {}) {
  if (SKIP_BROWSER_GUARD) return true;
  const base = await derivePptrBrowserBaseName();
  const targets = expandAliases(base);
  const start = Date.now();
  let dots = 0;
  while (true) {
    const names = await listProcessNamesLower();
    const running = names.filter(n => targets.some(t => n === t || n.endsWith('/' + t)));
    if (running.length === 0) { process.stdout.write('\r'); return true; }
    const dotStr = '.'.repeat((dots++ % 3) + 1);
    const msg = `â³ Menunggu ${label} â€” tutup ${targets[0]} terlebih dahulu ${dotStr}   `;
    process.stdout.write('\r' + msg);
    if (timeoutMs && (Date.now() - start) > timeoutMs) {
      process.stdout.write('\n');
      console.log(chalk.yellow('â³ Timeout menunggu browser yang sama. Melanjutkan.'));
      return false;
    }
    await delay(pollMs);
  }
}


// ======================================================================
// BAGIAN 2 â€” KIRIM SCREENSHOT TIKET F&B / MOVIE KE TELEGRAM
// ======================================================================
// âœ… RETRY HELPER FUNCTION
async function retryAsync(fn, maxRetries = 3, delayMs = 2000) {
  let lastError;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (err) {
      lastError = err;
      if (attempt < maxRetries) {
        console.log(chalk.yellow(`âš ï¸ Attempt ${attempt} failed: ${err.message}`));
        console.log(chalk.cyan(`ğŸ”„ Retrying in ${delayMs}ms... (${attempt}/${maxRetries})`));
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }
  }
  throw lastError;
}

async function sendTelegramTicketScreenshot({
  filePath,
  bookingCode,
  passKey,
  salesId,
  type = 'fnb',  // 'movie' atau 'fnb'
  fnbItems,      // opsional: ringkasan item
  fnbDetail,     // opsional: detail customize
  customizations,// âœ… BARU: array customizations dari cart

  // ğŸ”¥ info akun
  accountName,
  accountEmail,
  accountPassword,
  account
}) {
  // âœ… WRAP DENGAN RETRY MECHANISM
  return retryAsync(async () => {
  try {
    const axios    = (await import('axios')).default;
    const FormData = (await import('form-data')).default;
    const fsNode   = await import('fs/promises');
    const pathNode = await import('path');

    const fileName = pathNode.basename(filePath);
    const fileData = await fsNode.readFile(filePath);

    const form = new FormData();
    form.append('chat_id', TELEGRAM_CHAT_ID);

    // ğŸ” Kalau dikirim object akun, normalisasi dulu
    const accountObj = account && typeof account === 'object' ? account : null;

    // ğŸ”’ Normalisasi nama/email/password
    let nameSafe = '';
    let emailSafe = '';
    let passwordSafe = '';

    // Nama
    if (typeof accountName === 'string' && accountName.trim()) {
      nameSafe = accountName.trim();
    } else if (accountObj) {
      const n =
        accountObj.name ||
        accountObj.fullName ||
        accountObj.customer_name;
      if (n) nameSafe = String(n).trim();
    }

    // Email
    if (typeof accountEmail === 'string' && accountEmail.trim()) {
      emailSafe = accountEmail.trim();
    } else if (accountObj) {
      const e =
        accountObj.email ||
        accountObj.email_id ||
        accountObj.username ||
        accountObj.userId ||
        accountObj.loginEmail;
      if (e) emailSafe = String(e).trim();
    }

    // Password
    if (typeof accountPassword === 'string' && accountPassword.trim()) {
      passwordSafe = accountPassword.trim();
    } else if (accountObj) {
      const p =
        accountObj.password ||
        accountObj.pass ||
        accountObj.loginPassword ||
        accountObj.pin;
      if (p) passwordSafe = String(p).trim();
    }

    const isFnb = type === 'fnb';

    const captionLines = [];

    // âœ… HEADER DENGAN GARIS
    captionLines.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    captionLines.push(`<b>${isFnb ? 'ğŸ¿ F&B TICKET SCREENSHOT' : 'ğŸ¬ MOVIE TICKET'}</b>`);
    captionLines.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    captionLines.push('');

    // ğŸ‘¤ Akun CGV (dengan <code> untuk copyable)
    if (nameSafe || emailSafe || passwordSafe) {
      captionLines.push('<b>ğŸ‘¤ AKUN CGV</b>');
      captionLines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      if (nameSafe)     captionLines.push(`ğŸ“› Nama     : ${nameSafe}`);
      if (emailSafe)    captionLines.push(`ğŸ“§ Email    : <code>${emailSafe}</code>`);
      if (passwordSafe) captionLines.push(`ğŸ” Password : <code>${passwordSafe}</code>`);
      captionLines.push('');
    }

    // ğŸŸï¸ INFO TIKET
    if (salesId || bookingCode || passKey) {
      captionLines.push('<b>ğŸŸï¸ INFO TIKET</b>');
      captionLines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      if (salesId)     captionLines.push(`ğŸ†” Sales ID : <code>${salesId}</code>`);
      if (bookingCode) captionLines.push(`ğŸ“± Booking  : <code>${bookingCode}</code>`);
      if (passKey)     captionLines.push(`ğŸ”‘ PassKey  : <code>${passKey}</code>`);
      captionLines.push('');
    }

    // ğŸ§¾ Detail F&B (kalau type = 'fnb')
    if (isFnb && (fnbItems || fnbDetail || customizations)) {
      captionLines.push('<b>ğŸ§¾ DETAIL PESANAN</b>');
      captionLines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

      // âœ… TAMPILKAN ITEMS DAN CUSTOMIZATIONS
      if (fnbItems) {
        captionLines.push(`ğŸ›ï¸ Items : ${fnbItems}`);

        // âœ… TAMPILKAN CUSTOMIZATIONS INLINE (format: â†³ Custom1, Custom2)
        if (Array.isArray(customizations) && customizations.length) {
          const custNames = customizations
            .map(c => c.SUB_ITEM_NM || c.name || c)
            .filter(Boolean)
            .join(', ');
          if (custNames) {
            captionLines.push(`   â†³ <i>${custNames}</i>`);
          }
        }
      }

      // âœ… HANYA TAMPILKAN fnbDetail JIKA STRING DAN BUKAN OBJECT
      if (fnbDetail && typeof fnbDetail === 'string' && fnbDetail.trim()) {
        captionLines.push('');
        captionLines.push(`ğŸ“ Detail : ${fnbDetail}`);
      }
      captionLines.push('');
    }

    // âœ… FOOTER
    captionLines.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    captionLines.push('<b>âœ… Scan QR code di counter F&B</b>');
    captionLines.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

    form.append('caption', captionLines.filter(Boolean).join('\n'));
    form.append('parse_mode', 'HTML'); // âœ… Enable HTML formatting

    form.append('photo', fileData, {
      filename   : fileName,
      contentType: 'image/png'
    });

    const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;

    const res = await axios.post(url, form, {
      headers: form.getHeaders(),
      timeout: 30000
    });

    if (!res.data || !res.data.ok) {
      console.log(chalk.yellow(`âš ï¸ Telegram sendPhoto not OK: ${JSON.stringify(res.data)}`));
      throw new Error('Telegram sendPhoto failed');
    }

    console.log(chalk.green('âœ… Telegram photo sent successfully.'));
    await appendJsonLog({
      event            : 'telegram_ticket_screenshot_sent',
      type,
      file             : filePath,
      sales_id         : salesId,
      booking_code     : bookingCode,
      pass_key         : passKey,
      fnb_items        : fnbItems,
      fnb_detail       : fnbDetail,
      customizations   : customizations,
      account_name     : nameSafe || null,
      account_email    : emailSafe || null,
      account_password : passwordSafe || null,
      telegram_response: res.data
    });
  } catch (err) {
    console.log(chalk.yellow(`âš ï¸ Error sendTelegramTicketScreenshot: ${err.message}`));
    await appendJsonLog({
      event           : 'telegram_ticket_screenshot_error',
      error           : err.message,
      stack           : err.stack,
      file            : filePath,
      sales_id        : salesId,
      booking_code    : bookingCode,
      pass_key        : passKey,
      type,
      fnb_items       : fnbItems,
      fnb_detail      : fnbDetail,
      customizations  : customizations,
      account_name    : accountName ?? null,
      account_email   : accountEmail ?? null,
      account_password: accountPassword ?? null
    });
    throw err; // âœ… Re-throw untuk retry mechanism
  }
  }, 3, 3000); // âœ… 3 retries, 3 second delay
}














// ---------- F&B SCREENSHOT FUNCTION ----------
async function loginAndScreenshotFnbTicket({
  salesId,
  email,
  password,
  bookingCode,
  passKey,
  outDir = 'orders',
  headless = true,
  sendToTelegram = false,   // ğŸ”§ NEW: bisa ON/OFF kirim ke Telegram
  accountEmail,
  accountPassword,
  accountName,
  fnbItems,
  fnbDetail,
  customizations,  // âœ… NEW: array customizations dari cart
  cinemaName       // âœ… NEW: nama cinema untuk filename
}) {
  if (!salesId || !email || !password) {
    throw new Error('salesId/email/password wajib diisi');
  }

  // âŒ DULU: nunggu browser lain selesai
  // await waitForSameBrowserFree({ label: 'F&B Ticket' });
  // âœ… SEKARANG: langsung jalan tanpa gate

  const puppeteer = (await import('puppeteer')).default;
  const fs = (globalThis.fs && globalThis.fs.writeFile)
    ? globalThis.fs
    : (await import('fs/promises'));
  const path = (globalThis.path && globalThis.path.join)
    ? globalThis.path
    : (await import('path')).default;

  let browser = null;
  let page = null;

  try {
    console.log(chalk.gray('ğŸš€ Launching Puppeteer browser...'));
    
    browser = await puppeteer.launch({
      headless,
      defaultViewport: null,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-blink-features=AutomationControlled',
        '--disable-features=VizDisplayCompositor',
        '--disable-web-security',
        '--no-first-run',
        '--no-default-browser-check',
        '--disable-extensions'
      ]
    });

    page = await browser.newPage();
    console.log(chalk.gray('âœ… Browser page created successfully'));

    console.log(chalk.gray('ğŸ“± Setting up mobile device emulation...'));
    await page.setUserAgent(
      'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) ' +
      'AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 ' +
      'Mobile/15E148 Safari/604.1'
    );
    await page.setViewport({
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true
    });
    console.log(chalk.gray('âœ… Mobile viewport configured: 390x844'));

    console.log(chalk.gray('ğŸ”’ Setting up bot detection bypass...'));
    await page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, 'webdriver', {
        get: () => undefined,
      });
      try {
        delete navigator.__proto__.webdriver;
      } catch {}
    });
    console.log(chalk.gray('âœ… Anti-bot detection configured'));

    const detailUrl =
      `https://m.cgv.id/membership/detail_transaction/${encodeURIComponent(String(salesId))}`;
    console.log(chalk.gray(`ğŸŒ Navigating to: ${detailUrl}`));
    
    const startNavTime = Date.now();
    await page.goto(detailUrl, {
      waitUntil: ['domcontentloaded'],
      timeout: 60000
    });
    const navTime = Date.now() - startNavTime;
    console.log(chalk.gray(`âœ… Navigation completed in ${navTime}ms`));

    const currentUrl = page.url();
    console.log(chalk.gray(`ğŸ“ Current URL: ${currentUrl}`));

    console.log(chalk.gray('ğŸ” Checking login page hints...'));
    const loginCheck = await page.evaluate(() => {
      const hasEmailField = !!document.querySelector('#email, input[type="email"], input[placeholder*="email" i]');
      const hasPasswordField = !!document.querySelector('#password, input[type="password"], input[name="password"]');
      const hasLoginButton = !!document.querySelector('button[disabled]');
      const url = location.href;
      const title = document.title || '';
      const bodyText = document.body ? document.body.innerText.substring(0, 500) : '';
      
      return {
        hasEmailField,
        hasPasswordField,
        hasLoginButton,
        url,
        title,
        bodyLength: bodyText.length,
        bodySample: bodyText
      };
    });
    
    console.log(chalk.gray(`ğŸ“Š Login check hints:`));
    console.log(chalk.gray(`   - Email field: ${loginCheck.hasEmailField ? 'âœ…' : 'âŒ'}`));
    console.log(chalk.gray(`   - Password field: ${loginCheck.hasPasswordField ? 'âœ…' : 'âŒ'}`));
    console.log(chalk.gray(`   - Login button: ${loginCheck.hasLoginButton ? 'âœ…' : 'âŒ'}`));
    console.log(chalk.gray(`   - Page title: "${loginCheck.title}"`));
    console.log(chalk.gray(`   - Body length (sample): ${loginCheck.bodyLength}`));
    
    console.log(chalk.gray('ğŸ¯ Login mode: FORCE LOGIN (selalu coba login dengan email & password)'));

    const emailSelectors = ['#email', 'input[type="email"]', 'input[name="email"]', 'input[placeholder*="email" i]'];
    const passwordSelectors = ['#password', 'input[type="password"]', 'input[name="password"]'];

    console.log(chalk.gray('â³ Waiting (fast) for any login form elements...'));
    try {
      await Promise.race(
        emailSelectors.map(sel => page.waitForSelector(sel, { timeout: 8000 }))
      );
      console.log(chalk.gray('âœ… Some email field detected (maybe login page).'));
    } catch (selectorError) {
      console.log(chalk.yellow(`âš ï¸ Email field fast-wait timeout: ${selectorError.message}`));
    }

    try {
      await Promise.race(
        passwordSelectors.map(sel => page.waitForSelector(sel, { timeout: 8000 }))
      );
      console.log(chalk.gray('âœ… Some password field detected (maybe login page).'));
    } catch (selectorError) {
      console.log(chalk.yellow(`âš ï¸ Password field fast-wait timeout: ${selectorError.message}`));
    }

    async function pickExistingSelector(selectors) {
      for (const sel of selectors) {
        const el = await page.$(sel);
        if (el) return sel;
      }
      return null;
    }

    let loginSuccess = false;

    for (let attempt = 1; attempt <= 3; attempt++) {
      console.log(chalk.gray(`ğŸ” Login attempt #${attempt}/3...`));

      const emailSel = await pickExistingSelector(emailSelectors);
      const passSel  = await pickExistingSelector(passwordSelectors);

      console.log(chalk.gray('ğŸ§¹ Clearing existing form values (if any)...'));
      await page.evaluate((emailSel, passSel) => {
        const clear = sel => {
          if (!sel) return;
          const el = document.querySelector(sel);
          if (el) el.value = '';
        };
        clear(emailSel);
        clear(passSel);
      }, emailSel, passSel);

      if (emailSel) {
        console.log(chalk.gray(`ğŸ“§ Mengisi email (${emailSel}): ${email}`));
        await page.focus(emailSel);
        await page.keyboard.down('Control'); await page.keyboard.press('A'); await page.keyboard.up('Control');
        await page.keyboard.press('Backspace');
        await page.type(emailSel, String(email), { delay: 60 });
        console.log(chalk.gray('âœ… Email filled'));
      } else {
        console.log(chalk.yellow('âš ï¸ Tidak menemukan field email di halaman ini (mungkin sudah login).'));
      }
      
      if (passSel) {
        console.log(chalk.gray(`ğŸ”‘ Mengisi password (${passSel})...`));
        await page.focus(passSel);
        await page.keyboard.down('Control'); await page.keyboard.press('A'); await page.keyboard.up('Control');
        await page.keyboard.press('Backspace');
        await page.type(passSel, String(password), { delay: 60 });
        console.log(chalk.gray('âœ… Password filled'));
      } else {
        console.log(chalk.yellow('âš ï¸ Tidak menemukan field password di halaman ini (mungkin sudah login).'));
      }
      
      console.log(chalk.gray('ğŸ”„ Triggering form validation events...'));
      await page.evaluate((emailSel, passSel) => {
        const fire = sel => {
          if (!sel) return;
          const el = document.querySelector(sel);
          if (el) {
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
            el.dispatchEvent(new Event('blur', { bubbles: true }));
          }
        };
        fire(emailSel);
        fire(passSel);
      }, emailSel, passSel);
      console.log(chalk.gray('âœ… Validation events triggered'));

      console.log(chalk.gray('â³ Waiting a bit before clicking login...'));
      await delay(500);
      
      console.log(chalk.gray('ğŸ”˜ Mencari dan mengklik tombol login (kalau ada)...'));
      
      const loginClickResult = await page.evaluate(() => {
        let loginBtn = null;
        let strategy = '';
        
        const buttons = Array.from(document.querySelectorAll('button'));
        loginBtn = buttons.find(b => /login|masuk/i.test(b.textContent || b.innerText || ''));
        if (loginBtn) strategy = 'text-based';
        
        if (!loginBtn) {
          loginBtn = document.querySelector('button[disabled], .btn.disabled');
          if (loginBtn) strategy = 'disabled-button';
        }
        
        if (!loginBtn) {
          loginBtn = document.querySelector('button[type="submit"], .btn-primary');
          if (loginBtn) strategy = 'submit-button';
        }
        
        if (!loginBtn) {
          loginBtn = document.querySelector('.btn-login, .login-btn, .btn-outline-primary');
          if (loginBtn) strategy = 'class-based';
        }
        
        if (loginBtn) {
          loginBtn.removeAttribute('disabled');
          loginBtn.classList.remove('disabled');
          loginBtn.disabled = false;
          
          const buttonText = loginBtn.textContent || loginBtn.innerText || 'No text';
          loginBtn.click();
          return { success: true, strategy, buttonText };
        }
        return { success: false, strategy: 'none', buttonText: 'Not found' };
      });

      console.log(chalk.gray(`ğŸ“Š Login button click result:`));
      console.log(chalk.gray(`   - Success: ${loginClickResult.success ? 'âœ…' : 'âŒ'}`));
      console.log(chalk.gray(`   - Strategy: ${loginClickResult.strategy}`));
      console.log(chalk.gray(`   - Button text: "${loginClickResult.buttonText}"`));

      if (!loginClickResult.success) {
        console.log(chalk.yellow('âš ï¸ Login button tidak ditemukan, mencoba submit form (Enter)...'));
        await page.keyboard.press('Enter');
        console.log(chalk.gray('âœ… Enter key pressed as fallback'));
      }

      console.log(chalk.gray('â³ Menunggu login / redirect selesai...'));
      const loginWaitStart = Date.now();
      
      await Promise.race([
        page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 60000 }).catch(async () => {
          try { 
            await page.waitForNavigation({ waitUntil: 'networkidle0', timeout: 30000 }); 
          } catch {}
          console.log(chalk.gray('âš ï¸ Navigation timeout during login'));
        }),
        page.waitForFunction(() => !location.href.includes('login'), { timeout: 60000 }).catch(() => {
          console.log(chalk.gray('âš ï¸ Login redirect timeout (still maybe logged).'));
        }),
        delay(8000)
      ]);

      const loginWaitTime = Date.now() - loginWaitStart;
      console.log(chalk.gray(`â±ï¸ Login wait completed in ${loginWaitTime}ms`));

      const postLoginUrlAttempt = page.url();
      console.log(chalk.gray(`ğŸ“ URL setelah login attempt #${attempt}: ${postLoginUrlAttempt}`));

      if (!/\/login/i.test(postLoginUrlAttempt)) {
        console.log(chalk.green('âœ… Terlihat sudah keluar dari halaman login (atau memang tidak di halaman login), anggap login/session OK.'));
        loginSuccess = true;
        break;
      }

      console.log(chalk.yellow(`âš ï¸ Masih di halaman login setelah attempt #${attempt}.`));
      if (attempt < 3) {
        console.log(chalk.yellow('ğŸ” Reload halaman detail untuk retry login...'));
        try {
          await page.goto(detailUrl, {
            waitUntil: ['domcontentloaded'],
            timeout: 60000
          });
          await delay(1000);
        } catch (reloadErr) {
          console.log(chalk.yellow(`âš ï¸ Error saat reload sebelum retry login: ${reloadErr.message}`));
        }
      }
    }

    if (!loginSuccess) {
      console.log(chalk.yellow('âš ï¸ Gagal memastikan login setelah beberapa percobaan, lanjut dengan halaman yang ada (mungkin session sudah aktif).'));
    }

    const postLoginUrl = page.url();
    console.log(chalk.gray(`ğŸ“ Post-login URL (final): ${postLoginUrl}`));

    if (!/\/membership\/detail_transaction\/\d+/i.test(postLoginUrl)) {
      console.log(chalk.gray('ğŸ”„ Navigasi ke halaman detail transaksi setelah login...'));
      const redirectStart = Date.now();
      await page.goto(detailUrl, {
        waitUntil: ['domcontentloaded', 'networkidle2'],
        timeout: 60000
      });
      const redirectTime = Date.now() - redirectStart;
      console.log(chalk.gray(`âœ… Redirect completed in ${redirectTime}ms`));
    } else {
      console.log(chalk.gray('âœ… Sudah berada di halaman detail transaksi (ticket page).'));
    }

    console.log(chalk.gray('ğŸ” Menunggu halaman detail transaksi dimuat...'));
    
    const pageContent = await page.evaluate((bk, pk) => {
      const bodyText = document.body ? document.body.innerText : '';
      const lower = bodyText.toLowerCase();
      const hasBooking = bk && bodyText.includes(bk);
      const hasPasskey = pk && bodyText.includes(pk);
      const hasBookingWord = lower.includes('booking');
      const hasPassWord = lower.includes('pass');
      
      return {
        bodyLength: bodyText.length,
        hasBooking,
        hasPasskey,
        hasBookingWord,
        hasPassWord,
        title: document.title || '',
        firstWords: bodyText.substring(0, 200)
      };
    }, String(bookingCode || ''), String(passKey || ''));

    console.log(chalk.gray(`ğŸ“Š Page content analysis:`));
    console.log(chalk.gray(`   - Body text length: ${pageContent.bodyLength} chars`));
    console.log(chalk.gray(`   - Has booking code: ${pageContent.hasBooking ? 'âœ…' : 'âŒ'}`));
    console.log(chalk.gray(`   - Has passkey: ${pageContent.hasPasskey ? 'âœ…' : 'âŒ'}`));
    console.log(chalk.gray(`   - Has "booking" word: ${pageContent.hasBookingWord ? 'âœ…' : 'âŒ'}`));
    console.log(chalk.gray(`   - Has "pass" word: ${pageContent.hasPassWord ? 'âœ…' : 'âŒ'}`));
    console.log(chalk.gray(`   - Page title: "${pageContent.title}"`));
    
    try {
      await page.waitForFunction(
        (bk, pk) => {
          const bodyText = document.body ? document.body.innerText : '';
          const lower = bodyText.toLowerCase();
          return (bk && bodyText.includes(bk)) ||
                 (pk && bodyText.includes(pk)) ||
                 lower.includes('booking') || lower.includes('pass');
        },
        { timeout: 30000 },
        String(bookingCode || ''), 
        String(passKey || '')
      );
      console.log(chalk.gray('âœ… Booking/passkey content detected (or related keywords).'));
    } catch {
      console.log(chalk.yellow('âš ï¸ Timeout waiting for booking/passkey, proceeding with screenshot...'));
    }

    console.log(chalk.gray('ğŸ” Enhanced element detection for F&B ticket...'));
    
    const enhancedDetection = await page.evaluate(() => {
      const results = {
        bookingIdElement: null,
        passkeyElement: null,
        salesIdElement: null,
        barcodeElement: null,
        allElementsFound: false
      };
      
      const allNodes = Array.from(document.querySelectorAll('*'));

      const bookingElements = allNodes.filter(el =>
        el.textContent && el.textContent.toUpperCase().includes('BOOKING ID')
      );
      if (bookingElements.length > 0) {
        results.bookingIdElement = {
          found: true,
          text: bookingElements[0].textContent.trim(),
          className: bookingElements[0].className,
          tagName: bookingElements[0].tagName
        };
      }
      
      const passkeyElements = allNodes.filter(el =>
        el.textContent && (
          el.textContent.toUpperCase().includes('PASSKEY') ||
          el.textContent.toUpperCase().includes('PASS KEY')
        )
      );
      if (passkeyElements.length > 0) {
        results.passkeyElement = {
          found: true,
          text: passkeyElements[0].textContent.trim(),
          className: passkeyElements[0].className,
          tagName: passkeyElements[0].tagName
        };
      }
      
      const salesElements = allNodes.filter(el =>
        el.textContent && el.textContent.toUpperCase().includes('SALES ID')
      );
      if (salesElements.length > 0) {
        results.salesIdElement = {
          found: true,
          text: salesElements[0].textContent.trim(),
          className: salesElements[0].className,
          tagName: salesElements[0].tagName
        };
      }
      
      const barcodeImages = Array.from(document.querySelectorAll('img')).filter(img => {
        const alt = (img.alt || '').toLowerCase();
        const src = img.src || '';
        return alt.includes('barcode') || alt.includes('qr') || src.startsWith('data:image');
      });
      if (barcodeImages.length > 0) {
        results.barcodeElement = {
          found: true,
          alt: barcodeImages[0].alt,
          src: barcodeImages[0].src.substring(0, 50) + '...',
          width: barcodeImages[0].width,
          height: barcodeImages[0].height
        };
      }
      
      results.allElementsFound = !!(
        results.bookingIdElement &&
        results.passkeyElement &&
        results.salesIdElement &&
        results.barcodeElement
      );
      
      return results;
    });

    console.log(chalk.gray('ğŸ“Š Enhanced detection results:'));
    console.log(chalk.gray(`   ğŸŸï¸  Booking ID: ${enhancedDetection.bookingIdElement ? 'âœ… Found' : 'âŒ Not found'}`));
    if (enhancedDetection.bookingIdElement) {
      console.log(chalk.gray(`       Text: "${enhancedDetection.bookingIdElement.text}"`));
    }
    
    console.log(chalk.gray(`   ğŸ”‘ Passkey: ${enhancedDetection.passkeyElement ? 'âœ… Found' : 'âŒ Not found'}`));
    if (enhancedDetection.passkeyElement) {
      console.log(chalk.gray(`       Text: "${enhancedDetection.passkeyElement.text}"`));
    }
    
    console.log(chalk.gray(`   ğŸ†” Sales ID: ${enhancedDetection.salesIdElement ? 'âœ… Found' : 'âŒ Not found'}`));
    if (enhancedDetection.salesIdElement) {
      console.log(chalk.gray(`       Text: "${enhancedDetection.salesIdElement.text}"`));
    }
    
    console.log(chalk.gray(`   ğŸ“± Barcode: ${enhancedDetection.barcodeElement ? 'âœ… Found' : 'âŒ Not found'}`));
    if (enhancedDetection.barcodeElement) {
      console.log(chalk.gray(`       Alt: "${enhancedDetection.barcodeElement.alt}"`));
    }
    
    const completeness = enhancedDetection.allElementsFound ? 'âœ… COMPLETE' : 'âš ï¸ PARTIAL';
    console.log(chalk.gray(`   ğŸ¯ Ticket completeness: ${completeness}`));
    
    if (!enhancedDetection.allElementsFound) {
      console.log(chalk.yellow('â³ Waiting for missing ticket elements...'));
      try {
        await page.waitForFunction(() => {
          const txt = document.body ? document.body.textContent.toUpperCase() : '';
          const hasBookingId = txt.includes('BOOKING ID');
          const hasPasskey = txt.includes('PASSKEY') || txt.includes('PASS KEY');
          const hasSalesId = txt.includes('SALES ID');
          const hasBarcode = document.querySelector(
            'img[alt*="arcode"], img[alt*="QR"], img[src*="data:image"]'
          );
          
          return hasBookingId && hasPasskey && hasSalesId && hasBarcode;
        }, { timeout: 15000 });
        console.log(chalk.green('âœ… All critical ticket elements now present'));
      } catch {
        console.log(chalk.yellow('âš ï¸ Timeout waiting for all elements, proceeding with available content...'));
      }
    }

    await appendJsonLog({
      event: 'fnb_enhanced_element_detection',
      sales_id: salesId,
      detection_results: enhancedDetection
    });

// âœ… HELPER: Sanitize filename (hapus karakter ilegal, PERTAHANKAN SPASI, batasi panjang)
const sanitizeFilename = (str, maxLen = 30) => {
  return String(str || '')
    .replace(/[<>:"\/\\|?*]/g, '')  // Only remove Windows illegal chars, KEEP SPACES
    .slice(0, maxLen);
};

// âœ… BUILD FILENAME: Cinema_Item_[Custom1+Custom2]_Booking_Passkey.png
let outName = '';

// 1) Cinema name - use parameter or extract from fnbItems
let cinemaPart = cinemaName || 'Cinema';
if (!cinemaName && typeof fnbItems === 'string' && fnbItems.includes(' - ')) {
  const parts = fnbItems.split(' - ');
  if (parts[1]) cinemaPart = parts[1];
}
const cinemaShort = sanitizeFilename(cinemaPart, 20);

// 2) Item name (dari fnbItems parameter atau cart)
let itemName = '';
if (typeof fnbItems === 'string' && fnbItems.trim()) {
  // Ambil item pertama kalau ada multiple (split by comma)
  itemName = fnbItems.split(',')[0].trim();
} else if (Array.isArray(lastFnbCartSnapshot) && lastFnbCartSnapshot.length) {
  itemName = lastFnbCartSnapshot[0].name || '';
}
const itemShort = sanitizeFilename(itemName || 'FnB', 25);

// 3) Customizations - PRIORITAS: parameter customizations > lastFnbCartSnapshot
let customPart = '';
const customizationsToUse = Array.isArray(customizations) && customizations.length
  ? customizations
  : (Array.isArray(lastFnbCartSnapshot) && lastFnbCartSnapshot.length && lastFnbCartSnapshot[0].customizations)
    ? lastFnbCartSnapshot[0].customizations
    : null;

if (customizationsToUse && customizationsToUse.length) {
  const custNames = customizationsToUse
    .map(c => {
      const name = c.SUB_ITEM_NM || c.name || '';
      // Trim nama yang terlalu panjang (max 30 char per custom)
      return sanitizeFilename(name, 30);
    })
    .filter(Boolean)
    .join('+');

  if (custNames) {
    // Batasi total length customization part (max 80 char)
    const maxCustomLen = 80;
    const truncated = custNames.length > maxCustomLen
      ? custNames.slice(0, maxCustomLen) + '...'
      : custNames;
    customPart = `_[${truncated}]`;
  }
}

// Debug log untuk customizations
if (customizationsToUse && customizationsToUse.length) {
  console.log(chalk.gray(`ğŸ” Cart snapshot for filename:`));
  console.log(chalk.gray(`   Source: ${customizations && customizations.length ? 'Parameter' : 'Global lastFnbCartSnapshot'}`));
  console.log(chalk.gray(`   Customizations: ${customizationsToUse.length}`));
  customizationsToUse.forEach((c, idx) => {
    console.log(chalk.gray(`     ${idx + 1}. ${c.SUB_ITEM_NM || c.name || 'Unknown'}`));
  });
} else {
  console.log(chalk.yellow(`âš ï¸ No customizations found (parameter: ${customizations?.length || 0}, global: ${lastFnbCartSnapshot?.[0]?.customizations?.length || 0})`));
}

// âœ… FINAL FILENAME - Format: Cinema_Item_[Custom1+Custom2]_Booking_Passkey.png
const bookingShort = sanitizeFilename(bookingCode || 'booking', 15);
const passKeyShort = sanitizeFilename(passKey || 'passkey', 10);
outName = `${cinemaShort}_${itemShort}${customPart}_${bookingShort}_${passKeyShort}.png`;


    console.log(chalk.gray(`ğŸ“ Creating output directory: ${outDir}`));
    await fs.mkdir(outDir, { recursive: true });
    const outPath = path.join(outDir, outName);
    console.log(chalk.gray(`ğŸ’¾ Output path: ${outPath}`));

    console.log(chalk.gray('ğŸ“œ Scrolling to top for full page screenshot...'));
    await page.evaluate(() => window.scrollTo(0, 0));
    await delay(2000);
    console.log(chalk.gray('âœ… Scroll to top completed'));

    console.log(chalk.gray('ğŸ“± Taking full mobile page screenshot...'));
    
    await page.screenshot({
      path: outPath,
      type: 'png',
      fullPage: true
    });
    
    console.log(chalk.gray('âœ… Full page screenshot completed'));

    try {
      const stats = await fs.stat(outPath);
      console.log(chalk.green(`ğŸ“¸ Screenshot tersimpan: ${outPath} (${Math.round(stats.size/1024)}KB)`));
      console.log(chalk.cyan('ğŸ¯ Screenshot mencakup: Header + Info F&B + Booking Code + PassKey + QR/Barcode'));
    } catch (statError) {
      console.log(chalk.yellow(`âš ï¸ Could not verify screenshot file: ${statError.message}`));
    }

    // ğŸ§¹ TUTUP BROWSER SECEPATNYA SETELAH SCREENSHOT
    try {
      if (page) {
        console.log(chalk.gray('ğŸ§¹ Closing page (after screenshot)...'));
        await page.close();
        page = null;
        console.log(chalk.gray('ğŸ“± Page closed'));
      }
    } catch {}
    try {
      if (browser) {
        console.log(chalk.gray('ğŸ§¹ Closing browser (after screenshot)...'));
        await browser.close();
        browser = null;
        console.log(chalk.gray('ğŸš€ Browser closed'));
      }
    } catch {}

    // ğŸ“² Kirim ke Telegram kalau diizinkan
    if (sendToTelegram && typeof sendTelegramTicketScreenshot === 'function') {
      try {
        console.log(chalk.gray('ğŸ“² Sending F&B ticket screenshot to Telegram...'));

        const emailForTg = accountEmail || email;
        const passForTg  = accountPassword || password;

        await sendTelegramTicketScreenshot({
          filePath: outPath,
          bookingCode,
          passKey,
          salesId,
          type: 'fnb',
          fnbItems,
          fnbDetail,
          customizations,  // âœ… PASS CUSTOMIZATIONS
          accountEmail: emailForTg,
          accountPassword: passForTg,
          accountName
        });

        console.log(chalk.green('ğŸ¿ğŸ“± F&B ticket screenshot sent to Telegram!'));
      } catch (tgErr) {
        console.log(chalk.yellow(`âš ï¸ Gagal kirim screenshot F&B ke Telegram: ${tgErr.message}`));
      }
    } else {
      console.log(chalk.gray(`ğŸ“µ Skip kirim Telegram (sendToTelegram=${sendToTelegram})`));
    }
    
    await appendJsonLog({
      event: 'fnb_mobile_screenshot_saved',
      file: outPath,
      url: currentUrl,
      sales_id: salesId,
      booking_code: bookingCode,
      pass_key: passKey,
      login_required: true, // FORCE LOGIN MODE
      page_content: pageContent,
      screenshot_type: 'full_page',
      send_telegram: sendToTelegram
    });

    return { success: true, path: outPath };
    
  } catch (e) {
    console.log(chalk.red(`âŒ Screenshot error: ${e.message}`));
    console.log(chalk.gray(`ğŸ” Error stack: ${e.stack}`));
    await appendJsonLog({
      event: 'fnb_mobile_screenshot_error',
      error: e.message,
      stack: e.stack,
      sales_id: salesId
    });
    return { success: false, error: e.message };
  } finally {
    // FINAL SAFETY: kalau masih ada page/browser yang belum ketutup
    try { 
      if (page) {
        console.log(chalk.gray('ğŸ§¹ Closing page (finally)...'));
        await page.close();
        console.log(chalk.gray('ğŸ“± Page closed'));
      }
    } catch {}
    try { 
      if (browser) {
        console.log(chalk.gray('ğŸ§¹ Closing browser (finally)...'));
        await browser.close();
        console.log(chalk.gray('ğŸš€ Browser closed'));
      }
    } catch {}
  }
}




// ---------- QR CODE GENERATOR ----------
function generateQRCodeUrl(data, size = '200x200') {
  const encodedData = encodeURIComponent(data);
  return `https://api.qrserver.com/v1/create-qr-code/?size=${size}&data=${encodedData}&format=png`;
}


function generateAdvancedQRUrl(data, options = {}) {
  const {
    size = '300x300',
    color = '000000',
    bgcolor = 'ffffff',
    ecc = 'M',
    format = 'png'
  } = options;
  const encodedData = encodeURIComponent(data);
  return `https://api.qrserver.com/v1/create-qr-code/?size=${size}&data=${encodedData}&color=${color}&bgcolor=${bgcolor}&ecc=${ecc}&format=${format}`;
}

// ---------- QR / BARCODE HELPERS (untuk F&B) ----------
async function sendTelegramBookingQRCodeWithRetry(qrData, caption = '', chatId = TELEGRAM_CHAT_ID) {
  // âœ… WRAP WITH RETRY MECHANISM
  return retryAsync(async () => {
    const payload = String(qrData ?? '');

    try {
    // ğŸ¯ UTAMA: Generate BARCODE 1D (Code128) mirip tampilan CGV
    // pastikan sudah: npm install bwip-js
    const bwipModule = await import('bwip-js');
    const bwip = bwipModule.default || bwipModule;

    // âœ… FIX: Gunakan options yang benar untuk bwip-js
    const png = await bwip.toBuffer({
      bcid: 'code128',       // Barcode type
      text: payload,         // Text to encode
      scale: 3,              // 3x scaling
      height: 15,            // Bar height in millimeters
      includetext: true,     // Show text below barcode
      textxalign: 'center'   // Center align text
    });

    await sendTelegramPhotoBuffer(png, 'ticket_barcode.png', caption, chatId);
    return { success: true, mode: 'barcode' };

  } catch (errBarcode) {
    console.log(chalk.yellow(`âš ï¸ barcode (bwip-js) gagal: ${errBarcode.message}, fallback ke QR 2D`));

    try {
      // ğŸ” FALLBACK 1: tetap bikin QR 2D lokal kalau barcode gagal
      const QRCode = (await import('qrcode')).default;
      const png = await QRCode.toBuffer(payload, {
        errorCorrectionLevel: 'H',
        type: 'png',
        margin: 1,
        scale: 8,
        color: { dark: '#000000', light: '#ffffff' }
      });

      await sendTelegramPhotoBuffer(png, 'ticket_qr.png', caption, chatId);
      return { success: true, mode: 'qr2d' };
    } catch (error) {
      // ğŸ” FALLBACK 2: terakhir, pakai URL generator seperti sebelumnya
      console.log(chalk.yellow(`âš ï¸ qrcode local gagal: ${error.message}, fallback ke url`));
      const qrUrl = generateAdvancedQRUrl(payload, {
        size: '400x400',
        color: '000000',
        bgcolor: 'ffffff',
        ecc: 'H',
        format: 'png'
      });
      const telegramUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;
      const response = await requestJson('POST', telegramUrl, {
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({
          chat_id: chatId,
          photo: qrUrl,
          caption: caption.slice(0, 1024),
          parse_mode: 'HTML'
        })
      });
      return { success: true, mode: 'remote', response };
    }
  }
  }, 3, 3000); // âœ… 3 retries, 3 second delay
}



async function sendTelegramMessage(message, parseMode = 'HTML') {
  // âœ… WRAP WITH RETRY MECHANISM
  return retryAsync(async () => {
  try {
    const telegramUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
    const { json, status, text } = await requestJson('POST', telegramUrl, {
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        chat_id: TELEGRAM_CHAT_ID,
        text: String(message || '').slice(0, 4096),
        parse_mode: parseMode
      })
    });

    if (!json || json.ok === false) {
      throw new Error(json?.description || `Telegram sendMessage failed (HTTP ${status})`);
    }

    const msgId = json?.result?.message_id ?? null;

    // kompatibel ke belakang: ada `success`, ada `result`, ada `message_id`
    return {
      ...json,
      success: true,
      status,
      message_id: msgId,
      raw_text: text
    };
  } catch (error) {
    console.log(chalk.red(`âŒ Telegram sendMessage failed: ${error.message}`));
    throw error; // âœ… Re-throw untuk retry mechanism
  }
  }, 3, 3000); // âœ… 3 retries, 3 second delay
}



function generateTelegramTicket(ticketData, type = 'fnb') {
  const {
    fnbItems,
    cinemaName,
    date,
    bookingCode,
    salesId,
    totalAmount,
    itemDetails = [],
    passKey,
    cinemaLocation,
    location
  } = ticketData || {};

  const safe = (val) => String(val ?? '');

  const itemsLabel   = safe(fnbItems) || 'F&B Order';
  const cinemaLabel  = safe(cinemaName) || 'CGV Cinema';
  const dateLabel    = safe(date || todayYmd());
  const totalLabel   = safe(totalAmount) || 'Rp0';
  const bookingLabel = safe(bookingCode || 'N/A');
  const passKeyLabel = safe(passKey || '-');
  const salesIdLabel = safe(salesId || '-');
  const locLabel     = safe(cinemaLocation || location || '');

  // Judul menyesuaikan tipe
  let message = `ğŸ« <b>${type === 'movie' ? 'MOVIE TICKET RECEIPT' : 'F&B ORDER RECEIPT'}</b>\n\n`;

  // ğŸ§¾ DETAIL PESANAN
  message += `ğŸ§¾ <b>Detail Pesanan ${type === 'movie' ? 'Tiket' : 'F&B'}</b>\n`;
  message += `â€¢ Items   : ${itemsLabel}\n`;

  // Rincian item + customizations
  let detailBlock = '';
  if (Array.isArray(itemDetails) && itemDetails.length > 0) {
    detailBlock = itemDetails
      .map((item, idx) => {
        const name = safe(item.name || `Item ${idx + 1}`);
        const qty  = item.qty || item.quantity || 1;

        const customs = Array.isArray(item.customizations)
          ? item.customizations.filter(Boolean).map(c => safe(c))
          : [];

        let line = `   ${idx + 1}. ${name} (${qty}x)`;
        if (customs.length) {
          // contoh:
          //    1. Combo Solo (1x)
          //       â†³ Medium Caramel Popcorn
          //       â†³ Medium Jasmine
          line += `\n      â†³ ${customs.join('\n      â†³ ')}`;
        }
        return line;
      })
      .filter(Boolean)
      .join('\n');
  }

  if (detailBlock) {
    message += `â€¢ Rincian :\n${detailBlock}\n`;
  }

  // ğŸ¢ BIOSKOP
  message += `\nğŸ¢ <b>Bioskop</b>\n`;
  message += `â€¢ Nama    : ${cinemaLabel}\n`;
  if (locLabel) {
    message += `â€¢ Lokasi  : ${locLabel}\n`;
  }
  message += `â€¢ Tanggal : ${dateLabel}\n`;

  // ğŸŸï¸ TIKET
  message += `\nğŸŸï¸ <b>Tiket</b>\n`;
  message += `â€¢ Booking : <code>${bookingLabel}</code>\n`;
  message += `â€¢ PassKey : <code>${passKeyLabel}</code>\n`;
  message += `â€¢ Sales ID: <code>${salesIdLabel}</code>\n`;

  // ğŸ’³ PEMBAYARAN
  message += `\nğŸ’³ <b>Pembayaran</b>\n`;
  message += `â€¢ Total   : ${totalLabel}\n`;

  // STATUS
  message += `\nâœ… <b>STATUS: ${type === 'movie' ? 'TIKET SIAP DIGUNAKAN' : 'F&B SIAP DIAMBIL'}</b>\n`;
  message += `ğŸ“ Tunjukkan ${type === 'movie'
    ? 'tiket & booking code saat masuk studio'
    : 'booking code di counter F&B'}\n`;
  message += `â° ${new Date().toLocaleString('id-ID')}\n`;

  // ğŸ”¢ ASCII "barcode" â€” PRIORITAS: PASSKEY â†’ SALES_ID â†’ BOOKING
  message += `\n<pre>`;
  const barcodeData = safe(passKey || salesId || bookingCode || 'NO_DATA');
  const chars = barcodeData.split('').slice(0, 15);

  try {
    for (let i = 0; i < 3; i++) {
      let line = '';
      chars.forEach((char) => {
        const code = char.charCodeAt(0);
        const patterns = ['â–ˆâ–ˆâ–ˆ', 'â–ˆ â–ˆ', 'â–ˆâ–ˆâ–ˆ'];
        const pattern = code % (i + 2) === 0 ? patterns[0] : patterns[1];
        line += pattern + ' ';
      });
      message += line.slice(0, 30) + '\n';
    }
    message += `${barcodeData}\n</pre>`;
  } catch {
    message += `${barcodeData}\n</pre>`;
  }

  return message;
}






// ======================================================================
// BAGIAN 1 â€” KIRIM QR F&B (BOOKING + PASSKEY) KE TELEGRAM
// ======================================================================
async function sendFnBOrderWithQR(fnbData, options = {}) {
  const { sendToTelegram = false } = options; // ğŸ”§ default ON (sesuai kebutuhan)

  const safe = (val) => (val == null ? '' : String(val).trim());

  const booking = safe(fnbData.bookingCode);
  const passKey = safe(fnbData.passKey);
  const salesId = safe(fnbData.salesId);

  // ğŸ” Deteksi object akun
  const accountObj =
    fnbData.account ||
    fnbData.selectedAccount ||
    fnbData.orderAccount ||
    fnbData.cgvAccount ||
    fnbData.user ||
    fnbData.member ||
    null;

  // ğŸ“› Nama, email, password akun CGV
  const accountNameRaw =
    fnbData.accountName ??
    (accountObj && (
      accountObj.name ||
      accountObj.fullName ||
      accountObj.customer_name
    ));

  const accountEmailRaw =
    fnbData.accountEmail ??
    fnbData.email ??
    (accountObj && (
      accountObj.email ||
      accountObj.email_id ||
      accountObj.username ||
      accountObj.userId ||
      accountObj.loginEmail
    ));

  const accountPasswordRaw =
    fnbData.accountPassword ??
    fnbData.password ??
    (accountObj && (
      accountObj.password ||
      accountObj.pass ||
      accountObj.loginPassword ||
      accountObj.pin
    ));

  const accountName     = safe(accountNameRaw);
  const accountEmail    = safe(accountEmailRaw);
  const accountPassword = safe(accountPasswordRaw);

  // ğŸ“Œ QR = {BOOKINGCODE}{PASSKEY} (TANPA SPASI, TIDAK ADA NEWLINE)
  const qrData = passKey ? `${booking}${passKey}` : booking;

  // ---------- NORMALISASI CART / ITEM DETAILS (FREE & PAID) ----------
  const pickItemsArray = () => {
    if (Array.isArray(fnbData.itemDetails) && fnbData.itemDetails.length) return fnbData.itemDetails;
    if (Array.isArray(fnbData.cartItems) && fnbData.cartItems.length)     return fnbData.cartItems;
    if (Array.isArray(fnbData.items) && fnbData.items.length)             return fnbData.items;
    if (Array.isArray(fnbData.cart?.items) && fnbData.cart.items.length)  return fnbData.cart.items;
    return [];
  };

  const itemsRaw = pickItemsArray();

  const normalizeName = (it) =>
    it?.name ||
    it?.itemName ||
    it?.item_name ||
    it?.menuName ||
    it?.menu_name ||
    it?.product_name ||
    '-';

  const normalizeQty = (it) => {
    const q = it?.qty ?? it?.quantity ?? it?.qty_order ?? it?.count;
    if (typeof q === 'number' && q > 0) return q;
    const n = Number(q);
    return Number.isFinite(n) && n > 0 ? n : 1;
  };

  const normalizeCustomizations = (it) => {
    const pickSrc = () => {
      if (Array.isArray(it.customizations) && it.customizations.length) return it.customizations;
      if (Array.isArray(it.customize) && it.customize.length)           return it.customize;
      if (Array.isArray(it.options) && it.options.length)               return it.options;
      if (Array.isArray(it.itemDetail) && it.itemDetail.length)         return it.itemDetail;
      if (Array.isArray(it.details) && it.details.length)               return it.details;
      if (Array.isArray(it.item_child_all) && it.item_child_all.length) return it.item_child_all;
      return null;
    };

    const src = pickSrc();
    if (!src || !src.length) return [];

    // sudah array string
    if (typeof src[0] === 'string') {
      return src.map(safe).filter(Boolean);
    }

    // array objek: gabung name + value kalau ada
    return src
      .map((opt) => {
        if (!opt || typeof opt !== 'object') return null;
        
        // ğŸ” Extract name dari berbagai kemungkinan field
        const name = safe(
          opt.SUB_ITEM_NM ||  // âœ… DARI API DETAIL TICKET
          opt.name ||
          opt.label ||
          opt.title ||
          opt.attrNm ||
          opt.attribute ||
          opt.type ||
          opt.option_name
        );
        
        const value = safe(
          opt.value ||
          opt.choice ||
          opt.attrVal ||
          opt.text ||
          opt.selected ||
          opt.option_value
        );
        
        if (name && value) return `${name}: ${value}`;
        return name || value || null;
      })
      .filter(Boolean);
  };

  const itemDetails = itemsRaw
    .map((it) => {
      const name = normalizeName(it);
      const qty  = normalizeQty(it);
      const customizations = normalizeCustomizations(it);
      return { name, qty, customizations };
    })
    .filter((it) => it.name && (it.qty || (it.customizations && it.customizations.length)));

  const itemsSummary = itemDetails.length
    ? itemDetails.map((it) => `${it.name} (${it.qty}x)`).join(', ')
    : safe(fnbData.fnbItems);

  // ğŸ”¥ DETAIL LINES WITH CUSTOMIZATIONS
  const detailLines = itemDetails
    .map((it) => {
      const base = `${it.name} (${it.qty}x)`;
      if (!it.customizations || !it.customizations.length) return `   - ${base}`;
      return `   - ${base}\n      â†³ ${it.customizations.join(', ')}`;
    })
    .filter(Boolean);

  const cinemaName     = safe(fnbData.cinemaName);
  const cinemaLocation = safe(fnbData.cinemaLocation || fnbData.location);
  const dateLabel      = safe(fnbData.date);
  const totalAmount    = safe(fnbData.totalAmount);
  const voucherLabel   = safe(fnbData.voucherLabel);

  // ---------- CAPTION TELEGRAM (HTML) ----------
  let caption = '';

  // âœ… HEADER
  caption += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
  caption += `ğŸ¿ <b>F&B ORDER QR CODE</b>\n`;
  caption += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;

  // ğŸ‘¤ Info Akun CGV
  if (accountName || accountEmail || accountPassword) {
    caption += `ğŸ‘¤ <b>AKUN CGV</b>\n`;
    caption += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
    if (accountName) {
      caption += `Nama     : ${accountName}\n`;
    }
    caption += `Email    : <code>${accountEmail || '-'}</code>\n`;
    if (accountPassword) {
      caption += `Password : <code>${accountPassword}</code>\n`;
    }
    caption += `\n`;
  }

  // ğŸ§¾ Detail Pesanan
  caption += `ğŸ§¾ <b>DETAIL PESANAN</b>\n`;
  caption += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
  caption += `Items : ${itemsSummary || '-'}\n`;
  if (detailLines.length) {
    caption += `\n`;
    detailLines.forEach((line, idx) => {
      const itemText = line.replace(/^\s*-\s*/, '').trim();
      caption += `  ${idx + 1}. ${itemText}\n`;
    });
  }

  // ğŸ¢ Bioskop
  caption += `\nğŸ¢ <b>BIOSKOP</b>\n`;
  caption += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
  caption += `Nama    : ${cinemaName || '-'}\n`;
  if (cinemaLocation) {
    caption += `Lokasi  : ${cinemaLocation}\n`;
  }
  if (dateLabel) {
    caption += `Tanggal : ${dateLabel}\n`;
  }

  // ğŸŸï¸ Info Tiket
  caption += `\nğŸŸï¸ <b>INFO TIKET</b>\n`;
  caption += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
  caption += `Booking  : <code>${booking}</code>\n`;
  caption += `Passkey  : <code>${passKey || '-'}</code>\n`;
  caption += `Sales ID : <code>${salesId || '-'}</code>\n`;

  // ğŸ’³ Pembayaran
  caption += `\nğŸ’³ <b>PEMBAYARAN</b>\n`;
  caption += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
  caption += `Total   : ${totalAmount || '-'}\n`;
  if (voucherLabel) {
    caption += `Voucher : ${voucherLabel}\n`;
  }

  // âœ… FOOTER
  caption += `\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
  caption += `âœ… <b>SCAN QR AT F&B COUNTER</b>\n`;
  caption += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;

  // ğŸ”§ Kalau dimatikan, jangan kirim ke Telegram
  if (!sendToTelegram) {
    console.log(chalk.yellow('ğŸ“µ sendFnBOrderWithQR: sendToTelegram = false, skip kirim ke Telegram.'));
    return {
      success       : false,
      skipped       : true,
      reason        : 'sendToTelegram=false',
      qrData,
      booking,
      passKey,
      salesId,
      accountName,
      accountEmail
    };
  }

  try {
    const qrResult = await sendTelegramBookingQRCodeWithRetry(qrData, caption);
    if (qrResult.success) {
      console.log(chalk.green('ğŸ¿ğŸ“± F&B QR sent (booking+passkey + akun CGV + customizations)'));
      return { success: true, telegram: true };
    }

    // fallback text, kirim juga info akun
    console.log(chalk.yellow('âš ï¸ QR F&B gagal, kirim versi text...'));
    const textFnb = generateTelegramTicket(
      {
        ...fnbData,
        accountName,
        accountEmail,
        accountPassword
      },
      'fnb'
    );
    await sendTelegramMessage(textFnb);
    return { success: true, telegram: true, fallback: 'text' };
  } catch (err) {
    console.log(chalk.yellow(`âš ï¸ sendFnBOrderWithQR error: ${err.message}`));
    return { success: false, telegram: false, error: err.message };
  }
}



















// ============================================================
// Generate F&B receipt for free order (FIXED: pakai sales_id + pass_key)
// ============================================================
async function generateFreeFnbReceiptForOrder({
  orderId,
  token,
  fnbItems = '',
  selectedAccount = null
}) {
  try {
    if (!orderId) {
      console.log(chalk.red('âŒ generateFreeFnbReceiptForOrder: orderId kosong.'));
      return;
    }

    // 1) Ambil order detail terbaru
    const odRes = await fetchOrderDetail(orderId, token);
    const od = odRes?.data || {};
    if (!od.id) {
      console.log(chalk.red('âŒ Tidak bisa ambil order detail untuk free order.'));
      await appendJsonLog({
        event: 'fnb_free_order_no_order_detail',
        order_id: orderId,
        raw: odRes
      });
      return;
    }

    // 2) Cari transaksi F&B paling relevan â†’ ambil sales_id
    let pickedTx = null;
    let salesId = od.sales_id || null;

    // Coba beberapa kali (kadang transaction muncul telat)
    for (let attempt = 1; attempt <= 3 && !salesId; attempt++) {
      const txRes = await fetchMembershipTransactions(token);
      if (txRes?.status_code === 200 && Array.isArray(txRes.data)) {
        pickedTx = pickRelevantFnbTransaction(
          txRes.data,
          {
            completeDate: od.complete_date,
            orderId: od.id,
            bookingCode: od.booking_code,
            totalAmount: od.total_amount,
            fnbItems: fnbItems || (od.conces || []).map(c => c.name).join(', ')
          },
          { preferComplete: true }
        );
        salesId = pickedTx?.sales_id || salesId;
      }

      if (!salesId) {
        console.log(chalk.gray(`â³ [FREE] Belum dapat sales_id (attempt ${attempt}/3), tunggu 2 detik...`));
        await delay(2000);
      }
    }

    if (!salesId) {
      console.log(chalk.yellow('âš ï¸ [FREE] Tidak menemukan sales_id, kirim tiket sederhana hanya dengan booking code.'));
      const simpleData = {
        fnbItems: fnbItems || (od.conces || []).map(c => c.name).join(', ') || 'F&B Order',
        cinemaName: od.cinema_name || 'CGV Cinema',
        date: (od.complete_date || od.sale_date || todayYmd()).split(' ')[0],
        bookingCode: od.booking_code,
        passKey: '',
        salesId: '',
        totalAmount: toRp(od.total_amount || 0),
        itemDetails: od.conces || []
      };

      await sendTelegramMessage(generateTelegramTicket(simpleData, 'fnb'));


      await appendJsonLog({
        event: 'fnb_free_order_simple_ticket_sent',
        order_id: orderId,
        booking_code: simpleData.bookingCode
      });

      return;
    }

    console.log(chalk.green(`âœ… [FREE] Sales ID ditemukan: ${salesId}`));

    // 3) Ambil ticket detail â†’ pass_key, booking_code, conces
    const tdRes = await fetchTicketDetail(salesId, token);
    let passKey = null;
    let bookingFromDetail = null;
    let itemDetails = [];
    let cinemaName = od.cinema_name || pickedTx?.cinema_name || 'CGV Cinema';
    let dateStr =
      (od.complete_date || pickedTx?.pickup_date || pickedTx?.transaction_date || todayYmd())
        .split(' ')[0];

    if (tdRes?.status_code === 200 && tdRes.data) {
      const d = tdRes.data;
      passKey = d.pass_key || d.passkey || d.passKey || '';
      bookingFromDetail = d.booking_code || od.booking_code;
      itemDetails = d.conces || d.conces_items || [];

      cinemaName = d.cinema_name || cinemaName;
      if (d.complete_date) {
        dateStr = d.complete_date.split(' ')[0];
      }

      await appendJsonLog({
        event: 'fnb_free_order_ticket_detail_ok',
        order_id: orderId,
        sales_id: salesId,
        pass_key: passKey,
        booking_code: bookingFromDetail
      });
    } else {
      console.log(chalk.yellow('âš ï¸ [FREE] Gagal ambil detail ticket, pakai data transaksi/order saja.'));
      bookingFromDetail = od.booking_code;
      itemDetails = od.conces || [];
      await appendJsonLog({
        event: 'fnb_free_order_ticket_detail_failed',
        order_id: orderId,
        sales_id: salesId,
        raw: tdRes
      });
    }

    // 4) Susun data tiket final
    const finalFnbItems =
      fnbItems ||
      pickedTx?.name ||
      itemDetails.map(c => c.name).join(', ') ||
      'F&B Order';

    const fnbTicketData = {
      fnbItems: finalFnbItems,
      cinemaName,
      date: dateStr,
      bookingCode: bookingFromDetail || od.booking_code,
      passKey: passKey || '',
      salesId,
      totalAmount: toRp(od.total_amount || pickedTx?.amount || 0),
      itemDetails
    };

    // 5) Screenshot mobile m.cgv.id
    try {
      if (selectedAccount?.email && selectedAccount?.password) {
        console.log(chalk.cyan('\nğŸŒ [FREE] Auto login & screenshot F&B ticket...'));
        const sendScreenshotFnb = (process.env.SEND_SCREENSHOT_TO_TELEGRAM_FNB || 'false').toLowerCase() === 'true';
        const ssRes = await loginAndScreenshotFnbTicket({
          salesId,
          email: selectedAccount.email,
          password: selectedAccount.password,
          bookingCode: fnbTicketData.bookingCode,
          passKey: fnbTicketData.passKey,
          outDir: 'orders',
          headless: true,
          sendToTelegram: sendScreenshotFnb,  // âœ… USE ENV VARIABLE
          accountEmail: selectedAccount.email,  // âœ… Added
          accountPassword: selectedAccount.password,  // âœ… Added
          accountName: selectedAccount.name || selectedAccount.fullName || selectedAccount.customer_name || '',  // âœ… Added
          fnbItems: fnbTicketData.fnbItems,  // âœ… Added
          fnbDetail: fnbTicketData.itemDetails,  // âœ… Added
          customizations: (Array.isArray(lastFnbCartSnapshot) && lastFnbCartSnapshot.length && lastFnbCartSnapshot[0].customizations) || [],  // âœ… PRIORITAS lastFnbCartSnapshot user choices
          cinemaName: fnbTicketData.cinemaName  // âœ… PASS CINEMA NAME
        });


        if (ssRes.success) {
          console.log(chalk.green(`ğŸ“¸ [FREE] Screenshot berhasil: ${ssRes.path}`));
          await appendJsonLog({
            event: 'fnb_free_order_screenshot_ok',
            order_id: orderId,
            sales_id: salesId,
            file: ssRes.path
          });
        } else {
          console.log(chalk.yellow(`âš ï¸ [FREE] Screenshot gagal: ${ssRes.error}`));
          await appendJsonLog({
            event: 'fnb_free_order_screenshot_failed',
            order_id: orderId,
            sales_id: salesId,
            error: ssRes.error
          });
        }
      } else {
        console.log(chalk.yellow('â„¹ï¸ [FREE] Skip screenshot (butuh email + password akun).'));
      }
    } catch (e) {
      console.log(chalk.yellow(`âš ï¸ [FREE] Screenshot error: ${e.message}`));
    }

    // 7) QR / receipt ke Telegram (booking + passKey/salesId)
    const sendQrFnb = (process.env.SEND_QR_TO_TELEGRAM_FNB || 'false').toLowerCase() === 'true';
    await sendFnBOrderWithQR(fnbTicketData, { sendToTelegram: sendQrFnb });
    if (sendQrFnb) {
      console.log(chalk.green('ğŸ“± [FREE] F&B QR/receipt for FREE order sent to Telegram!'));
    }

    await appendJsonLog({
      event: 'fnb_free_order_done',
      order_id: orderId,
      sales_id: salesId,
      booking_code: fnbTicketData.bookingCode,
      pass_key: fnbTicketData.passKey
    });

  } catch (e) {
    console.log(chalk.red(`âŒ generateFreeFnbReceiptForOrder error: ${e.message}`));
    await appendJsonLog({
      event: 'fnb_free_order_error',
      order_id: orderId,
      error: e.message,
      stack: e.stack
    });

    const errorMsg =
      `ğŸš¨ <b>F&amp;B FREE ORDER ERROR</b>\n\n` +
      `Order ID: <code>${orderId}</code>\n` +
      `Error: <code>${e.message}</code>\n` +
      `Time: ${new Date().toLocaleString('id-ID')}`;
    await sendTelegramMessage(errorMsg);
  }
}


// Safe function executor with Telegram fallback
async function safeExecute(fn, context = '') {
  try {
    return await fn();
  } catch (error) {
    const errorMsg = `âŒ <b>ERROR in ${context}</b>\n\n` +
      `<code>${error.message || error}</code>\n\n` +
      `Stack: <pre>${(error.stack || '').slice(0, 500)}</pre>\n\n` +
      `Time: ${new Date().toLocaleString('id-ID')}`;
    
    await sendTelegramMessage(errorMsg);
    throw error; // Re-throw untuk normal error handling
  }
}

// ğŸ” TAMBAHKAN HELPER INI DI SINI
function extractSalesIdFromOrder(od) {
  if (!od || typeof od !== 'object') return null;

  const fromRoot =
    od.sales_id ||
    od.salesId ||
    od.sale_id ||
    od.saleId ||
    od.ticket_sales_id ||
    od.ticketSalesId ||
    od.fnb_sales_id ||
    od.fnbSalesId ||
    null;

  const fromData = od.data && (
    od.data.sales_id ||
    od.data.salesId ||
    od.data.sale_id ||
    od.data.saleId ||
    od.data.ticket_sales_id ||
    od.data.ticketSalesId
  );

  const fromTicket = od.ticket && (
    od.ticket.sales_id ||
    od.ticket.salesId ||
    od.ticket.sale_id ||
    od.ticket.saleId
  );

  return fromRoot || fromData || fromTicket || null;
}
  // ---------- TICKET GENERATION ----------
  async function generateTicketLayout(ticketData, type = 'movie') {
    const { 
      movieName, duration, rating, cinemaName, format, date, time, 
      auditorium, seats, bookingCode, passKey, salesId, fnbItems,
      totalAmount
    } = ticketData;
    
    const lines = [];
    const width = 61;
    const center = (text) => {
      const padding = Math.max(0, Math.floor((width - text.length) / 2));
      return ' '.repeat(padding) + text + ' '.repeat(width - text.length - padding);
    };
    
    // Safe string conversion
    const safeString = (val) => String(val || '');
    const safeSlice = (val, start, end) => safeString(val).slice(start, end);
    
    // Header
    lines.push('â•­' + 'â”€'.repeat(width) + 'â•®');
    lines.push('â”‚' + center(type === 'movie' ? 'MOVIE TICKET DETAIL' : 'F&B ORDER DETAIL') + 'â”‚');
    lines.push('â”œ' + 'â”€'.repeat(width) + 'â”¤');
    lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
    
    if (type === 'movie') {
      // Movie info
      lines.push('â”‚    ğŸ¬ ' + safeSlice(movieName || 'Movie Title', 0, 54).padEnd(54) + 'â”‚');
      lines.push('â”‚    â±ï¸  ' + `${duration || 0} minutes | ${rating || 'N/A'}`.slice(0, 54).padEnd(54) + 'â”‚');
      lines.push('â”‚    ğŸ¢ ' + `${cinemaName || 'Cinema'} - ${format || '2D'}`.slice(0, 54).padEnd(54) + 'â”‚');
      lines.push('â”‚    ğŸ“… ' + `${date || ''} ${time || ''}`.slice(0, 54).padEnd(54) + 'â”‚');
      lines.push('â”‚    ğŸ­ ' + safeSlice(auditorium || 'Studio', 0, 54).padEnd(54) + 'â”‚');
      lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
      lines.push('â”‚    ğŸŸï¸  ' + `${seats?.length || 1} Ticket : ${seats?.map(s => s.row_name + s.number).join(', ') || 'N/A'}`.slice(0, 54).padEnd(54) + 'â”‚');
    } else {
      // F&B info
      lines.push('â”‚    ğŸ¿ ' + safeSlice(fnbItems || 'F&B Items', 0, 54).padEnd(54) + 'â”‚');
      lines.push('â”‚    ğŸ¢ ' + safeSlice(cinemaName || 'Cinema', 0, 54).padEnd(54) + 'â”‚');
      lines.push('â”‚    ğŸ“… ' + safeSlice(date || '', 0, 54).padEnd(54) + 'â”‚');
      lines.push('â”‚    ğŸ’° ' + `Total: ${totalAmount || 'N/A'}`.slice(0, 54).padEnd(54) + 'â”‚');
      lines.push('â”‚    ğŸŸï¸  ' + 'Ready for Pickup'.slice(0, 54).padEnd(54) + 'â”‚');
    }
    
    lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
    lines.push('â”œ' + 'â”€'.repeat(width) + 'â”¤');
    
    // âœ… PERBAIKAN: F&B dan Movie pakai format yang sama (BOOKING ID | PASSKEY)
    const bookingText = `BOOKING ID          â”‚  PASSKEY`;
    const safeBookingCode = safeString(bookingCode);
    const safePassKey = safeString(passKey);
    const bookingValue = `${safeBookingCode.padEnd(19)} â”‚  ${safePassKey.slice(0, 28)}`;
    
    lines.push('â”‚  ' + bookingText.padEnd(width - 2) + 'â”‚');
    lines.push('â”‚  ' + bookingValue.padEnd(width - 2) + 'â”‚');
  // ...
  lines.push('â”œ' + 'â”€'.repeat(width) + 'â”¤');
  lines.push('â”‚' + ' '.repeat(width) + 'â”‚');

  // âœ… BARCODE: sekarang F&B juga pakai PASSKEY (fallback â†’ SALES_ID â†’ BOOKING)
  const barcodeData = safeString(
    type === 'movie'
      ? (passKey || bookingCode || 'NO_DATA')
      : (passKey || salesId || bookingCode || 'NO_DATA')
  );

  const barcodeLines = generateASCIIBarcode(barcodeData);
  barcodeLines.forEach(barcode => {
    lines.push('â”‚' + barcode.padEnd(width) + 'â”‚');
  });

  lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
  lines.push('â”‚  ' + barcodeData.slice(0, width - 4).padEnd(width - 4) + 'â”‚');
  lines.push('â”‚' + ' '.repeat(width) + 'â”‚');
  lines.push('â•°' + 'â”€'.repeat(width) + 'â•¯');
  return lines.join('\n');
}



  function generateASCIIBarcode(data) {
    // Safe ASCII barcode generator
    const safeData = String(data || 'NO_DATA');
    const chars = safeData.split('').slice(0, 20); // Limit untuk safety
    const barcodeLines = ['', '', ''];
    
    chars.forEach(char => {
      const code = char.charCodeAt(0);
      const pattern1 = code % 2 === 0 ? 'â–ˆâ–ˆâ–ˆ' : 'â–ˆ â–ˆ';
      const pattern2 = code % 3 === 0 ? 'â–ˆ â–ˆ' : 'â–ˆâ–ˆâ–ˆ'; 
      const pattern3 = code % 4 === 0 ? 'â–ˆâ–ˆâ–ˆ' : 'â–ˆ â–ˆ';
      
      barcodeLines[0] += pattern1 + ' ';
      barcodeLines[1] += pattern2 + ' ';
      barcodeLines[2] += pattern3 + ' ';
    });
    
    return [
      '  ' + barcodeLines[0].slice(0, 57),
      '  ' + barcodeLines[1].slice(0, 57), 
      '  ' + barcodeLines[2].slice(0, 57)
    ];
  }


  async function saveTicketAsText(ticketText, filename) {
    try {
      // Ensure orders folder exists
      const ordersDir = 'orders';
      try {
        await fs.mkdir(ordersDir, { recursive: true });
      } catch (mkdirError) {
        // Folder already exists, continue
      }
      
      // Save to orders folder
      const fullPath = path.join(ordersDir, filename);
      await fs.writeFile(fullPath, ticketText, 'utf-8');
      return { success: true, filename: fullPath };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // ---------- MONITORING UTILS ----------
  function parseUtcish(s){
    if (!s) return null;
    const t = s.replace(' ', 'T') + 'Z';
    const d = new Date(t);
    return isNaN(+d) ? null : d;
  }
  
  function formatRemaining(ms){
    if (ms <= 0) return '0s';
    const s = Math.floor(ms/1000);
    const m = Math.floor(s/60);
    const r = s%60;
    return m ? `${m}m ${r}s` : `${r}s`;
  }

  function htmlDecode(input) {
    const s = String(input || '');
    return s
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&#x2F;/g, '/')
      .replace(/&#(\d+);/g, (_,n)=>String.fromCharCode(Number(n)))
      .replace(/&#x([0-9a-fA-F]+);/g, (_,h)=>String.fromCharCode(parseInt(h,16)));
  }

    // Cari transaksi F&B yang paling match dengan sesi kita barusan (copy dari movie logic)
  function pickRelevantFnbTransaction(txList=[], ctx={}, { preferComplete = true } = {}){
    const {
      completeDate,                  // string "YYYY-MM-DD HH:mm:ss" dari order.complete_date
      orderId,                       // order ID untuk F&B
      bookingCode,                   // booking code
      totalAmount,                   // od.total_amount
      fnbItems                       // nama F&B items
    } = ctx;
    const toMs = (s)=> s ? new Date(s.replace(' ', 'T')).getTime() : 0;
    const targetMs = toMs(completeDate);

    // filter: hanya Food & Beverage & status sesuai preferensi (1=complete, 0=aktif)
    const cand = txList.filter(t =>
      (t?.type === 'Food & Beverage') &&
      (Number(t?.is_complete) === (preferComplete ? 1 : 0))
      );

    // beri skor
    const scored = cand.map(t => {
      let score = 0;
      if (fnbItems && (t.name||'').toLowerCase().includes(fnbItems.toLowerCase())) score += 40;
      if (bookingCode && t.booking_code === bookingCode) score += 30;
      if (orderId && String(t.order_id) === String(orderId)) score += 25;
      if (totalAmount && Number(t.amount) <= Number(totalAmount)) score += 5;
      const dtMs = toMs(t.transaction_date_time);
      if (targetMs && dtMs) {
        const diff = Math.abs(dtMs - targetMs);
        // makin dekat makin tinggi
        if (diff < 60_000) score += 30;
        else if (diff < 3*60_000) score += 20;
        else if (diff < 10*60_000) score += 10;
      }
      return { t, score };
    });

    scored.sort((a,b)=> b.score - a.score || toMs(b.t.transaction_date_time) - toMs(a.t.transaction_date_time));
    return scored[0]?.t || null;
  }

  function statusLabelFromResult(result, orderSnapshot){
    if (result === 'success') return 'LUNAS';
    if (result === 'canceled') return 'DIBATALKAN';
    if (result === 'expired') return 'EXPIRED';
    if (orderSnapshot?.complete_date) return 'LUNAS';
    return 'BELUM LUNAS';
  }



  // ---------- API FUNCTIONS ----------
  async function readAccountsFromJson(path) {
    try {
      const raw = await fs.readFile(path,'utf-8');
      const j = JSON.parse(raw);
      const items = Array.isArray(j?.items) ? j.items : [];
      return items.filter(it => it?.email);
    } catch { return []; }
  }

async function ensureBearerForAccount(acc, opts = {}) {
  const { forceRefresh = false } = opts;

  // kalau sudah ada bearer dan tidak dipaksa refresh â†’ pakai ini
  if (!forceRefresh && acc?.bearer) {
    return { ok: true, token: acc.bearer, source: 'account.json' };
  }

  // DI SINI: panggil fungsi login / refresh token-mu
  if (typeof loginCgvWithPassword === 'function' && acc?.email && acc?.password) {
    const loginRes = await loginCgvWithPassword(acc.email, acc.password);
    if (loginRes?.token) {
      // optional: simpan balik ke account.json
      acc.bearer = loginRes.token;
      // ... write file kalau mau
      return { ok: true, token: loginRes.token, source: 'login_refresh' };
    }
  }

  return { ok: false, reason: 'Bearer tidak tersedia dan refresh gagal.' };
}


  function redactHeaders(h){
    const out = { ...(h||{}) };
    if (out.Authorization) out.Authorization = `Bearer ${maskToken(String(out.Authorization).replace(/^Bearer\s+/i,''))}`;
    if (out.authorization) out.authorization = `Bearer ${maskToken(String(out.authorization).replace(/^Bearer\s+/i,''))}`;
    return out;
  }

  function getRandomUA() {
    const seeds = [
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/124.0 Safari/537.36',
      'Mozilla/5.0 (Linux; Android 13; Pixel 6) AppleWebKit/537.36 Chrome/124.0 Mobile Safari/537.36',
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 14_5) AppleWebKit/605.1.15 Version/17.4 Safari/605.1.15',
    ];
    return seeds[Math.floor(Math.random()*seeds.length)];
  }
  
  function getRandomLang(){ return Math.random() < 0.85 ? 'id-ID,id;q=0.9' : 'en-US,en;q=0.9'; }
  
  function generateRandomHeaders(extra={}) {
    return {
      accept: 'application/json, text/plain, */*',
      'accept-encoding': 'gzip',
      'user-agent': getRandomUA(),
      'accept-language': getRandomLang(),
      ...extra,
    };
  }

  async function requestJson(method, url, { headers={}, body, note='' } = {}) {
    const hdrs = generateRandomHeaders(headers);
    let status = 0;
    let text = '';
    let json = null;
    try {
      const res = await fetch(url, {
        method,
        headers: hdrs,
        body,
        ...proxyFetchOpts(),   // â† inject proxy runtime di sini
      });
      status = res.status;
      if (note) log.http(method, url, status, note);
      try { text = await res.text(); } catch { text = ''; }
      try { json = text ? JSON.parse(text) : null; } catch { json = null; }
      await appendJsonLog({
        http: { method, url, status },
        request: { headers: redactHeaders(hdrs), body: (typeof body==='string' && body.length<2048) ? body : (body? '[[binary or long body]]' : '') },
        response: { text: text?.slice?.(0, 100000) }
      });
      return { json, status, text };
    } catch (e) {
      await appendJsonLog({
        http: { method, url, status: 0 },
        request: { headers: redactHeaders(hdrs), body: (typeof body==='string' && body.length<2048) ? body : (body? '[[binary or long body]]' : '') },
        response: { error: String(e?.message||e) }
      });
      log.error(`${method} ${url} failed: ${e.message}`);
      return { json: null, status: 0, text: '', error: e };
    }
  }



  async function fetchCinemas(token) {
    const url = `${baseURL}/api/cinemas`;
    const { json } = await requestJson('GET', url, {
      headers: { Authorization: `Bearer ${token}` }
    });
    return json || { status_code: 500, data: [] };
  }

  async function fetchFnbCategories(cinemaId, token) {
    const url = `${baseURL}/api/conce-category?cinema_id=${cinemaId}`;
    const { json } = await requestJson('GET', url, {
      headers: { Authorization: `Bearer ${token}` }
    });
    return json || { status_code: 500, data: [] };
  }

  async function fetchFnbItems(cinemaId, saleDate, categoryId, token) {
    const url = `${baseURL}/api/conce?cinema_id=${cinemaId}&sale_date=${saleDate}&category_id=${categoryId}`;
    const { json } = await requestJson('GET', url, {
      headers: { Authorization: `Bearer ${token}` }
    });
    return json || { status_code: 500, data: [] };
  }

  async function fetchItemCustomization(cinemaId, conceId, saleDate, token) {
    const url = `${baseURL}/api/conce-item`;
    
    const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
    const parts = [];
    
    const fields = {
      cinema_id: String(cinemaId),
      conce_id: String(conceId),
      sale_date: String(saleDate)
    };
    
    Object.entries(fields).forEach(([k,v])=>{
      parts.push(`--${boundary}`);
      parts.push(`Content-Disposition: form-data; name="${k}"`);
      parts.push('');
      parts.push(v);
    });
    parts.push(`--${boundary}--`);
    const body = parts.join('\r\n');
    
    const { json } = await requestJson('POST', url, {
      headers: { 
        Authorization: `Bearer ${token}`,
        'content-type': `multipart/form-data; boundary=${boundary}`
      },
      body
    });
    return json || { status_code: 500, data: [] };
  }

  async function bookFnb(payload, token) {
    const url = `${baseURL}/api/conce/book`;
    const { json } = await requestJson('POST', url, {
      headers: { 
        Authorization: `Bearer ${token}`,
        'content-type': 'application/json'
      },
      body: JSON.stringify(payload)
    });
    return json || { status_code: 500, data: null };
  }

  // Coupon API functions
  async function couponSelect(orderId, token) {
    const url = `${baseURL}/api/orders/coupon/select`;
    const payload = { order_id: Number(orderId) };
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': 'application/json' },
      body: JSON.stringify(payload)
    });
    return json || { status_code: 500, data: null };
  }

  async function couponValidate(orderId, discountCode, couponNumber, token) {
    const url = `${baseURL}/api/orders/coupon/validate`;
    const payload = { 
      order_id: Number(orderId), 
      coupon_number: couponNumber || '', 
      discount_code: discountCode || '' 
    };
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': 'application/json' },
      body: JSON.stringify(payload)
    });
    return json || { status_code: 500, data: null };
  }

  async function couponPay(orderId, discountCode, couponNumber, token) {
    const url = `${baseURL}/api/orders/coupon/pay`;
    const payload = { 
      order_id: Number(orderId), 
      coupon_number: couponNumber || '', 
      discount_code: discountCode || '' 
    };
    const { json } = await requestJson('POST', url, {
      headers: { Authorization: `Bearer ${token}`, 'content-type': 'application/json' },
      body: JSON.stringify(payload)
    });
    return json || { status_code: 500, data: null };
  }

  async function fetchPaymentMethods(token) {
    const url = `${baseURL}/api/payments`;
    const { json } = await requestJson('GET', url, {
      headers: { Authorization: `Bearer ${token}` }
    });
    return json || { status_code: 500, data: [] };
  }

  async function paymentPartnerSelect(orderId, categoryId, paymentId, token, extraFields = {}) {
    const url = `${baseURL}/api/orders/payment-partners/select`;
    const fields = {
      order_id: String(orderId),
      category_id: String(categoryId),
      payment_id: String(paymentId),
      ...extraFields
    };
    
    const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
    const parts = [];
    Object.entries(fields).forEach(([k,v])=>{
      const val = String(v ?? '');
      parts.push(`--${boundary}`);
      parts.push(`Content-Disposition: form-data; name="${k}"`);
      parts.push('');
      parts.push(val);
    });
    parts.push(`--${boundary}--`);
    const body = parts.join('\r\n');
    
    const { json } = await requestJson('POST', url, {
      headers: { 
        Authorization: `Bearer ${token}`, 
        'content-type': `multipart/form-data; boundary=${boundary}` 
      },
      body
    });
    return json || { status_code: 500, data: null };
  }

  async function paymentPartnerPay(orderId, token) {
    const url = `${baseURL}/api/orders/payment-partners/pay`;
    const fields = { order_id: String(orderId) };
    
    const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
    const parts = [];
    Object.entries(fields).forEach(([k,v])=>{
      const val = String(v ?? '');
      parts.push(`--${boundary}`);
      parts.push(`Content-Disposition: form-data; name="${k}"`);
      parts.push('');
      parts.push(val);
    });
    parts.push(`--${boundary}--`);
    const body = parts.join('\r\n');
    
    const { json } = await requestJson('POST', url, {
      headers: { 
        Authorization: `Bearer ${token}`, 
        'content-type': `multipart/form-data; boundary=${boundary}` 
      },
      body
    });
    return json || { status_code: 500, data: null };
  }

  async function cancelOrder(orderId, token) {
    const url = `${baseURL}/api/orders/cancel`;
    const fields = { order_id: String(orderId) };
    
    const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
    const parts = [];
    Object.entries(fields).forEach(([k,v])=>{
      const val = String(v ?? '');
      parts.push(`--${boundary}`);
      parts.push(`Content-Disposition: form-data; name="${k}"`);
      parts.push('');
      parts.push(val);
    });
    parts.push(`--${boundary}--`);
    const body = parts.join('\r\n');
    
    const { json } = await requestJson('POST', url, {
      headers: { 
        Authorization: `Bearer ${token}`, 
        'content-type': `multipart/form-data; boundary=${boundary}` 
      },
      body
    });
    return json || { status_code: 500, data: null };
  }

// === [TAMBAHAN BARU] CGV POINT â€” API helper minimal ===
async function cgvPointSelect(orderId, token) {
  const url = `${baseURL}/api/orders/cgv-point/select`;
  const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  const parts = [];
  parts.push(`--${boundary}`);
  parts.push(`Content-Disposition: form-data; name="order_id"`);
  parts.push('');
  parts.push(String(orderId));
  parts.push(`--${boundary}--`);
  const body = parts.join('\r\n');

  const { json } = await requestJson('POST', url, {
    headers: {
      Authorization: `Bearer ${token}`,
      'content-type': `multipart/form-data; boundary=${boundary}`
    },
    body,
    note: 'cgv-point-select'
  });
  return json || { status_code: 500, data: null };
}

async function cgvPointPay(orderId, fields, token) {
  const url = `${baseURL}/api/orders/cgv-point/pay`;
  const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  const parts = [];
  const payload = {
    order_id: String(orderId),
    pin: String(fields.pin || ''),
    member_grade_id: String(fields.member_grade_id || '03'),
    member_tier_id:  String(fields.member_tier_id  || '03'),
    customer_name:    String(fields.customer_name   || ''),
    customer_phone:   String(fields.customer_phone  || ''),
    customer_email:   String(fields.customer_email  || ''),
    customer_address: String(fields.customer_address|| ''),
    customer_city:    String(fields.customer_city   || ''),
    customer_post_code: String(fields.customer_post_code || '')
  };
  Object.entries(payload).forEach(([k,v])=>{
    parts.push(`--${boundary}`);
    parts.push(`Content-Disposition: form-data; name="${k}"`);
    parts.push('');
    parts.push(v);
  });
  parts.push(`--${boundary}--`);
  const body = parts.join('\r\n');

  const { json } = await requestJson('POST', url, {
    headers: {
      Authorization: `Bearer ${token}`,
      'content-type': `multipart/form-data; boundary=${boundary}`
    },
    body,
    note: 'cgv-point-pay'
  });
  return json || { status_code: 500, data: null };
}

// ğŸ” Tambahan: cek saldo CGV Point (coba beberapa endpoint umum; fallback aman)
function extractPointFromJson(j){
  let best = null;
  const stack = [j];
  while (stack.length){
    const o = stack.pop();
    if (!o || typeof o !== 'object') continue;
    for (const [k,v] of Object.entries(o)){
      if (typeof v === 'number' && /point|poin|balance/i.test(k)) {
        if (best == null || v > best) best = v;
      } else if (v && typeof v === 'object') {
        stack.push(v);
      }
    }
  }
  return best;
}

async function fetchCgvPointBalance(token) {
  const endpoints = [
    `${baseURL}/api/membership/profile`,
    `${baseURL}/api/membership/point`,
    `${baseURL}/api/membership/points`,
    `${baseURL}/api/membership/me`
  ];
  for (const url of endpoints) {
    const { json } = await requestJson('GET', url, {
      headers: { Authorization: `Bearer ${token}` },
      note: 'cgv-point-balance'
    });
    if (json && (json.status_code === 200 || String(json.message||'').toUpperCase() === 'OK')) {
      const bal = extractPointFromJson(json);
      if (typeof bal === 'number') {
        await appendJsonLog({ event: 'cgv_point_balance_ok', source: url, balance: bal });
        return { ok:true, balance: bal, source: url, raw: json };
      }
    }
  }
  await appendJsonLog({ event: 'cgv_point_balance_unknown' });
  return { ok:false, balance: null };
}

// === Wrapper satu pintu ===
async function launchBrowser({ label = 'Automation', ...launchOpts } = {}) {
  await waitForSameBrowserFree({ label });
  const puppeteer = (await import('puppeteer')).default;
  return puppeteer.launch(launchOpts);
}

  async function openExternalUrl(url) {
    if (!url) return { ok:false, reason:'empty_url' };
    try {
      try {
        const openMod = (await import('open')).default;
        await openMod(url, { wait:false });
        return { ok:true, via:'open' };
      } catch {}
      
      const { spawn } = await import('child_process');
      const platform = process.platform;
      let cmd, args;
      if (platform === 'darwin') { cmd='open'; args=[url]; }
      else if (platform === 'win32') { cmd='cmd'; args=['/c','start','',url]; }
      else { cmd='xdg-open'; args=[url]; }
      const child = spawn(cmd, args, { stdio:'ignore', detached:true });
      child.unref();
      return { ok:true, via:cmd };
    } catch (e) {
      return { ok:false, reason:e?.message || 'unknown' };
    }
  }


  // --- Order & Transactions Monitoring ---
  async function fetchOrderDetail(orderId, token){
    const url = `${baseURL}/api/orders/${encodeURIComponent(orderId)}`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: null };
  }
  
  async function fetchMembershipTransactions(token){
    const url = `${baseURL}/api/membership/transactions`;
    const { json } = await requestJson('GET', url, { headers: { Authorization: `Bearer ${token}` } });
    return json || { status_code: 500, message: 'Invalid JSON', data: [] };
  }

  // ---------- API TICKET DETAIL ----------
  async function fetchTicketDetail(salesId, token) {
    const url = `${baseURL}/api/membership/tickets/${encodeURIComponent(salesId)}`;
    const { json } = await requestJson('GET', url, {
      headers: { Authorization: `Bearer ${token}` }
    });
    return json || { status_code: 500, data: null };
  }

  // ======== RENDER RINGKASAN LENGKAP F&B ========
  function renderFullFnbOrderSummaryBox(orderObj, cartItems, cinema, account, statusText = 'Pembayaran Diproses') {
    const o = orderObj || {};
    console.log();
    log.section('ğŸ“‹ RINGKASAN LENGKAP PESANAN F&B');
    console.log(chalk.cyan('â•­' + 'â”€'.repeat(80) + 'â•®'));
    console.log(chalk.cyan('â”‚') + chalk.white.bold('                        DETAIL PESANAN F&B LENGKAP                    ') + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”œ' + 'â”€'.repeat(80) + 'â”¤'));
    console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Akun Email')}      : ${String(account.email||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Bioskop')}        : ${String(cinema.name||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Lokasi')}         : ${String(cinema.location_name||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Alamat')}         : ${String(cinema.address||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('F&B Items')}      : ${String(cartItems.length + ' items').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    const itemNames = cartItems.map(c => `${c.name} (${c.quantity}x)`).join(', ');
    console.log(chalk.cyan('â”‚') + ` ${chalk.yellow('Detail Items')}   : ${itemNames.slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”œ' + 'â”€'.repeat(80) + 'â”¤'));
    console.log(chalk.cyan('â”‚') + ` ${chalk.green('Order ID')}       : ${String(o.id||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”‚') + ` ${chalk.green('Booking Code')}   : ${String(o.booking_code||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”‚') + ` ${chalk.green('Total Bayar')}    : ${toRp(o.total_amount||0).slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”‚') + ` ${chalk.green('Voucher')}        : ${(o.discount_code ? `${o.discount_code} - ${o.discount_name||''}` : 'Tidak Ada').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”‚') + ` ${chalk.green('Diskon')}         : ${(o.discount_value ? toRp(o.discount_value) : 'Rp0').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”‚') + ` ${chalk.red('Expire Time')}    : ${String(o.expired_date||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â”‚') + ` ${chalk.blue('Status')}         : ${String(statusText||'-').slice(0,50).padEnd(50)} ${chalk.cyan('â”‚')}`);
    console.log(chalk.cyan('â•°' + 'â”€'.repeat(80) + 'â•¯'));
  }

async function monitorFnbPaymentLoop({
  orderId,
  token,
  methodLabel='(unknown)',
  fnbItems='',
  intervalSec=1,
  confirmEverySec=60,
  initialRapidSec=20,
  rapidIntervalSec=1,
  selectedAccount=null
}){

  log.section('ğŸ“¡ MONITORING PEMBAYARAN F&B');
  console.log(chalk.gray('â–¶ Monitoring otomatis tanpa prompt. Tekan Ctrl+C untuk membatalkan pesanan.'));
  
  console.log(chalk.cyan('â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
  console.log(chalk.cyan('â”‚') + chalk.white.bold('                   MONITORING PEMBAYARAN F&B               ') + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
  console.log(chalk.cyan('â”‚') + ` ğŸ« Order ID  : ${String(orderId).padEnd(40)} ` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + ` ğŸ¿ F&B Items : ${fnbItems.slice(0,40).padEnd(40)} ` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + ` ğŸ’³ Metode    : ${methodLabel.padEnd(40)} ` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
  console.log(chalk.cyan('â”‚') + chalk.gray(' Check: 0.1s (cepat) | Error: 1s (backoff) | Log: 1s      ') + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n'));

  // âœ… SEMUA VARIABLE SUDAH DIDEFINISIKAN
  let done = false;
  let canceled = false;
  let noResponseCount = 0;
  let finalStatus = 'pending';
  let finalSnapshot = null;
  let lastLogTime = 0;
  let consecutiveErrors = 0;
  let currentInterval = intervalSec;

  let cur = (await fetchOrderDetail(orderId, token))?.data || {};
  let expUtc = parseUtcish(cur?.expired_date_utc) || parseUtcish(cur?.expired_date);

// âŒ¨ï¸ Ctrl+C â†’ auto cancel order
let sigintOnce = false;
const onSigint = async () => {
  if (sigintOnce) return;
  sigintOnce = true;
  console.log(chalk.yellow('\nğŸ›‘ Ctrl+C terdeteksi â€” membatalkan pesanan...'));

  // Set flags IMMEDIATELY to stop tick() loop
  canceled = true;
  done = true;

  try {
    // Retry loop untuk cancel order sampai sukses
    const maxRetries = 10;
    const retryDelay = 2000; // 2 detik
    let cancelSuccess = false;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const r = await cancelOrder(orderId, token);
        if (r?.status_code === 200) {
          console.log(chalk.green('âœ… Order berhasil dibatalkan.'));
          cancelSuccess = true;

          // ğŸ”„ Hapus pesan tracking di Telegram juga (pakai helper clear)
          await clearFnbTelegramPaymentMessage('canceled', { id: orderId });
          break; // Sukses, keluar dari loop
        } else {
          const errMsg = r?.message || 'Unknown error';
          console.log(chalk.red(`âŒ Gagal batalkan order (attempt ${attempt}/${maxRetries}): ${errMsg}`));

          if (attempt < maxRetries) {
            console.log(chalk.yellow(`â³ Retry dalam ${retryDelay/1000} detik...`));
            await new Promise(resolve => setTimeout(resolve, retryDelay));
          }
        }
      } catch (e) {
        console.log(chalk.red(`âŒ Cancel error (attempt ${attempt}/${maxRetries}): ${e.message}`));

        if (attempt < maxRetries) {
          console.log(chalk.yellow(`â³ Retry dalam ${retryDelay/1000} detik...`));
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
      }
    }

    if (!cancelSuccess) {
      console.log(chalk.red(`âŒ Gagal batalkan order setelah ${maxRetries} percobaan. Order mungkin expire otomatis.`));
    }
  } catch (e) {
    console.log(chalk.red(`âŒ Critical cancel error: ${e.message}`));
  } finally {
    try { process.off('SIGINT', onSigint); } catch {}
    try { process.off('SIGTERM', onSigint); } catch {}
    process.exit(130); // tetap pakai exit code SIGINT
  }
};

process.on('SIGINT', onSigint);
process.on('SIGTERM', onSigint);


  const tick = async () => {
    return await safeExecute(async () => {
      // Skip fetch jika sudah canceled atau done
      if (canceled || done) {
        return;
      }

      const res = await fetchOrderDetail(orderId, token);
      let orderFound = false;

      if (res?.status_code === 200) {
        cur = res.data || cur;
        noResponseCount = 0; // âœ… RESET COUNTER ON SUCCESS
        consecutiveErrors = 0; // âœ… RESET ERROR BACKOFF
        currentInterval = intervalSec; // âœ… RESET TO FAST INTERVAL
      } else {
        noResponseCount++; // âœ… INCREMENT ON FAILURE
        consecutiveErrors++; // âœ… INCREMENT ERROR COUNTER

        // Adaptive backoff: switch to 1 second on error
        if (consecutiveErrors >= 2) {
          currentInterval = 1.0; // Backoff to 1 second
        }

        console.log(chalk.yellow(`âš ï¸  Order detail tidak dapat diambil (attempt ${noResponseCount})`));
        
        // Fallback: cek transaction history jika gagal get order detail
        if (noResponseCount >= 3) {
          console.log(chalk.cyan('ğŸ”„ Fallback: Checking transaction history...'));
          
          const tx = await fetchMembershipTransactions(token);
          if (tx?.status_code === 200 && Array.isArray(tx.data)) {
            // Cari transaksi F&B terbaru yang match dengan timeline
            const recentFnb = tx.data.filter(t => 
              t.type === 'Food & Beverage' && 
              t.transaction_date_time &&
              new Date(t.transaction_date_time + '+07:00').getTime() >= Date.now() - 3600000 // Last 1 hour
            );
            
            if (recentFnb.length > 0) {
              const latestFnb = recentFnb[0];
              console.log(chalk.green('âœ… Found recent F&B transaction in history!'));
              
              // Simulate completed order from transaction
              cur = {
                id: orderId,
                booking_code: latestFnb.booking_code || `CGV${Date.now()}`,
                complete_date: latestFnb.transaction_date_time,
                payment_method: 'Digital Payment',
                total_amount: latestFnb.amount || 0,
                sales_id: latestFnb.sales_id,
                conces: [{
                  name: latestFnb.name,
                  qty: latestFnb.qty || 1
                }]
              };
              orderFound = true;
              noResponseCount = 0; // âœ… RESET COUNTER WHEN FOUND
              
              console.log(chalk.green(`ğŸ‰ Transaction found: ${latestFnb.name} - ${toRp(latestFnb.amount || 0)}`));
            }
          }
        }
      }

      const tx = await fetchMembershipTransactions(token);
      const txCount = Array.isArray(tx?.data) ? tx.data.length : 0;
      await appendJsonLog({ 
        event: 'fnb_monitor_tick', 
        order_id: orderId, 
        tx_count: txCount, 
        no_response_count: noResponseCount,
        order_found: orderFound,
        order_snapshot: {
          complete_date: cur.complete_date || '',
          payment_method: cur.payment_method || '',
          expired_date: cur.expired_date || '',
          total_amount: cur.total_amount || 0
        }
      });

      if (cur?.complete_date) {
        console.log(chalk.green('\nğŸ‰ PEMBAYARAN F&B BERHASIL DIKONFIRMASI!'));
        console.log(chalk.green(`âœ… Waktu selesai: ${cur.complete_date}`));
        console.log(chalk.green('ğŸ¿ F&B sudah bisa diambil!'));
        
        // Enhanced F&B transaction fetching
        console.log(chalk.cyan('\nğŸ“‹ Mengambil detail pesanan F&B...'));
        
        try {
          // ğŸ”„ PERBAIKAN: Gunakan Sales ID detection yang sama seperti Movie Auto Order
          let salesId = cur?.sales_id || null;
          let fnbTransaction = null;
          
          // Kalau belum ada sales_id dari order, ambil transaksi lalu pilih yang paling relevan
          if (!salesId) {
            const txRes = await fetchMembershipTransactions(token);
            if (txRes?.status_code === 200 && Array.isArray(txRes.data)) {
              const picked = pickRelevantFnbTransaction(
                txRes.data,
                {
                  completeDate: cur.complete_date,
                  orderId: cur.id,
                  bookingCode: cur.booking_code,
                  totalAmount: cur?.total_amount,
                  fnbItems: fnbItems || 'F&B' // dari parameter monitoring
                },
                { preferComplete: true } // âœ… sesudah bayar: cari transaksi complete=1
              );
              salesId = picked?.sales_id || null;
              fnbTransaction = picked;
              
              if (picked) {
                console.log(chalk.green(`âœ… F&B Sales ID ditemukan via pickRelevantFnbTransaction: ${salesId}`));
              }
            }
          } else {
            // Jika sudah ada sales_id, cari transaction detailnya untuk display
            const txRes = await fetchMembershipTransactions(token);
            if (txRes?.status_code === 200 && Array.isArray(txRes.data)) {
              fnbTransaction = txRes.data.find(tx => tx.sales_id === salesId);
            }
          }

          
          if (fnbTransaction && salesId) {
            // âœ… FETCH DETAIL TICKET UNTUK AMBIL PASSKEY & DATA LENGKAP
            console.log(chalk.cyan('\nğŸ“‹ Mengambil detail ticket lengkap...'));
            const ticketDetail = await fetchTicketDetail(salesId, token);
            
            let passKey = null;
            let bookingCodeFromDetail = null;
            let enhancedItemDetails = [];
            
            if (ticketDetail?.status_code === 200 && ticketDetail?.data) {
              const detail = ticketDetail.data;
              passKey = detail.pass_key || detail.passkey || detail.passKey;
              bookingCodeFromDetail = detail.booking_code;
              enhancedItemDetails = detail.conces || [];
              
              console.log(chalk.green(`âœ… Detail ticket berhasil diambil`));
              console.log(chalk.cyan(`ğŸ”‘ Pass Key: ${passKey || 'Not found'}`));
              console.log(chalk.cyan(`ğŸŸï¸  Booking Code: ${bookingCodeFromDetail || 'Not found'}`));
              
              await appendJsonLog({ 
                event: 'fnb_ticket_detail_fetched', 
                sales_id: salesId,
                pass_key: passKey,
                booking_code: bookingCodeFromDetail,
                detail: detail
              });
            } else {
              console.log(chalk.yellow('âš ï¸  Gagal ambil detail ticket, pakai data transaksi saja'));
              await appendJsonLog({ 
                event: 'fnb_ticket_detail_failed', 
                sales_id: salesId,
                response: ticketDetail
              });
            }
            
            // Comprehensive display
            console.log(chalk.green('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
            console.log(chalk.green('â”‚') + chalk.white.bold('                   PESANAN F&B BERHASIL DIKONFIRMASI         ') + chalk.green('â”‚'));
            console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
            console.log(chalk.green('â”‚') + ` ğŸ¿ Item F&B  : ${(fnbTransaction.name || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
            console.log(chalk.green('â”‚') + ` ğŸ¢ Bioskop   : ${(fnbTransaction.cinema_name || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
            console.log(chalk.green('â”‚') + ` ğŸ“… Tanggal   : ${(fnbTransaction.pickup_date || fnbTransaction.transaction_date || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
            console.log(chalk.green('â”‚') + ` â° Waktu     : ${(fnbTransaction.transaction_time || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
            console.log(chalk.green('â”‚') + ` ğŸ“¦ Jumlah    : ${String(fnbTransaction.qty || 1).padEnd(40)} ` + chalk.green('â”‚'));
            console.log(chalk.green('â”‚') + ` ğŸŸï¸  Booking   : ${(bookingCodeFromDetail || cur.booking_code || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
            console.log(chalk.green('â”‚') + ` ğŸ”‘ Pass Key  : ${(passKey || '-').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
            console.log(chalk.green('â”‚') + ` ğŸ†” Sales ID  : ${(salesId || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
            console.log(chalk.green('â”‚') + ` ğŸ’° Total     : ${toRp(cur.total_amount || 0).slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
            console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
            
            // Generate ASCII ticket dengan data lengkap
            const fnbTicketData = {
              fnbItems: fnbTransaction.name,
              cinemaName: fnbTransaction.cinema_name,
              date: fnbTransaction.pickup_date || fnbTransaction.transaction_date,
              bookingCode: bookingCodeFromDetail || cur.booking_code,
              passKey: passKey,  // â† TAMBAH PASSKEY DARI API DETAIL
              salesId: salesId,
              totalAmount: toRp(cur.total_amount || 0),
              itemDetails: enhancedItemDetails.length ? enhancedItemDetails : (cur.conces || []),
              // âœ… TAMBAHKAN account info untuk Telegram
              accountEmail: selectedAccount?.email,
              accountPassword: selectedAccount?.password,
              accountName: selectedAccount?.name
            };

            

            await clearFnbTelegramPaymentMessage('success', cur);


            // âœ… AUTO LOGIN + SCREENSHOT mobile web F&B (SAMA SEPERTI MOVIE)
            try {
              const accForLogin = selectedAccount || {};
              if (salesId && accForLogin?.email && accForLogin?.password) {
                console.log(chalk.cyan('\nğŸŒ Auto login m.cgv.id mobile & screenshot F&B tiket...'));
const sendScreenshotFnb = (process.env.SEND_SCREENSHOT_TO_TELEGRAM_FNB || 'false').toLowerCase() === 'true';
const screenshotResult = await loginAndScreenshotFnbTicket({
  salesId,
  email: accForLogin.email,
  password: accForLogin.password,
  bookingCode: fnbTicketData.bookingCode,
  passKey: fnbTicketData.passKey,
  outDir: 'orders',
  headless: true,
  sendToTelegram: sendScreenshotFnb, // âœ… Gunakan ENV
  accountEmail: accForLogin.email,      // âœ… TAMBAHKAN
  accountPassword: accForLogin.password,// âœ… TAMBAHKAN
  accountName: accForLogin.name,        // âœ… TAMBAHKAN
  fnbItems: fnbTicketData.fnbItems,     // âœ… PASS ITEMS
  fnbDetail: fnbTicketData.itemDetails, // âœ… PASS DETAIL
  customizations: (Array.isArray(lastFnbCartSnapshot) && lastFnbCartSnapshot.length && lastFnbCartSnapshot[0].customizations) || [],  // âœ… PRIORITAS lastFnbCartSnapshot user choices (enhancedItemDetails tidak punya custom names)
  cinemaName: fnbTicketData.cinemaName  // âœ… PASS CINEMA NAME
});

                
                if (screenshotResult.success) {
                  console.log(chalk.green(`ğŸ“¸ Screenshot berhasil: ${screenshotResult.path}`));
                  await appendJsonLog({ 
                    event: 'fnb_mobile_screenshot_success', 
                    file: screenshotResult.path,
                    sales_id: salesId,
                    booking_code: fnbTicketData.bookingCode
                  });
                } else {
                  console.log(chalk.yellow(`âš ï¸ Screenshot gagal: ${screenshotResult.error}`));
                  await appendJsonLog({ 
                    event: 'fnb_mobile_screenshot_failed', 
                    error: screenshotResult.error,
                    sales_id: salesId
                  });
                }
              } else {
                console.log(chalk.yellow('â„¹ï¸ Skip screenshot (butuh salesId + email + password).'));
              }
            } catch (e) {
              console.log(chalk.red(`âŒ Screenshot error: ${e.message}`));
              await appendJsonLog({ 
                event: 'fnb_mobile_screenshot_error', 
                error: e.message,
                sales_id: salesId
              });
            }
            
            // Send to Telegram with QR Code
            const sendQrCodeFnb = (process.env.SEND_QR_TO_TELEGRAM_FNB || 'false').toLowerCase() === 'true';
            await sendFnBOrderWithQR(fnbTicketData, { sendToTelegram: sendQrCodeFnb });
            if (sendQrCodeFnb) {
              console.log(chalk.green('ğŸ“± F&B QR code sent to Telegram!'));
            }

            
          } else {
            console.log(chalk.yellow('âš ï¸  Tidak dapat mengambil detail tiket F&B, menggunakan data order saja'));
            
// ğŸ”„ PERBAIKAN: Tetap coba cari Sales ID yang benar untuk fallback
let fallbackSalesId = cur.sales_id || null;
if (!fallbackSalesId) {
  try {
    const txRes = await fetchMembershipTransactions(token);
    const picked = pickRelevantFnbTransaction(
      txRes?.data || [],
      {
        completeDate: cur.complete_date,
        orderId: cur.id,
        bookingCode: cur.booking_code,
        totalAmount: cur?.total_amount,
        fnbItems: fnbItems
      },
      { preferComplete: true }
    );
    fallbackSalesId = picked?.sales_id || null;

    if (fallbackSalesId) {
      console.log(chalk.green(`âœ… Fallback Sales ID (from transactions): ${fallbackSalesId}`));
    } else {
      console.log(chalk.yellow('âš ï¸ Tidak menemukan sales_id untuk fallback, lanjut tanpa sales_id.'));
    }
  } catch (e) {
    console.log(chalk.yellow(`âš ï¸ Error mencari fallback Sales ID: ${e.message}`));
    fallbackSalesId = null; // JANGAN pake order.id lagi
  }
}


            const fallbackTicketData = {
              fnbItems: fnbItems || 'F&B Order',
              cinemaName: 'CGV Cinema',
              date: cur.complete_date?.split(' ')[0] || todayYmd(),
              bookingCode: cur.booking_code,
              passKey: cur.pass_key || '',
              salesId: fallbackSalesId,
              totalAmount: toRp(cur.total_amount || 0),
              itemDetails: cur.conces || [],
              // âœ… TAMBAHKAN account info untuk Telegram
              accountEmail: selectedAccount?.email,
              accountPassword: selectedAccount?.password,
              accountName: selectedAccount?.name
            };
            

            // Screenshot dengan Sales ID yang benar
            try {
              const accForLogin = selectedAccount || {};
              if (fallbackSalesId && accForLogin?.email && accForLogin?.password) {
                console.log(chalk.cyan('\nğŸŒ Auto login m.cgv.id mobile & screenshot F&B tiket (fallback)...'));

// Check env untuk send screenshot ke Telegram
const sendScreenshotFnb = (process.env.SEND_SCREENSHOT_TO_TELEGRAM_FNB || 'false').toLowerCase() === 'true';

const screenshotResult = await loginAndScreenshotFnbTicket({
  salesId,
  email: accForLogin.email,
  password: accForLogin.password,
  bookingCode: fnbTicketData.bookingCode,
  passKey: fnbTicketData.passKey,
  outDir: 'orders',
  headless: true,
  sendToTelegram: sendScreenshotFnb, // âœ… USE ENV VARIABLE
  accountEmail: accForLogin.email,      // âœ… TAMBAHKAN
  accountPassword: accForLogin.password,// âœ… TAMBAHKAN
  accountName: accForLogin.name,        // âœ… TAMBAHKAN
  fnbItems: fnbTicketData.fnbItems,     // âœ… PASS ITEMS
  fnbDetail: fnbTicketData.itemDetails, // âœ… PASS DETAIL
  customizations: (Array.isArray(lastFnbCartSnapshot) && lastFnbCartSnapshot.length && lastFnbCartSnapshot[0].customizations) || [],  // âœ… PRIORITAS lastFnbCartSnapshot user choices
  cinemaName: fnbTicketData.cinemaName  // âœ… PASS CINEMA NAME
});

                
                if (screenshotResult.success) {
                  console.log(chalk.green(`ğŸ“¸ Screenshot berhasil: ${screenshotResult.path}`));
                  await appendJsonLog({ 
                    event: 'fnb_mobile_screenshot_success', 
                    file: screenshotResult.path,
                    sales_id: fallbackSalesId,
                    booking_code: fallbackTicketData.bookingCode
                  });
                } else {
                  console.log(chalk.yellow(`âš ï¸ Screenshot gagal: ${screenshotResult.error}`));
                  await appendJsonLog({ 
                    event: 'fnb_mobile_screenshot_failed', 
                    error: screenshotResult.error,
                    sales_id: fallbackSalesId
                  });
                }
              } else {
                console.log(chalk.yellow('â„¹ï¸ Skip screenshot (butuh salesId + email + password).'));
              }
            } catch (e) {
              console.log(chalk.red(`âŒ Screenshot error: ${e.message}`));
              await appendJsonLog({ 
                event: 'fnb_mobile_screenshot_error', 
                error: e.message,
                sales_id: fallbackSalesId
              });
            }
            
            // Send fallback to Telegram
            const telegramFallback = generateTelegramTicket(fallbackTicketData, 'fnb');
            await sendTelegramMessage(telegramFallback);
            
            console.log(chalk.green('ğŸ“± Fallback F&B receipt sent to Telegram!'));
          }

          
        } catch (fnbError) {
          console.log(chalk.yellow(`âš ï¸  Error detail F&B: ${fnbError.message}`));
          
          // Emergency Telegram notification
          const errorMsg = `ğŸš¨ <b>F&B ORDER ERROR</b>\n\n` +
            `Order ID: <code>${orderId}</code>\n` +
            `Error: <code>${fnbError.message}</code>\n` +
            `Time: ${new Date().toLocaleString('id-ID')}\n\n` +
            `Booking: <code>${cur.booking_code || 'Unknown'}</code>\n` +
            `Total: ${toRp(cur.total_amount || 0)}`;
          
          await sendTelegramMessage(errorMsg);
        }
        
        done = true; return;
      }

      expUtc = parseUtcish(cur?.expired_date_utc) || parseUtcish(cur?.expired_date);
      const now = new Date();
     if (expUtc && now > expUtc) {
  console.log(chalk.red('\nâ° WAKTU PEMBAYARAN F&B HABIS'));
  
  // Send expiry notification to Telegram
  const expiryMsg = `â° <b>F&B ORDER EXPIRED</b>\n\n` +
    `Order ID: <code>${orderId}</code>\n` +
    `Items: ${fnbItems}\n` +
    `Expired: ${cur.expired_date || 'Unknown'}\n` +
    `Time: ${new Date().toLocaleString('id-ID')}`;
  
  await sendTelegramMessage(expiryMsg);

  // ğŸ”„ Bersihkan pesan payment-init di Telegram
  await clearFnbTelegramPaymentMessage('expired', cur);

  done = true;
  return;
}


      const remainStr = expUtc ? formatRemaining(expUtc - now) : '-';

      // Throttle log output: hanya print setiap 1 detik
      const currentTime = Date.now();
      if (currentTime - lastLogTime >= 1000) {
        console.log(chalk.blue(`â³ Menunggu konfirmasi pembayaran F&B... (sisa waktu: ${chalk.white(remainStr)})`));
        lastLogTime = currentTime;
      }
    }, 'fnb_monitor_tick');
  };

  await tick();

  const rapidUntil = Date.now() + initialRapidSec * 1000;
  while (!done) {
    const now = Date.now();
    const isRapid = now < rapidUntil;

    // Adaptive interval: gunakan currentInterval yang bisa berubah jika ada error
    const delayMs = Math.max(100, currentInterval * 1000);

    // Safe delay execution
    try {
      await globalThis.delay(delayMs);
    } catch (delayError) {
      // Fallback delay jika globalThis.delay tidak ada
      await new Promise(r => setTimeout(r, delayMs));
    }

    await tick();
    if (done) break;
  }

  // bersihkan listener sinyal jika keluar normal (tanpa Ctrl+C)
  try { process.off('SIGINT', onSigint); process.off('SIGTERM', onSigint); } catch {}

  // Final check dengan enhanced fallback
  try {
    // Skip final fetch jika sudah canceled atau expired
    if (canceled) {
      finalSnapshot = cur;
      finalStatus = 'canceled';
    } else if (done && expUtc && new Date() > expUtc) {
      finalSnapshot = cur;
      finalStatus = 'expired';
    } else {
      const final = await fetchOrderDetail(orderId, token);
      if (final?.status_code === 200) {
        finalSnapshot = final.data || cur;
      } else {
        // Ultimate fallback: check recent transactions
        console.log(chalk.cyan('ğŸ”„ Final fallback: Checking all recent transactions...'));
        const tx = await fetchMembershipTransactions(token);
      if (tx?.status_code === 200 && Array.isArray(tx.data)) {
        const recentFnb = tx.data.filter(t => 
          t.type === 'Food & Beverage' && 
          t.transaction_date_time &&
          new Date(t.transaction_date_time + '+07:00').getTime() >= Date.now() - 7200000 // Last 2 hours
        );
        
        if (recentFnb.length > 0) {
          const latestFnb = recentFnb[0];
          finalSnapshot = {
            ...cur,
            complete_date: latestFnb.transaction_date_time,
            sales_id: latestFnb.sales_id,
            booking_code: latestFnb.booking_code || cur.booking_code
          };
          console.log(chalk.green('âœ… Final status determined from transaction history'));
        }
      }
      }
    }

    if (finalSnapshot?.complete_date) {
      finalStatus = 'success';
    } else {
      const exp = parseUtcish(finalSnapshot?.expired_date_utc) || parseUtcish(finalSnapshot?.expired_date);
      finalStatus = (exp && new Date() > exp) ? 'expired' : (canceled ? 'canceled' : 'pending');
    }
  } catch (finalError) {
    console.log(chalk.yellow(`âš ï¸  Final check error: ${finalError.message}`));
    finalStatus = canceled ? 'canceled' : 'pending';
  }

  return { status: canceled ? 'canceled' : finalStatus, order: finalSnapshot };
}





  // ---------- RENDER FUNCTIONS ----------
  function renderAccountTable(accounts) {
    const t = new CliTable({
      head: ['#','Email','Phone','Bearer'],
      wordWrap: true,
      style: { head: ['green'] },
      colWidths: [4, 35, 15, 10]
    });

    accounts.forEach((acc, i) => {
      const phoneDisplay = acc.phone ? chalk.cyan(acc.phone) : chalk.gray('-');
      t.push([
        chalk.white.bold(i+1),
        acc.email,
        phoneDisplay,
        acc.bearer ? chalk.green('YES') : chalk.red('NO')
      ]);
    });
    console.log(t.toString());
  }


  function renderCinemaTable(cinemas, highlightQuery = '') {
    const t = new CliTable({
      head: ['#','Cinema Name','Location','Address'],
      wordWrap: true,
      style: { head: ['cyan'] },
      colWidths: [4, 25, 15, 45]
    });

    cinemas.forEach((cinema, i) => {
      let cinemaName = cinema.name;
      let locationName = cinema.location_name;
      
      // Highlight search query if provided
      if (highlightQuery) {
        const query = highlightQuery.toLowerCase();
        const namePos = cinema.name.toLowerCase().indexOf(query);
        const locPos = cinema.location_name.toLowerCase().indexOf(query);
        
        if (namePos >= 0) {
          cinemaName = cinema.name.slice(0, namePos) + 
                      chalk.bgYellow.black(cinema.name.slice(namePos, namePos + query.length)) + 
                      cinema.name.slice(namePos + query.length);
        }
        
        if (locPos >= 0) {
          locationName = cinema.location_name.slice(0, locPos) + 
                        chalk.bgYellow.black(cinema.location_name.slice(locPos, locPos + query.length)) + 
                        cinema.location_name.slice(locPos + query.length);
        }
      }
      
      t.push([
        chalk.white.bold(i+1),
        cinemaName,
        locationName,
        cinema.address || '-'
      ]);
    });
    console.log(t.toString());
  }


  function renderFnbCategoriesTable(categories) {
    const t = new CliTable({
      head: ['#','Category Name','Description','Status','ID'],
      wordWrap: true,
      style: { head: ['yellow'] },
      colWidths: [4, 20, 35, 12, 10]
    });

    categories.forEach((cat, i) => {
      // Check multiple possible status fields
      let statusColor;
      const statusField = cat.status || cat.is_active || cat.active || cat.available;
      
      if (statusField === true || statusField === 'true' || statusField === 1 || statusField === '1' || statusField === 'ACTIVE') {
        statusColor = chalk.green('âœ… BUKA');
      } else if (statusField === false || statusField === 'false' || statusField === 0 || statusField === '0' || statusField === 'INACTIVE') {
        statusColor = chalk.red('âŒ TUTUP');
      } else {
        // Unknown status - assume available but warn
        statusColor = chalk.yellow('âš ï¸ UNKNOWN');
      }
      
      const desc = cat.description || cat.name || '-';
      
      t.push([
        chalk.white.bold(i+1),
        chalk.cyan(cat.name),
        chalk.gray(desc),
        statusColor,
        chalk.yellow(cat.conce_category_id)
      ]);
    });
    console.log(t.toString());
    
    // Show debug info for first category
    if (categories.length > 0) {
      console.log(chalk.gray('\nğŸ” Status Debug Info (kategori pertama):'));
      const firstCat = categories[0];
      console.log(chalk.gray(`   â€¢ status: ${JSON.stringify(firstCat.status)}`));
      console.log(chalk.gray(`   â€¢ is_active: ${JSON.stringify(firstCat.is_active)}`));
      console.log(chalk.gray(`   â€¢ active: ${JSON.stringify(firstCat.active)}`));
      console.log(chalk.gray(`   â€¢ available: ${JSON.stringify(firstCat.available)}`));
    }
  }



  function renderFnbItemsTable(items) {
    const t = new CliTable({
      head: ['#','Item Name','Category','Price','Stock','Description'],
      wordWrap: true,
      style: { head: ['green'] },
      colWidths: [4, 28, 15, 12, 8, 30]
    });

    items.forEach((item, i) => {
      const stockStatus = item.stock_status === 'AVAILABLE' || item.is_available !== false
        ? chalk.green('âœ…')
        : chalk.red('âŒ');
      
      const priceColor = item.price > 100000 ? chalk.red(toRp(item.price)) 
        : item.price > 50000 ? chalk.yellow(toRp(item.price))
        : chalk.green(toRp(item.price));

      t.push([
        chalk.white.bold(i+1),
        chalk.cyan(item.name),
        chalk.gray(item.category_name || '-'),
        priceColor,
        stockStatus,
        chalk.gray((item.description || item.name || '-').slice(0, 28))
      ]);
    });
    console.log(t.toString());
    
    console.log(chalk.cyan('\nğŸ“Š STATISTIK ITEMS:'));
    console.log(chalk.white(`   ğŸ”¢ Total items: ${items.length}`));
    const avgPrice = items.reduce((sum, item) => sum + (Number(item.price) || 0), 0) / items.length;
    console.log(chalk.white(`   ğŸ’° Harga rata-rata: ${toRp(avgPrice || 0)}`));
    const minPrice = Math.min(...items.map(item => Number(item.price) || 0));
    const maxPrice = Math.max(...items.map(item => Number(item.price) || 0));
    console.log(chalk.white(`   ğŸ“ˆ Range harga: ${toRp(minPrice)} - ${toRp(maxPrice)}`));
  }


  function renderCartTable(cartItems) {
    const t = new CliTable({
      head: ['#','Item Name','Customization','Qty','Unit Price','Total'],
      wordWrap: true,
      style: { head: ['magenta'] },
      colWidths: [4, 20, 25, 5, 12, 12]
    });

    let grandTotal = 0;
    cartItems.forEach((item, i) => {
      const total = item.finalPrice * item.quantity;
      grandTotal += total;
      
      const customInfo = item.customizations ? 
        item.customizations.map(c => c.SUB_ITEM_NM).join(', ') : 
        'Default';
      
      t.push([
        i+1,
        item.name,
        customInfo,
        `${item.quantity}x`,
        toRp(item.finalPrice),
        toRp(total)
      ]);
    });
    
    console.log(t.toString());
    console.log(chalk.green(`\nğŸ’° GRAND TOTAL: ${toRp(grandTotal)}`));
    return grandTotal;
  }

  function renderCustomizationOptions(customGroup) {
    const t = new CliTable({
      head: ['#','Option Name','Extra Cost'],
      wordWrap: true,
      style: { head: ['blue'] },
      colWidths: [4, 30, 15]
    });

    customGroup.item_child.forEach((option, i) => {
      const extraCost = Number(option.ADD_AMT || 0);
      const costDisplay = extraCost > 0 ? `+${toRp(extraCost)}` : 'Free';
      const isDefault = option.DEFT_YN === '1' ? ' (Default)' : '';
      
      t.push([
        i+1,
        option.SUB_ITEM_NM + isDefault,
        costDisplay
      ]);
    });
    console.log(t.toString());
  }

  function renderPaymentMethodsTable(payData) {
    const t = new CliTable({
      head: ['Kategori','Metode (aktif saja)'],
      wordWrap: true,
      style: { head: ['magenta'] },
      colWidths: [24, 70]
    });
    (payData?.data||[]).forEach(cat=>{
      const active = (cat.items||[]).filter(it=>it.status).map(it=>it.name).join(', ') || '-';
      t.push([cat.name, active]);
    });
    console.log(t.toString());
  }

  function renderCouponsTable(coupons=[]) {
    const t = new CliTable({
      head: ['#','Discount Code','Type','Name'],
      wordWrap: true,
      style: { head: ['blue'] },
      colWidths: [4, 16, 8, 70]
    });
    coupons.forEach((c,i)=>{
      t.push([i+1, c.discount || '-', c.type || '-', c.name || '-']);
    });
    console.log(t.toString());
  }

  function findDana(payData) {
    const cats = payData?.data || [];
    for (const cat of cats) {
      const catId = String(cat?.category_id || cat?.id || '');
      const isWallet = catId === '2' || includesIgnoreCase(cat?.name, 'E-WALLET');
      if (!isWallet) continue;
      
      for (const it of (cat.items || [])) {
        if (!it?.status) continue;
        const nameNorm = String(it.name || '').toLowerCase();
        if (nameNorm === 'dana' || String(it.id) === '5') {
          return { 
            payment_id: String(it.id), 
            payment_name: it.name, 
            category_id: catId, 
            category_name: cat.name 
          };
        }
      }
    }
    return null;
  }



  function renderFnbPaymentSummary(pdata, cartItems, cinema, saleDate) {
    const lines = [];
    lines.push(`F&B Items  : ${cartItems.map(c=>c.name).join(', ')}`);
    lines.push(`Cinema     : ${cinema.name}`);
    lines.push(`Location   : ${cinema.location_name}`);
    lines.push(`Date       : ${saleDate.slice(6,8)}/${saleDate.slice(4,6)}/${saleDate.slice(0,4)}`);
    lines.push(`Metode     : ${pdata.virtual_account_bank_name || pdata.payment_method || 'Payment Method'}`);
    lines.push(`Order ID   : ${pdata.id || '-'}`);
    lines.push(`Booking    : ${pdata.booking_code || '-'}`);
    if (pdata.virtual_account_bank_number || pdata.payment_code) {
      lines.push(`VA Number  : ${pdata.virtual_account_bank_number || pdata.payment_code}`);
    }
    lines.push(`Subtotal   : ${toRp(pdata.sub_total_amount||0)}`);
    lines.push(`Convenience fee : ${toRp(pdata.convenience_fee||0)}`);
    if (pdata.insurance_fee) lines.push(`Insurance  : ${toRp(pdata.insurance_fee||0)}`);
    lines.push(`Total      : ${toRp(pdata.total_amount||0)}`);
    lines.push(`Expires    : ${pdata.expired_date || '-'}`);
    console.log(multilineBox(lines));
  }



  // ---------- CITY MATCHING ----------
  function cityScore(hay, needle) {
    hay = String(hay || '').toLowerCase();
    needle = String(needle || '').toLowerCase();
    if (!needle) return 0;
    if (hay === needle) return 100;
    if (hay.includes(needle)) return 90;
    if (hay.startsWith(needle)) return 80;
    const hTok = new Set(hay.split(/\s+/));
    const nTok = new Set(needle.split(/\s+/));
    let overlap = 0;
    nTok.forEach(t=>{ if (hTok.has(t)) overlap++; });
    return overlap * 10;
  }

  function findCityCandidates(cinemas, input) {
    const scored = cinemas.map(cinema => ({
      score: cityScore(cinema.location_name, input),
      cinema
    })).filter(x => x.score > 0);
    scored.sort((a,b)=> b.score - a.score || a.cinema.location_name.localeCompare(b.cinema.location_name));
    return scored.map(x => x.cinema);
  }

  function findCinemaByNameOrLocation(cinemas, input) {
    const query = String(input || '').toLowerCase().trim();
    if (!query) return [];

    const matches = [];
    
    cinemas.forEach(cinema => {
      const name = String(cinema.name || '').toLowerCase();
      const location = String(cinema.location_name || '').toLowerCase();
      const address = String(cinema.address || '').toLowerCase();
      
      let score = 0;
      
      // Exact match gets highest score
      if (name === query || location === query) {
        score = 1000;
      }
      // Starts with query gets high score  
      else if (name.startsWith(query) || location.startsWith(query)) {
        score = 500;
      }
      // Contains query gets medium score
      else if (name.includes(query) || location.includes(query) || address.includes(query)) {
        score = 100;
      }
      // Word match gets lower score
      else {
        const nameWords = name.split(/\s+/);
        const locationWords = location.split(/\s+/);
        const queryWords = query.split(/\s+/);
        
        queryWords.forEach(queryWord => {
          nameWords.forEach(nameWord => {
            if (nameWord.includes(queryWord) || queryWord.includes(nameWord)) {
              score += 50;
            }
          });
          locationWords.forEach(locationWord => {
            if (locationWord.includes(queryWord) || queryWord.includes(locationWord)) {
              score += 30;
            }
          });
        });
      }
      
      if (score > 0) {
        matches.push({ cinema, score });
      }
    });

    // Sort by score descending, then by name
    matches.sort((a, b) => b.score - a.score || a.cinema.name.localeCompare(b.cinema.name));
    
    // Return top 10 matches to avoid overwhelming user
    return matches.slice(0, 10).map(m => m.cinema);
  }

    function findItemsByName(items, query) {
    const searchTerm = String(query || '').toLowerCase().trim();
    if (!searchTerm) return [];

    const matches = [];
    
    items.forEach(item => {
      const name = String(item.name || '').toLowerCase();
      const category = String(item.category_name || '').toLowerCase();
      const description = String(item.description || '').toLowerCase();
      
      let score = 0;
      
      // Exact match gets highest score (boost untuk auto-select)
      if (name === searchTerm) {
        score = 10000; // Much higher untuk prioritas exact match
      }

      // Starts with query gets high score  
      else if (name.startsWith(searchTerm)) {
        score = 500;
      }
      // Contains query gets medium score
      else if (name.includes(searchTerm) || description.includes(searchTerm)) {
        score = 100;
      }
      // Category match gets lower score
      else if (category.includes(searchTerm)) {
        score = 50;
      }
      // Word match gets lowest score
      else {
        const nameWords = name.split(/\s+/);
        const queryWords = searchTerm.split(/\s+/);
        
        queryWords.forEach(queryWord => {
          nameWords.forEach(nameWord => {
            if (nameWord.includes(queryWord) || queryWord.includes(nameWord)) {
              score += 25;
            }
          });
        });
      }
      
      if (score > 0) {
        matches.push({ item, score });
      }
    });

    // Sort by score descending, then by name
    matches.sort((a, b) => b.score - a.score || a.item.name.localeCompare(b.item.name));
    
    // Return top 15 matches to avoid overwhelming user
    return matches.slice(0, 15).map(m => m.item);
  }


  // ---------- MAIN FLOW ----------
  console.clear();
  log.header('ğŸ¿ AUTO ORDER F&B', 'Food & Beverage Orders');

  try {
    await appendJsonLog({ event: 'fnb_session_start' });

    // ğŸ”Œ Proxy setup (untuk fetch). Puppeteer tetap tanpa proxy.
    await promptProxyAtStartup();
    await initSessionAgentIfNeeded();

  // ğŸŒ Cek IP publik; cek #2 & delay hanya jika proxy ON
  const STARTUP_IP_WAIT_MS = Number(process.env.STARTUP_IP_WAIT_MS || 5000);

  log.section('ğŸŒ PROXY / OUTBOUND IP CHECK');
  let ip1 = '-', ip2 = '-';

  // deteksi proxy aktif
  const proxyActive = (!PROXY_DISABLED) && !!(typeof sessionProxyUrl !== 'undefined' && sessionProxyUrl);

  try {
    const r1 = await requestJson('GET', 'https://api.ipify.org?format=json', {
      note: 'proxy-ip-check#1'
    });
    ip1 = r1?.json?.ip || '-';
    console.log(chalk.cyan(`ğŸ” Public IP #1: ${ip1}`));
    try {
      if (proxyActive) {
        console.log(chalk.gray(`   via proxy: ${maskProxy(sessionProxyUrl)}`));
      } else {
        console.log(chalk.gray('   via direct connection'));
      }
    } catch {}
  } catch (e) {
    console.log(chalk.yellow('âš ï¸  Gagal cek IP publik (hit #1).'));
  }

  if (proxyActive) {
    // â³ tunggu beberapa detik sebelum hit #2 (khusus proxy)
    await delay(STARTUP_IP_WAIT_MS);

    try {
      const r2 = await requestJson('GET', 'https://api.ipify.org?format=json', {
        note: 'proxy-ip-check#2'
      });
      ip2 = r2?.json?.ip || '-';
      console.log(chalk.cyan(`ğŸ” Public IP #2: ${ip2}`));
    } catch (e) {
      console.log(chalk.yellow('âš ï¸  Gagal cek IP publik (hit #2).'));
    }

    // ğŸ” bandingkan
    if (ip1 !== '-' && ip2 !== '-') {
      if (ip1 !== ip2) {
        console.log(chalk.green(`ğŸ”„ IP berubah: ${ip1} â†’ ${ip2}`));
      } else {
        console.log(chalk.yellow('â¸ï¸  IP belum berubah (masih sama).'));
      }
    } else {
      console.log(chalk.gray('â„¹ï¸  Tidak cukup data untuk membandingkan IP.'));
    }

    await appendJsonLog({
      event: 'startup_ip_double_check',
      ip_first: ip1,
      ip_second: ip2,
      wait_ms: STARTUP_IP_WAIT_MS,
      proxy: maskProxy(sessionProxyUrl)
    });
  } else {
    // DIRECT â†’ tidak perlu cek #2 & tidak perlu delay
    console.log(chalk.gray('â­ï¸  Skip IP check #2 (proxy OFF/DIRECT).'));
    await appendJsonLog({
      event: 'startup_ip_single_check',
      ip_first: ip1,
      proxy: 'DIRECT'
    });
  }


    // 1. Account Selection
    const accItems = await readAccountsFromJson(accountJsonPath);

    if (!accItems.length) {
      log.error('account.json kosong/invalid. Pastikan file berisi "items[]"');
      await appendJsonLog({ event: 'fnb_session_end', reason: 'no_accounts' });
      return;
    }

    log.section('ğŸ‘¤ PILIH AKUN F&B');
    renderAccountTable(accItems);
    
    console.log(chalk.yellow('\nğŸ’¡ CARA PILIH AKUN:'));
    console.log(chalk.gray('   â€¢ Ketik nomor urut (1-' + accItems.length + ') dari tabel di atas'));
    console.log(chalk.gray('   â€¢ Ketik email lengkap atau sebagian: gblazada@gmail.com'));
    console.log(chalk.gray('   â€¢ Ketik nomor telepon: 0881024062912'));
    console.log(chalk.cyan('   âš¡ Tip: Nomor telepon lebih cepat daripada email panjang\n'));


    let selectedAccount = null;
    while (!selectedAccount) {
      const { accInput } = await inquirer.prompt([{
        type: 'input', 
        name: 'accInput',
        message: 'Pilih akun (nomor/email/telepon):',
        filter: s => String(s || '').trim()
      }]);

      // 1. Check if input is table number (1-250)
      if (/^\d+$/.test(accInput) && Number(accInput) >= 1 && Number(accInput) <= accItems.length) {
        const idx = Number(accInput) - 1;
        selectedAccount = accItems[idx];
        if (selectedAccount) {
          console.log(chalk.green(`âœ… Dipilih berdasarkan nomor urut: #${accInput}`));
        }
      }
      // 2. Check if input is phone number (starts with 08 or 628, length 10-15)
      else if (/^(08|628)\d{8,13}$/.test(accInput)) {
        selectedAccount = accItems.find(acc => {
          const accPhone = String(acc.phone || '').replace(/[\s\-\+]/g, '');
          const inputPhone = accInput.replace(/[\s\-\+]/g, '');
          return accPhone === inputPhone || 
                 accPhone.endsWith(inputPhone.slice(-10)) || // Match last 10 digits
                 inputPhone.endsWith(accPhone.slice(-10));
        });
        if (selectedAccount) {
          console.log(chalk.green(`âœ… Dipilih berdasarkan nomor telepon: ${accInput}`));
        }
      }
      // 3. Check if input is email (contains @ or partial match)
      else if (accInput) {
        selectedAccount = accItems.find(acc => 
          includesIgnoreCase(acc.email, accInput)
        );
        if (selectedAccount) {
          console.log(chalk.green(`âœ… Dipilih berdasarkan email: ${accInput}`));
        }
      }

      if (!selectedAccount) {
        console.log(chalk.red('\nâŒ AKUN TIDAK DITEMUKAN'));
        console.log(chalk.yellow('ğŸ’¡ Yang bisa diinput:'));
        console.log(chalk.gray(`   â€¢ Nomor urut tabel: 1-${accItems.length}`));
        console.log(chalk.gray('   â€¢ Email: contoh@gmail.com atau sebagian email'));
        console.log(chalk.gray('   â€¢ Nomor telepon: 08123456789 atau 628123456789'));
        console.log(chalk.cyan('   ğŸ“‹ Lihat tabel di atas untuk referensi\n'));
      }
    }


    log.info(`Using account: ${selectedAccount.email}`);
    await appendJsonLog({ event: 'fnb_account_selected', email: selectedAccount.email });

// 2. Bearer token
// Pastikan bearer
log.process('Ensuring bearer token...');
const bearerEns = await ensureBearerForAccount(selectedAccount);
if (!bearerEns.ok) {
  log.error(`Bearer error: ${bearerEns.reason || 'unknown'}`);
  await appendJsonLog({ event: 'session_end', reason: 'no_bearer', detail: bearerEns.reason || 'unknown' });
  return;
}
let token = bearerEns.token;
log.success(`Bearer OK ${chalk.gray(`(${bearerEns.source})`)}`);
await appendJsonLog({ event: 'bearer_ok', source: bearerEns.source, token_masked: maskToken(token) });

log.process('Validating bearer token with CGV API...');
let bearerCheck = await validateBearerTokenWithApi(token);

if (!bearerCheck.ok) {
  log.warn(`Bearer token tidak valid di server CGV (HTTP ${bearerCheck.status}). Mencoba refresh token...`);
  await appendJsonLog({
    event: 'bearer_invalid_first_try',
    http_status: bearerCheck.status
  });

  // ğŸ” Coba refresh bearer (paksa ambil token baru, abaikan cache lama)
  // NOTE:
  // Pastikan implementasi ensureBearerForAccount mendukung opsi { forceRefresh: true }
  // dan DI DALAMNYA dia nggak pakai cache token lama.
  const refreshEns = await ensureBearerForAccount(selectedAccount, { forceRefresh: true });

  if (!refreshEns.ok) {
    log.error(`Gagal refresh bearer token: ${refreshEns.reason || 'unknown'}`);
    await appendJsonLog({
      event: 'session_end',
      reason: 'bearer_refresh_failed',
      detail: refreshEns.reason || 'unknown'
    });
    return;
  }

  token = refreshEns.token;
  log.success(`Berhasil refresh bearer token ${chalk.gray(`(${refreshEns.source})`)}`);
  await appendJsonLog({
    event: 'bearer_refreshed',
    source: refreshEns.source,
    token_masked: maskToken(token)
  });

  // âœ… Validasi ulang token BARU
  bearerCheck = await validateBearerTokenWithApi(token);
  if (!bearerCheck.ok) {
    log.error(`Token baru juga TIDAK valid di server CGV (HTTP ${bearerCheck.status}).`);
    await appendJsonLog({
      event: 'session_end',
      reason: 'bearer_invalid_after_refresh',
      http_status: bearerCheck.status
    });
    return;
  }
}

log.success('Bearer valid di server CGV.');

// ===== UTIL TAMBAHAN (aman, tidak mengganggu struktur) =====
function safeDecodeJwt(token) {
  try {
    const payload = JSON.parse(Buffer.from(String(token||'').split('.')[1]||'', 'base64').toString('utf8'));
    return payload || {};
  } catch { return {}; }
}

// Coba panggil getMemberInfo seperti di listAccounts(); jika tidak ada, balikin null
async function tryGetMemberInfo(token) {
  try {
    if (typeof getMemberInfo === 'function') {
      const info = await getMemberInfo(token);
      if (info?.RESULTS?.ds_mbrList) return info;
    }
  } catch {}
  return null;
}

/** Split nama lengkap jadi first_name + last_name */
function splitName(full) {
  const parts = String(full || '')
    .trim()
    .split(/\s+/)
    .filter(Boolean);

  if (!parts.length) return { first: '', last: '' };
  if (parts.length === 1) return { first: parts[0], last: '' };
  const last = parts.pop();
  const first = parts.join(' ');
  return { first, last };
}

/**
 * Update profil hanya FIRST_NAME + LAST_NAME.
 * - Kalau nama 1 kata â†’ first_name = kata itu, last_name = '' (benar-benar kosong)
 * - Field lain (alamat/kota/gender) diambil dari profil sekarang (tidak diubah selain dikirim ulang).
 */
async function updateProfileNameOnly(token, selectedAccount, newFullName) {
  const safeName = String(newFullName || '').trim();
  if (!safeName) {
    return {
      ok: false,
      status: 0,
      message: 'Nama baru kosong'
    };
  }

  // 1) Ambil profil lama dulu
  let info;
  try {
    info = await tryGetMemberInfo(token);
  } catch (e) {
    return {
      ok: false,
      status: 0,
      message: 'Gagal membaca profil saat ini (getMemberInfo error)'
    };
  }

  const m = info?.RESULTS?.ds_mbrList;
  if (!m) {
    return {
      ok: false,
      status: 0,
      message: 'Data profil tidak ditemukan; nama tidak diubah'
    };
  }

  // 2) Pecah nama baru â†’ kalau 1 kata, last_name dikosongkan
  const parts = safeName.split(/\s+/).filter(Boolean);
  let firstName = '';
  let lastName  = '';

  if (parts.length === 1) {
    // Contoh: "Iqra" â†’ first="Iqra", last=""
    firstName = parts[0];
    lastName  = '';
  } else {
    // Contoh: "Iqra Nur Fajar" â†’ first="Iqra Nur", last="Fajar"
    lastName  = parts.pop();
    firstName = parts.join(' ');
  }

  // 3) Field lain diambil dari profil lama (supaya nggak ke-reset aneh)
  const addr   = (m.ADDR_STREET    ?? '').toString();
  const cityId = (m.ADDR_REGION_CD ?? '').toString();
  const gender = (m.SEC_CD         ?? '').toString();

  // Kalau mau super aman, bisa kasih fallback default; kalau nggak perlu, bisa di-skip
  const finalAddr   = addr;
  const finalCityId = cityId || (selectedAccount?.city_id || '024');
  const finalGender = gender || (selectedAccount?.gender_code || '01');

  const form = new FormData();
  form.set('first_name', firstName || '-');
  // âš ï¸ PENTING: jangan pakai fallback ' ' lagi â€” biarkan kosong kalau memang kosong
  form.set('last_name',  lastName);
  form.set('address',    finalAddr);
  form.set('city_id',    finalCityId);
  form.set('gender',     finalGender);

  try {
    const res = await fetch('https://v2-api.cgv.id/api/membership/profile/edit', {
      method: 'POST',
      headers: {
        Accept            : 'application/json, text/plain, */*',
        Authorization     : `Bearer ${token}`,
        'X-Requested-With': 'XMLHttpRequest'
      },
      body: form
    });

    const httpStatus = res.status;
    let body = null;
    try { body = await res.json(); } catch { body = null; }

    const statusCode = body?.status_code ?? httpStatus;

    if (statusCode === 200) {
      // In-memory: sync juga, biar next view pakai nama baru
      if (selectedAccount) {
        selectedAccount.name       = safeName;
        selectedAccount.first_name = firstName;
        selectedAccount.last_name  = lastName;
      }

      return { ok: true, status: statusCode, body };
    }

    return {
      ok: false,
      status: statusCode,
      message: body?.message || `HTTP ${httpStatus}`
    };
  } catch (e) {
    return {
      ok: false,
      status: 0,
      message: e?.message || 'network error'
    };
  }
}




function parseMemberProfileFromInfo(info) {
  if (!info?.RESULTS?.ds_mbrList) return null;
  const m = info.RESULTS.ds_mbrList;
  const points = Number(m.ACCU_POINT ?? m.MILEAGE_AMT ?? 0);
  return {
    name: m.MBR_NM || '-',
    tier_name: m.MBR_GRD_NM || m.MBR_TIER_NM || 'NEW',
    // best-effort code (kalau ada); fallback tetap ke '03' saat pay
    grade_id:  m.MBR_GRD_CD || null,
    tier_id:   m.MBR_TIER_CD || null,
    points,
    member_no: m.MBR_NO || null,
    phone: m.MOBILE_NO || null,
    city:  m.ADDR_REGION_NM || null,
    email_id: m.EMAIL_ID || null
  };
}

function extractPointNumber(obj) {
  if (!obj || typeof obj !== 'object') return null;
  const keys = ['point','points','point_balance','balance','balance_point','available_point','available_points'];
  for (const k of keys) {
    const v = obj[k] ?? obj?.data?.[k];
    if (typeof v === 'number' && Number.isFinite(v)) return v;
    if (typeof v === 'string' && /^[0-9]+$/.test(v)) return Number(v);
  }
  return null;
}

async function validateBearerTokenWithApi(token) {
  const url = 'https://v2-api.cgv.id/api/membership/profile';
  try {
    const res = await requestJson('GET', url, {
      headers: {
        accept: 'application/json',
        authorization: `Bearer ${token}`
      },
      silent: true
    });

    const status = res?.status_code ?? res?.status ?? 200;
    // 401 / 403 â†’ token sudah mati / tidak valid
    if (status === 401 || status === 403) {
      return { ok: false, status };
    }
    return { ok: true, status };
  } catch (e) {
    const status = e?.status || e?.response?.status || 0;

    // Kalau server jelas bilang 401/403 di error, anggap invalid
    if (status === 401 || status === 403) {
      return { ok: false, status };
    }

    // Error lain (timeout / network) â†’ jangan matiin flow, anggap ok tapi catat status
    return { ok: true, status: status || 0 };
  }
}

async function probeGet(url, token) {
  try {
    const res = await requestJson('GET', url, {
      headers: { accept: 'application/json', authorization: `Bearer ${token}` },
      silent: true
    });
    const status = (res?.status_code ?? res?.status ?? 200);
    console.log(`HTTP GET ${url} â†’ ${status} | cgv-point-balance`);
    return { ok:true, status, body:res };
  } catch (e) {
    const status = e?.status || e?.response?.status || 0;
    console.log(`HTTP GET ${url} â†’ ${status} | cgv-point-balance`);
    return { ok:false, status, body:null };
  }
}

async function getCgvPointOverviewOrProfile(token, selectedAccount, selectedCinema) {
  // 1) PRIORITAS: getMemberInfo (rujukan dari listAccounts)
  const info = await tryGetMemberInfo(token);
  if (info?.RESULTS?.ds_mbrList) {
    const prof = parseMemberProfileFromInfo(info);
    const claims = safeDecodeJwt(token);
    return {
      // balance akan dipakai di ringkasan â€œkebutuhan pointâ€
      balance: prof.points,
      source: 'getMemberInfo()',
      // profil kaya untuk display
      profile: {
        name: prof.name,
        tier_name: prof.tier_name,
        grade_id: prof.grade_id,
        tier_id: prof.tier_id,
        member_no: prof.member_no,
        email: selectedAccount?.email || prof.email_id || '-',
        phone: (prof.phone || selectedAccount?.phone || '-').replace(/[^0-9+]/g,''),
        city: prof.city || (selectedAccount?.city || '-'),
        channel_code: claims?.channel_code || '-'
      }
    };
  }

  // 2) FALLBACK: probe endpoints lama (agar log tetap konsisten)
  const base = 'https://v2-api.cgv.id';
  const candidates = [
    '/api/membership/profile',
    '/api/membership/point',
    '/api/membership/points',
    '/api/membership/me'
  ];

  let balance = null;
  let source  = 'n/a';
  for (const path of candidates) {
    const { ok, body } = await probeGet(`${base}${path}`, token);
    if (!ok) continue;
    const data = body?.data ?? body;
    const val  = extractPointNumber(data);
    if (val !== null) { balance = val; source = path; break; }
  }
  const claims = safeDecodeJwt(token);
  return {
    balance,
    source,
    profile: {
      name: selectedAccount?.name || '-',
      tier_name: selectedAccount?.tier || 'NEW',
      grade_id: selectedAccount?.member_grade_id || null,
      tier_id: selectedAccount?.member_tier_id  || null,
      member_no: claims?.member_no || null,
      email: selectedAccount?.email || '-',
      phone: (selectedAccount?.phone || '-').replace(/[^0-9+]/g,''),
      city: selectedAccount?.city || (selectedCinema?.location_name || '-'),
      channel_code: claims?.channel_code || '-'
    }
  };
}

function renderPointProfileBox(pov) {
  const p = pov?.profile || {};
  const lines = [
    `Nama        : ${p.name || '-'}`,
    `Tier        : ${p.tier_name || '-'}`,
    `Member No   : ${p.member_no || '-'}`,
    `Email       : ${p.email || '-'}`,
    `Phone       : ${p.phone || '-'}`,
    `Kota        : ${p.city  || '-'}`,
    `Saldo Point : ${pov?.balance != null ? pov.balance : '(tidak terdeteksi)'}`,
    `Sumber      : ${pov?.source || 'n/a'}`
  ];
  console.log(multilineBox(lines));
}

// ====== PANGGIL (tetap di tempat yang sama) ======
log.section('ğŸ’  CGV POINT KAMU');
let pointPov = await getCgvPointOverviewOrProfile(token, selectedAccount);
renderPointProfileBox(pointPov);

// ====== OPSIONAL: GANTI NAMA PROFIL SEBELUM PILIH BIOSKOP ======
const { newName } = await inquirer.prompt([{
  type: 'input',
  name: 'newName',
  message: 'Mau ganti nama profil CGV? (Enter = pakai yang sekarang, atau ketik nama baru lengkap):',
  filter: s => String(s || '').trim()
}]);

if (newName) {
  log.process(`Update nama profil menjadi: "${newName}" ...`);
  await appendJsonLog({
    event: 'profile_name_change_request',
    email: selectedAccount.email,
    new_name: newName
  });

  const upd = await updateProfileNameOnly(token, selectedAccount, newName);

  if (!upd.ok) {
    log.warn(
      `Gagal update nama profil: ${upd.message || ('HTTP ' + (upd.status || '?'))}. ` +
      'Nama lama tetap dipakai.'
    );
    await appendJsonLog({
      event: 'profile_name_change_failed',
      email: selectedAccount.email,
      status: upd.status,
      message: upd.message || null
    });
  } else {
    log.success('Nama profil berhasil diperbarui.');

    await appendJsonLog({
      event: 'profile_name_change_success',
      email: selectedAccount.email,
      new_name: newName
    });

    // refresh box point pakai nama baru biar user yakin
    pointPov = await getCgvPointOverviewOrProfile(token, selectedAccount);
    renderPointProfileBox(pointPov);
  }
}


// 3. Load Cinemas
log.process('Loading cinemas...');

const cinemasRes = await fetchCinemas(token);
if (cinemasRes?.status_code !== 200 || !Array.isArray(cinemasRes.data) || !cinemasRes.data.length) {
  log.error('Gagal ambil data cinema.');
  await appendJsonLog({ event: 'fnb_session_end', reason: 'no_cinemas' });
  return;
}

const cinemas = cinemasRes.data;



// Helper normalisasi + smart picker
const norm = (s) => String(s || '').trim().toLowerCase();

/**
 * Smart pick cinema dari keyword:
 * - exact name match (case-insensitive)
 * - prefix match pada nama bioskop
 * - semua kata dalam keyword muncul di nama bioskop
 * - fallback: satu kata unik yang hanya muncul di satu bioskop
 */
function smartPickCinemaByName(keyword) {
  const kw = norm(keyword);
  if (!kw) return null;

  const words = kw.split(/\s+/).filter(Boolean);
  if (!words.length) return null;

  // 1) Exact match pada nama
  let exact = cinemas.find(c => norm(c.name) === kw);
  if (exact) return exact;

  // 2) Prefix match: "bekasi cyber" â†’ "bekasi cyber park"
  let prefixMatches = cinemas.filter(c => norm(c.name).startsWith(kw));
  if (prefixMatches.length === 1) return prefixMatches[0];

  // 3) Semua kata dalam keyword muncul di nama bioskop
  let allWordsInName = cinemas.filter(c => {
    const nameN = norm(c.name);
    return words.every(w => nameN.includes(w));
  });
  if (allWordsInName.length === 1) return allWordsInName[0];

  // 4) Jika cuma satu kata, dan hanya satu bioskop yg mengandung kata itu di name/location_name
  if (words.length === 1) {
    const w = words[0];
    let uniqueWordMatch = cinemas.filter(c => {
      const nameN = norm(c.name);
      const locN  = norm(c.location_name);
      return nameN.includes(w) || locN.includes(w);
    });
    if (uniqueWordMatch.length === 1) return uniqueWordMatch[0];
  }

  return null;
}

// 4. City Input & Cinema Selection
const { cityInput } = await inquirer.prompt([{
  type: 'input',
  name: 'cityInput',
  message: 'ğŸ¬ Ketik nama bioskop/kota (Enter=lihat semua | mis: panakkukang, central park, bandung):',
  filter: s => String(s || '').trim()
}]);

let selectedCinema = null;

if (!cityInput) {
  // === MODE: ENTER â†’ LIHAT SEMUA BIOSKOP ===
  log.section('ğŸ¢ SEMUA BIOSKOP TERSEDIA');
  console.log(chalk.yellow(`ğŸ“ Menampilkan ${cinemas.length} bioskop dari seluruh Indonesia\n`));
  renderCinemaTable(cinemas); // Show ALL cinemas

  console.log(chalk.yellow('\nğŸ’¡ CARA PILIH BIOSKOP:'));
  console.log(chalk.gray(`   â€¢ Ketik nomor urut: 1-${cinemas.length}`));
  console.log(chalk.gray('   â€¢ Ketik nama bioskop: panakkukang, central park, pvj'));
  console.log(chalk.gray('   â€¢ Ketik kota: makassar, jakarta, bandung'));
  console.log(chalk.cyan('   âš¡ Tip: Nama sebagian juga bisa, misal "panak" untuk Panakkukang\n'));

  while (!selectedCinema) {
    const { cinemaInput } = await inquirer.prompt([{
      type: 'input',
      name: 'cinemaInput',
      message: `Pilih bioskop (nomor/nama/kota):`,
      filter: s => String(s || '').trim()
    }]);

    // 1. Pilih via nomor urut (global)
    if (/^\d+$/.test(cinemaInput)) {
      const idx = Number(cinemaInput) - 1;
      if (idx >= 0 && idx < cinemas.length) {
        selectedCinema = cinemas[idx];
        console.log(chalk.green(`âœ… Dipilih berdasarkan nomor urut: #${cinemaInput} - ${selectedCinema.name}`));
      } else {
        console.log(chalk.red(`âŒ Nomor tidak valid. Harus 1-${cinemas.length}`));
      }
    }
    // 2. Cari berdasarkan nama bioskop/kota/alamat
    else if (cinemaInput) {
      // ğŸ” Coba smart pick dulu (nama saja) â†’ kalau uniq langsung pilih
      const smart = smartPickCinemaByName(cinemaInput);
      if (smart) {
        selectedCinema = smart;
        console.log(chalk.green(`âœ… Ditemukan (smart): ${selectedCinema.name} - ${selectedCinema.location_name}`));
        break;
      }

      const matches = findCinemaByNameOrLocation(cinemas, cinemaInput);
      
      if (matches.length === 0) {
        console.log(chalk.red('\nâŒ BIOSKOP TIDAK DITEMUKAN'));
        console.log(chalk.yellow(`ğŸ’¡ Tidak ada bioskop yang cocok dengan "${cinemaInput}"`));
        console.log(chalk.gray('   Coba kata kunci lain atau lihat tabel di atas\n'));
      } else if (matches.length === 1) {
        selectedCinema = matches[0];
        console.log(chalk.green(`âœ… Ditemukan: ${selectedCinema.name} - ${selectedCinema.location_name}`));
      } else {
        console.log(chalk.cyan(`\nğŸ” Ditemukan ${matches.length} bioskop yang cocok dengan "${cinemaInput}":`));
        console.log(chalk.gray('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n'));
        
        const matchTable = new CliTable({
          head: ['#','Cinema Name','Location','Address'],
          wordWrap: true,
          style: { head: ['cyan'] },
          colWidths: [4, 25, 15, 45]
        });

        matches.forEach((cinema, i) => {
          matchTable.push([
            chalk.white.bold(i+1),
            chalk.cyan(cinema.name),
            chalk.yellow(cinema.location_name),
            cinema.address || '-'
          ]);
        });
        console.log(matchTable.toString());

        const { matchChoice } = await inquirer.prompt([{
          type: 'input',
          name: 'matchChoice',
          message: `Pilih dari hasil pencarian (1-${matches.length}):`,
          validate: input => {
            const num = Number(input);
            return (num > 0 && num <= matches.length) ? true : `Nomor harus 1-${matches.length}`;
          }
        }]);

        const matchIdx = Number(matchChoice) - 1;
        if (matchIdx >= 0 && matchIdx < matches.length) {
          selectedCinema = matches[matchIdx];
          console.log(chalk.green(`âœ… Dipilih: ${selectedCinema.name} - ${selectedCinema.location_name}`));
        }
      }
    } else {
      console.log(chalk.yellow('âš ï¸  Input tidak boleh kosong. Silakan coba lagi.\n'));
    }
  }
} else {
  // === MODE: SUDAH KETIK KATA KUNCI (kota / nama bioskop) ===

  // 1) Smart pick langsung dari keyword awal (bekasi cyber, aeon mall, dll)
  const smartFirst = smartPickCinemaByName(cityInput);

  if (smartFirst) {
    selectedCinema = smartFirst;
    log.info(`Selected cinema (auto smart): ${selectedCinema.name} - ${selectedCinema.location_name}`);
} else {
  // === MODE: SUDAH KETIK KATA KUNCI (kota / nama bioskop) ===
  let currentKeyword = cityInput; // keyword awal dari user
  let candidates = [];

  while (!selectedCinema) {
    // 1) Coba SMART PICK ke semua bioskop (nama unik â†’ auto pilih)
    const smartFirst = smartPickCinemaByName(currentKeyword);
    if (smartFirst) {
      selectedCinema = smartFirst;
      log.info(`Selected cinema (auto smart): ${selectedCinema.name} - ${selectedCinema.location_name}`);
      break;
    }

    // 2) Fuzzy search berdasarkan keyword sekarang
    candidates = findCinemaByNameOrLocation(cinemas, currentKeyword);

    // âŒ TIDAK ADA CANDIDATE â†’ MINTA KEYWORD BARU (LOOP TERUS)
    if (!candidates.length) {
      console.log(chalk.red(`\nâŒ Tidak ada bioskop yang cocok dengan "${currentKeyword}"`));
      console.log(chalk.gray('   Coba keyword lain, misal nama mall atau nama kota.'));
      console.log(chalk.gray('   Contoh: "panak" / "panakkukang" / "makassar"\n'));

      const { newKeyword } = await inquirer.prompt([{
        type: 'input',
        name: 'newKeyword',
        message: 'ğŸ” Masukkan keyword baru (nama bioskop/kota):',
        filter: s => String(s || '').trim()
      }]);

      if (!newKeyword) {
        console.log(chalk.yellow('âš ï¸  Input kosong, silakan masukkan keyword yang lebih jelas.\n'));
        continue; // balik ke awal while
      }

      currentKeyword = newKeyword; // pakai keyword baru
      continue; // ulang loop, coba search lagi
    }

    // âœ… Hanya 1 kandidat â†’ auto pilih
    if (candidates.length === 1) {
      selectedCinema = candidates[0];
      console.log(chalk.green(`âœ… Selected cinema (auto): ${selectedCinema.name} - ${selectedCinema.location_name}`));
      break;
    }

    // ğŸ” Lebih dari 1 kandidat â†’ tampilkan tabel & minta pilih / refine
    log.section('ğŸ¢ KANDIDAT BIOSKOP');
    renderCinemaTable(candidates.slice(0, 10)); // batasi 10 biar nggak kepanjangan

    const { candInput } = await inquirer.prompt([{
      type: 'input',
      name: 'candInput',
      message: 'Pilih bioskop (nomor) atau ketik nama/kota lain untuk cari lagi:',
      filter: s => String(s || '').trim()
    }]);

    if (!candInput) {
      console.log(chalk.yellow('âš ï¸  Input kosong, silakan masukkan nomor atau keyword baru.\n'));
      continue;
    }

    // a) Kalau angka â†’ pilih dari kandidat sekarang
    if (/^\d+$/.test(candInput)) {
      const idx = Number(candInput) - 1;
      if (idx >= 0 && idx < candidates.length) {
        selectedCinema = candidates[idx];
        console.log(chalk.green(`âœ… Selected cinema: ${selectedCinema.name} - ${selectedCinema.location_name}`));
      } else {
        console.log(chalk.red(`âŒ Nomor tidak valid. Harus 1-${candidates.length}`));
        }
      } else {
        // b) BUKAN angka â†’ coba smart pick ke SEMUA bioskop lagi
        const smartAgain = smartPickCinemaByName(candInput);
        if (smartAgain) {
          selectedCinema = smartAgain;
          console.log(chalk.green(`âœ… Selected cinema (smart): ${selectedCinema.name} - ${selectedCinema.location_name}`));
          break;
        }

        // Kalau belum uniq â†’ keyword baru untuk fuzzy search
        currentKeyword = candInput;
        const newCandidates = findCinemaByNameOrLocation(cinemas, currentKeyword);

        if (!newCandidates.length) {
          console.log(chalk.red(`\nâŒ Tidak ada bioskop yang cocok dengan "${currentKeyword}"`));
          console.log(chalk.gray('   Coba keyword lain, misal nama mall atau nama kota.\n'));
          continue;
        }

        candidates = newCandidates;
        // loop lanjut, nanti kandidat baru ditampilkan lagi
      }
    }
  }
}

if (!selectedCinema) {
  log.error('Bioskop tidak dipilih.');
  return;
}

log.info(`Selected cinema: ${selectedCinema.name} - ${selectedCinema.location_name}`);
await appendJsonLog({
  event: 'fnb_cinema_selected',
  cinema: { id: selectedCinema.id, name: selectedCinema.name }
});



// Set sale date
// â”€â”€ SALE DATE WIZARD (Enter = +4 minggu dari hari ini) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let saleDate = todayYmd();
const now = new Date();

// Check auto-quick-date setting
const AUTO_FNB_QUICK_DATE = String(process.env.AUTO_FNB_QUICK_DATE || 'false').toLowerCase() === 'true';

if (AUTO_FNB_QUICK_DATE) {
  // Auto: +4 minggu (28 hari) tanpa prompt
  saleDate = ymdFromDate(addDaysSafe(now, 28));
  log.info('ğŸ“… Auto-quick-date: +4 minggu dari hari ini (28 hari)');
  log.info(`Sale date = ${saleDate} (YYYYMMDD)`);
  await appendJsonLog({ event: 'fnb_sale_date_set', sale_date: saleDate, mode: 'Auto: +4 weeks' });
} else {
  log.section('ğŸ—“ï¸ PILIH TANGGAL F&B');
}

// helpers
function ymdFromDate(d){
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return `${y}${m}${dd}`;
}
function isValidYMD(y,m,d){
  const Y = Number(y), M = Number(m), D = Number(d);
  const dt = new Date(Y, M-1, D);
  return dt.getFullYear()===Y && (dt.getMonth()+1)===M && dt.getDate()===D;
}
function prettyDate(yyyymmdd){
  const y = Number(yyyymmdd.slice(0,4));
  const m = Number(yyyymmdd.slice(4,6));
  const d = Number(yyyymmdd.slice(6,8));
  const dt = new Date(y, m-1, d);
  return dt.toLocaleDateString('id-ID', { weekday:'long', year:'numeric', month:'long', day:'2-digit' });
}
// aman untuk DST: tambahkan hari di UTC lalu kembalikan ke local date
function addDaysSafe(baseDate, days){
  const dt = new Date(Date.UTC(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate()));
  dt.setUTCDate(dt.getUTCDate() + Number(days || 0));
  return new Date(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate());
}

// parse bebas: 29 | 29/10 | 20251001 | 2025-10-26 | 26 okt | 26 oktober 2025
function parseDateLoose(raw, nowRef=new Date()){
  if (!raw) return null;
  const s = String(raw).trim().toLowerCase().replace(/\s+/g,' ');
  const Y0 = nowRef.getFullYear(), M0 = nowRef.getMonth()+1;

  // YYYYMMDD
  if (/^\d{8}$/.test(s)) {
    const y = +s.slice(0,4), m = +s.slice(4,6), d = +s.slice(6,8);
    if (isValidYMD(y,m,d)) return `${y}${String(m).padStart(2,'0')}${String(d).padStart(2,'0')}`;
  }
  // YYYY[-/ ,]MM[-/ ,]DD
  if (/^\d{4}[-\/,\s]\d{1,2}[-\/,\s]\d{1,2}$/.test(s)) {
    const [y,m,d] = s.split(/[-\/,\s]/).map(Number);
    if (isValidYMD(y,m,d)) return `${y}${String(m).padStart(2,'0')}${String(d).padStart(2,'0')}`;
  }
  // DD[-/]MM[/]YYYY
  if (/^\d{1,2}[-\/]\d{1,2}[-\/]\d{4}$/.test(s)) {
    const [d,m,y] = s.split(/[-\/]/).map(Number);
    if (isValidYMD(y,m,d)) return `${y}${String(m).padStart(2,'0')}${String(d).padStart(2,'0')}`;
  }
  // DD[-/]MM  â†’ asumsi tahun sekarang
  if (/^\d{1,2}[-\/]\d{1,2}$/.test(s)) {
    let [d,m] = s.split(/[-\/]/).map(Number);
    if (d<=12 && m>12){ const tmp=d; d=m; m=tmp; }
    if (isValidYMD(Y0,m,d)) return `${Y0}${String(m).padStart(2,'0')}${String(d).padStart(2,'0')}`;
  }
  // DD saja â†’ asumsi bulan&tahun sekarang
  if (/^\d{1,2}$/.test(s)) {
    const d = Number(s);
    if (isValidYMD(Y0,M0,d)) return `${Y0}${String(M0).padStart(2,'0')}${String(d).padStart(2,'0')}`;
  }

  // DD <bulan> [YYYY] (id)
  const monMap = {
    'jan':1,'januari':1,
    'feb':2,'februari':2,
    'mar':3,'maret':3,
    'apr':4,'april':4,
    'mei':5,
    'jun':6,'juni':6,
    'jul':7,'juli':7,
    'ags':8,'agu':8,'agust':8,'agustus':8,
    'sep':9,'sept':9,'september':9,
    'okt':10,'oktober':10,
    'nov':11,'november':11,
    'des':12,'desember':12
  };
  const m1 = s.match(/^(\d{1,2})\s+([a-z\.]+)(?:\s+(\d{4}))?$/i);
  if (m1){
    const d = Number(m1[1]);
    const monKey = m1[2].replace(/\./g,'');
    const m = monMap[monKey];
    const y = m1[3] ? Number(m1[3]) : Y0;
    if (m && isValidYMD(y,m,d)) return `${y}${String(m).padStart(2,'0')}${String(d).padStart(2,'0')}`;
  }

  return null;
}

let modeLabel = 'Default: +4 minggu (28 hari)';

// sub-wizard functions (must be declared before use)
async function askDDOnly(){
  const defD = now.getDate();
  const defM = now.getMonth()+1;
  const defY = now.getFullYear();
  const { dd } = await inquirer.prompt([{
    type: 'input',
    name: 'dd',
    message: `Tanggal (DD) â€” Enter=${defD}:`,
    filter: s => String(s||'').trim()
  }]);
  const D = dd && /^\d{1,2}$/.test(dd) ? Number(dd) : defD;
  if (isValidYMD(defY, defM, D)) {
    saleDate = `${defY}${String(defM).padStart(2,'0')}${String(D).padStart(2,'0')}`;
    modeLabel = 'Custom: DD saja (bulan&tahun sekarang)';
  } else {
    log.warning('Tanggal tidak valid untuk bulan ini. Dipakai +4 minggu dari hari ini.');
    saleDate = ymdFromDate(addDaysSafe(now, 28)); modeLabel = 'Fallback: +4 minggu';
  }
}
async function askManualYMD(){
  const defY = now.getFullYear();
  const defM = now.getMonth()+1;
  const defD = now.getDate();

  const { yInp } = await inquirer.prompt([{ type:'input', name:'yInp', message:`Tahun â€” Enter=${defY}:`, filter:s=>String(s||'').trim() }]);
  const { mInp } = await inquirer.prompt([{ type:'input', name:'mInp', message:`Bulan (1-12) â€” Enter=${defM}:`, filter:s=>String(s||'').trim() }]);
  const { dInp } = await inquirer.prompt([{ type:'input', name:'dInp', message:`Tanggal (1-31) â€” Enter=${defD}:`, filter:s=>String(s||'').trim() }]);

  const Y = (yInp && /^\d{4}$/.test(yInp)) ? Number(yInp) : defY;
  const M = (mInp && /^\d{1,2}$/.test(mInp)) ? Number(mInp) : defM;
  const D = (dInp && /^\d{1,2}$/.test(dInp)) ? Number(dInp) : defD;

  if (isValidYMD(Y,M,D)) {
    saleDate = `${Y}${String(M).padStart(2,'0')}${String(D).padStart(2,'0')}`;
    modeLabel = 'Custom: Y/M/D';
  } else {
    log.warning('Tanggal manual tidak valid. Dipakai +4 minggu dari hari ini.');
    saleDate = ymdFromDate(addDaysSafe(now, 28)); modeLabel = 'Fallback: +4 minggu';
  }
}

if (!AUTO_FNB_QUICK_DATE) {
  // STEP 1: Enter=+4 minggu â€¢ y=input â€¢ atau ketik format bebas
  const { firstChoice } = await inquirer.prompt([{
    type: 'input',
    name: 'firstChoice',
    message: 'Tanggal: (Enter=+4 minggu dari hari ini â€¢ y=Input manual) â€” atau ketik langsung: 29 | 29/10 | 20251001 | 26 okt',
    filter: s => String(s||'').trim()
  }]);

  // keputusan step 1
  if (!firstChoice) {
    // Enter â†’ +4 minggu (28 hari) dari hari ini
    saleDate = ymdFromDate(addDaysSafe(now, 28));
    modeLabel = 'Default: +4 minggu (28 hari)';
  }
  else if (/^y(es|a)?$/i.test(firstChoice)) {
    // STEP 2: Enter=DD saja â€¢ y=Y/M/D
    const { secondChoice } = await inquirer.prompt([{
      type: 'input',
      name: 'secondChoice',
      message: 'Metode input: (Enter=Input tanggal (DD) saja â€¢ y=Input tahun/bulan/tanggal)',
      filter: s => String(s||'').trim().toLowerCase()
    }]);
    if (!secondChoice) await askDDOnly();
    else await askManualYMD();
  }
  else {
    const parsed = parseDateLoose(firstChoice, now);
    if (parsed) { saleDate = parsed; modeLabel = 'Direct: format bebas'; }
    else {
      log.warning('Input tidak dikenali. Dipakai +4 minggu dari hari ini.');
      saleDate = ymdFromDate(addDaysSafe(now, 28)); modeLabel = 'Fallback: +4 minggu';
    }
  }

  // Output ringkas & jelas (+ tampilkan patokan hari ini)
  const pretty = prettyDate(saleDate);
  const left = (t)=> t.padEnd(16);
  const todayPretty = now.toLocaleDateString('id-ID', { weekday:'long', year:'numeric', month:'long', day:'2-digit' });

  console.log(chalk.cyan('â•­' + 'â”€'.repeat(60) + 'â•®'));
  console.log(chalk.cyan('â”‚') + ` ${left('ğŸ“… Mode')} : ${modeLabel}`.padEnd(61) + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + ` ${left('ğŸ—“ï¸  Today')} : ${todayPretty}`.padEnd(61) + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + ` ${left('ğŸ—“ï¸  Local')} : ${pretty}`.padEnd(61) + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + ` ${left('ğŸ”¢ API Param')} : ${saleDate} (YYYYMMDD)`.padEnd(61) + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â•°' + 'â”€'.repeat(60) + 'â•¯'));

  log.info(`Sale date = ${saleDate} (YYYYMMDD)`);
  await appendJsonLog({ event: 'fnb_sale_date_set', sale_date: saleDate, mode: modeLabel });
} // end if (!AUTO_FNB_QUICK_DATE)



  // 5. Load F&B Categories
  log.process('Loading F&B categories...');

  const categoriesRes = await fetchFnbCategories(selectedCinema.id, token);
  if (categoriesRes?.status_code !== 200 || !Array.isArray(categoriesRes.data) || !categoriesRes.data.length) {
    log.error('Gagal memuat kategori F&B atau tidak ada kategori tersedia.');
    await appendJsonLog({ event: 'fnb_session_end', reason: 'no_categories' });
    return;
  }

  console.log(chalk.green('â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
  console.log(chalk.green('â”‚') + chalk.white.bold('                 KATEGORI F&B BERHASIL DIMUAT              ') + chalk.green('â”‚'));
  console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
  console.log(chalk.green('â”‚') + ` ğŸ“‚ Total kategori tersedia: ${String(categoriesRes.data.length).padEnd(27)} ` + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` ğŸ¢ Bioskop: ${selectedCinema.name.slice(0,35).padEnd(35)} ` + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` ğŸ“ Lokasi: ${selectedCinema.location_name.slice(0,36).padEnd(36)} ` + chalk.green('â”‚'));
  const dateFormatted = `${saleDate.slice(6,8)}/${saleDate.slice(4,6)}/${saleDate.slice(0,4)}`;
  console.log(chalk.green('â”‚') + ` ğŸ“… Tanggal: ${dateFormatted.padEnd(36)} ` + chalk.green('â”‚'));
  console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));

  const cart = [];

  // Helper normalisasi + smart picker F&B
  const normalizeTextFnb = (s) => String(s || '').trim().toLowerCase();

  /**
   * Smart pick item berdasarkan NAMA (bukan deskripsi).
   * - exact match
   * - prefix match ("small salty" â†’ "Small Salty Popcorn")
   * - all words di nama
   * - unik by single word
   */
  function smartPickItemByNameFrom(items, keyword) {
    const kw = normalizeTextFnb(keyword);
    if (!kw) return null;
    const words = kw.split(/\s+/).filter(Boolean);
    if (!words.length) return null;

    // 1) exact match
    const exact = items.filter(it => normalizeTextFnb(it.name) === kw);
    if (exact.length === 1) return exact[0];

    // 2) prefix
    const prefix = items.filter(it => normalizeTextFnb(it.name).startsWith(kw));
    if (prefix.length === 1) return prefix[0];

    // 3) all words in name
    const allWords = items.filter(it => {
      const n = normalizeTextFnb(it.name);
      return words.every(w => n.includes(w));
    });
    if (allWords.length === 1) return allWords[0];

    // 4) single word unique
    if (words.length === 1) {
      const w = words[0];
      const uniq = items.filter(it => normalizeTextFnb(it.name).includes(w));
      if (uniq.length === 1) return uniq[0];
    }

    return null;
  }

  /**
   * Smart filter customization options berdasarkan SUB_ITEM_NM.
   * Dipakai untuk popcorn / beverage combo.
   */
  function smartFilterOptionsByName(options, keyword) {
    const kw = normalizeTextFnb(keyword);
    if (!kw) return [];

    // Synonym mapping untuk bahasa Indonesia
    const synonyms = {
      'coklat': 'chocolate',
      'cokelat': 'chocolate',
      'choco': 'chocolate',
      'choc': 'chocolate',
      'asin': 'salty',
      'garam': 'salty',
      'salt': 'salty',
      'karamel': 'caramel',
      'caramell': 'caramel',
      'kar': 'caramel',
      'manis': 'caramel',
      'campur': 'mix',
      'mixed': 'mix',
      'besar': 'large',
      'l': 'large',
      'lg': 'large',
      'sedang': 'medium',
      'm': 'medium',
      'med': 'medium',
      'kecil': 'small',
      's': 'small',
      'sm': 'small'
    };

    // Replace synonyms
    let expandedKw = kw;
    Object.keys(synonyms).forEach(key => {
      const regex = new RegExp(`\\b${key}\\b`, 'gi');
      if (regex.test(expandedKw)) {
        expandedKw = expandedKw.replace(regex, synonyms[key]);
      }
    });

    const words = expandedKw.split(/\s+/).filter(Boolean);
    if (!words.length) return [];

    // Utama: semua kata muncul di nama
    let res = options.filter(opt => {
      const nm = normalizeTextFnb(opt.SUB_ITEM_NM || '');
      return words.every(w => nm.includes(w));
    });
    if (res.length) return res;

    // Fallback: minimal satu kata cocok
    res = options.filter(opt => {
      const nm = normalizeTextFnb(opt.SUB_ITEM_NM || '');
      return words.some(w => nm.includes(w));
    });
    return res;
  }

  // 6. Auto-load all F&B items directly
  log.section('ğŸ¿ LOADING SEMUA ITEM F&B');
  console.log(chalk.cyan(`ğŸ“ Bioskop: ${selectedCinema.name} - ${selectedCinema.location_name}`));
  console.log(chalk.cyan(`ğŸ“… Tanggal: ${dateFormatted}\n`));
  
  log.process('Loading semua item F&B dari semua kategori...');
  console.log(chalk.cyan('â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
  console.log(chalk.cyan('â”‚') + chalk.white.bold('                    LOADING ALL ITEMS                      ') + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
  console.log(chalk.cyan('â”‚') + ` ğŸª Memuat semua item dari ${categoriesRes.data.length} kategori...`.padEnd(56) + ' ' + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));

  let allItems = [];
  for (const cat of categoriesRes.data) {
    console.log(chalk.cyan('â”‚') + ` ğŸ“‚ Loading ${cat.name.padEnd(40)}... ` + chalk.cyan('â”‚'));
    const itemsRes = await fetchFnbItems(selectedCinema.id, saleDate, cat.conce_category_id, token);
    if (itemsRes?.status_code === 200 && Array.isArray(itemsRes.data) && itemsRes.data.length) {
      const items = itemsRes.data.map(item => ({ ...item, category_name: cat.name }));
      allItems.push(...items);
      console.log(chalk.cyan('â”‚') + ` âœ… ${cat.name}: ${items.length} items loaded`.padEnd(56) + ' ' + chalk.cyan('â”‚'));
    } else {
      const reason = itemsRes?.status_code !== 200 ? `Error ${itemsRes?.status_code}` : 'Kosong';
      console.log(chalk.cyan('â”‚') + ` âš ï¸  ${cat.name}: ${reason}`.padEnd(56) + ' ' + chalk.cyan('â”‚'));
    }
    await delay(300); // Small delay to show progress
  }
  
  console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
  console.log(chalk.cyan('â”‚') + ` ğŸ“¦ Total items loaded: ${String(allItems.length).padEnd(30)} ` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
  
  if (allItems.length === 0) {
    console.log(chalk.red('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
    console.log(chalk.red('â”‚') + chalk.white.bold('                    TIDAK ADA ITEM TERSEDIA                ') + chalk.red('â”‚'));
    console.log(chalk.red('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.red('â”‚') + ' Semua kategori tidak memiliki item yang tersedia saat ini. ' + chalk.red('â”‚'));
    console.log(chalk.red('â”‚') + ' Silakan coba lagi nanti atau hubungi customer service CGV. ' + chalk.red('â”‚'));
    console.log(chalk.red('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
    await appendJsonLog({ event: 'fnb_session_end', reason: 'no_items' });
    return;
  }

  // 8. Shopping Loop dengan semua items yang sudah di-load
  while (true) {
    if (cart.length > 0) {
      const { viewCart } = await inquirer.prompt([{
        type: 'input',
        name: 'viewCart',
        message: `ğŸ›’ ${cart.length} item di keranjang. Ketik "cart" untuk review, Enter untuk lanjut belanja:`,
        filter: s => String(s || '').trim()
      }]);

      if (viewCart.toLowerCase() === 'cart') {
        log.section('ğŸ›’ KERANJANG BELANJA F&B SAAT INI');
        renderCartTable(cart);
        
        const { cartAction } = await inquirer.prompt([{
          type: 'list',
          name: 'cartAction',
          message: 'Aksi keranjang:',
          choices: [
            { name: 'ğŸ”„ Lanjut belanja', value: 'continue' },
            { name: 'ğŸ—‘ï¸ Hapus item', value: 'remove' },
            { name: 'âœ… Checkout sekarang', value: 'checkout' }
          ]
        }]);

        if (cartAction === 'checkout') {
          break;
        } else if (cartAction === 'remove') {
          const { removeIdx } = await inquirer.prompt([{
            type: 'input',
            name: 'removeIdx',
            message: `Hapus item nomor (1-${cart.length}):`,
            validate: input => {
              const num = Number(input);
              return (num > 0 && num <= cart.length) ? true : `Nomor harus 1-${cart.length}`;
            }
          }]);
          
          const idx = Number(removeIdx) - 1;
          if (idx >= 0 && idx < cart.length) {
            const removed = cart.splice(idx, 1)[0];
            log.success(`Item "${removed.name}" dihapus dari keranjang.`);
          }
        }
        continue;
      }
    }

    log.section('ğŸ›ï¸  PILIH ITEM F&B');
    renderFnbItemsTable(allItems);

    console.log(chalk.yellow('\nğŸ’¡ CARA PILIH ITEM F&B:'));
    console.log(chalk.gray(`   â€¢ Ketik nomor: 1-${allItems.length}`));
    console.log(chalk.gray('   â€¢ Ketik nama item: "combo solo", "popcorn", "coca cola"'));
    console.log(chalk.gray('   â€¢ Ketik "checkout" untuk selesai belanja'));
    if (cart.length > 0) {
      console.log(chalk.green(`   â€¢ ğŸ›’ Keranjang saat ini: ${cart.length} items`));
    }
    console.log(chalk.cyan('   âš¡ Tip: Nama sebagian juga bisa, misal "combo" untuk semua combo\n'));

    let selectedItem = null;
    while (!selectedItem) {
      const { itemInput } = await inquirer.prompt([{
        type: 'input',
        name: 'itemInput',
        message: `Pilih item F&B (nomor/nama/checkout):`,
        filter: s => String(s || '').trim()
      }]);

      const itemInputNorm = itemInput.toLowerCase();

      if (itemInputNorm === 'checkout') {
        if (cart.length === 0) {
          log.warning('Keranjang kosong. Tambahkan item dulu.');
          continue;
        }
        break; // Exit inner loop, lalu outer akan break karena selectedItem tetap null
      }

      // 1. Check if input is table number
      if (/^\d+$/.test(itemInput)) {
        const idx = Number(itemInput) - 1;
        if (idx >= 0 && idx < allItems.length) {
          selectedItem = allItems[idx];
          console.log(chalk.green(`âœ… Dipilih berdasarkan nomor: #${itemInput} - ${selectedItem.name}`));
        } else {
          console.log(chalk.red(`âŒ Nomor tidak valid. Harus 1-${allItems.length}`));
        }
      }
      // 2. Smart search by item name
      else if (itemInput) {
        // ğŸ” Coba smart pick dulu hanya berdasarkan NAMA item
        const smartItem = smartPickItemByNameFrom(allItems, itemInput);
        if (smartItem) {
          selectedItem = smartItem;
          console.log(chalk.green(`âœ… Ditemukan (smart): ${selectedItem.name} - ${selectedItem.category_name}`));
        } else {
          // Fallback ke fungsi findItemsByName yang mungkin pakai description juga
          const matches = findItemsByName(allItems, itemInput);
          
          if (matches.length === 0) {
            console.log(chalk.red('\nâŒ ITEM TIDAK DITEMUKAN'));
            console.log(chalk.yellow(`ğŸ’¡ Tidak ada item yang cocok dengan "${itemInput}"`));
            console.log(chalk.gray('   Coba kata kunci lain atau lihat tabel di atas\n'));
          } else {
            // Check for exact match first (auto-select)
            const exactMatch = matches.find(item =>
              item.name.toLowerCase() === itemInputNorm
            );
            
            if (exactMatch) {
              selectedItem = exactMatch;
              console.log(chalk.green(`âœ… Exact match found: ${selectedItem.name} - ${selectedItem.category_name}`));
            } else if (matches.length === 1) {
              selectedItem = matches[0];
              console.log(chalk.green(`âœ… Ditemukan: ${selectedItem.name} - ${selectedItem.category_name}`));
            } else {
              console.log(chalk.cyan(`\nğŸ” Ditemukan ${matches.length} item yang cocok dengan "${itemInput}":`));
              console.log(chalk.gray('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n'));
              
              const matchTable = new CliTable({
                head: ['#','Item Name','Category','Price'],
                wordWrap: true,
                style: { head: ['cyan'] },
                colWidths: [4, 30, 15, 12]
              });

              matches.forEach((item, i) => {
                const priceColor = item.price > 70000 ? chalk.red(toRp(item.price)) 
                  : item.price > 40000 ? chalk.yellow(toRp(item.price))
                  : chalk.green(toRp(item.price));

                matchTable.push([
                  chalk.white.bold(i+1),
                  chalk.cyan(item.name),
                  chalk.gray(item.category_name),
                  priceColor
                ]);
              });
              console.log(matchTable.toString());

              const { matchChoice } = await inquirer.prompt([{
                type: 'input',
                name: 'matchChoice',
                message: `Pilih dari hasil pencarian (1-${matches.length} atau ketik nama lagi):`,
                filter: s => String(s || '').trim()
              }]);

              const choice = String(matchChoice || '').trim();
              if (!choice) {
                console.log(chalk.yellow('âš ï¸  Input kosong, silakan pilih nomor atau nama lagi.\n'));
              } else if (/^\d+$/.test(choice)) {
                const matchIdx = Number(choice) - 1;
                if (matchIdx >= 0 && matchIdx < matches.length) {
                  selectedItem = matches[matchIdx];
                  console.log(chalk.green(`âœ… Dipilih: ${selectedItem.name} - ${selectedItem.category_name}`));
                } else {
                  console.log(chalk.red(`âŒ Nomor tidak valid. Harus 1-${matches.length}`));
                }
              } else {
                // Smart pick lagi tapi dari subset hasil pencarian
                const smartFromSubset = smartPickItemByNameFrom(matches, choice);
                if (smartFromSubset) {
                  selectedItem = smartFromSubset;
                  console.log(chalk.green(`âœ… Dipilih (smart subset): ${selectedItem.name} - ${selectedItem.category_name}`));
                } else {
                  console.log(chalk.red(`âŒ Tidak bisa menentukan item dari input "${choice}". Coba nomor atau nama yang lebih spesifik.`));
                }
              }
            }
          }
        }
      } else {
        console.log(chalk.yellow('âš ï¸  Input tidak boleh kosong. Silakan coba lagi.\n'));
      }
    }

    // If checkout was selected, break from shopping loop
    if (!selectedItem) break;

    const itemBasePrice = Number(selectedItem.price || 0);
    
    console.log(chalk.green('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
    console.log(chalk.green(' â”‚') + chalk.white.bold('                    ITEM TERPILIH                          ') + chalk.green('â”‚'));
    console.log(chalk.green(' â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.green(' â”‚') + ` ğŸ¿ Nama      : ${selectedItem.name.slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ“‚ Kategori  : ${(selectedItem.category_name || '-').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ’° Harga     : ${toRp(itemBasePrice).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ“ Deskripsi : ${(selectedItem.description || '-').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));

    // 7. Get Item Customization
    log.process('Loading customization options...');
    const customRes = await fetchItemCustomization(selectedCinema.id, selectedItem.conce_id, saleDate, token);
    let finalItemChild = [];
    let finalPrice = itemBasePrice;

    if (customRes?.status_code === 200 && Array.isArray(customRes.data) && customRes.data.length) {
      log.section('ğŸ¨ CUSTOMIZATION OPTIONS');
      console.log(chalk.cyan(`\nCustomizing: ${selectedItem.name}\n`));
      
      for (const customGroup of customRes.data) {
        if (Array.isArray(customGroup?.item_child) && customGroup.item_child.length) {
          console.log(chalk.yellow(`\nğŸ“‹ ${customGroup.name || 'Options'}:`));
          renderCustomizationOptions(customGroup);

          const groupLabel = (customGroup.name || 'opsi');
          let selectedCustom;
          const defaultCustom = customGroup.item_child.find(opt => String(opt.DEFT_YN) === '1') || customGroup.item_child[0];

          // Loop until valid selection
          while (!selectedCustom) {
            const { customInput } = await inquirer.prompt([{
              type: 'input',
              name: 'customInput',
              message: `Pilih ${groupLabel} (nomor/nama atau Enter untuk default):`,
              filter: s => String(s || '').trim()
            }]);

            if (!customInput) {
              // Use default
              selectedCustom = defaultCustom;
              if (selectedCustom) {
                log.success(`Using default: ${selectedCustom.SUB_ITEM_NM}`);
              }
              break;
            } else if (/^\d+$/.test(customInput)) {
              const idx = Number(customInput) - 1;
              const temp = customGroup.item_child[idx];
              if (!temp) {
                log.warning(`âŒ Nomor tidak valid (1-${customGroup.item_child.length}). Silakan pilih lagi.`);
                continue; // Re-prompt
              } else {
                selectedCustom = temp;
                log.success(`Selected: ${selectedCustom.SUB_ITEM_NM}`);
                break;
              }
            } else {
              // Nama / keyword â†’ coba smart filter
              let candidates = smartFilterOptionsByName(customGroup.item_child, customInput);
              if (candidates.length === 1) {
                selectedCustom = candidates[0];
                log.success(`Selected: ${selectedCustom.SUB_ITEM_NM}`);
                break;
              } else if (candidates.length > 1) {
              console.log(chalk.cyan(`\nğŸ” Ditemukan ${candidates.length} opsi yang cocok dengan "${customInput}":`));
              const optTable = new CliTable({
                head: ['#', 'Option Name', 'Extra Cost'],
                wordWrap: true,
                style: { head: ['cyan'] },
                colWidths: [4, 30, 14]
              });

              candidates.forEach((opt, i) => {
                const addAmt = Number(opt.ADD_AMT || 0);
                const labelCost = addAmt > 0 ? `+${toRp(addAmt)}` : 'Free';
                optTable.push([
                  chalk.white.bold(i + 1),
                  chalk.cyan(opt.SUB_ITEM_NM || '-'),
                  chalk.yellow(labelCost)
                ]);
              });
              console.log(optTable.toString());

              const { optChoice } = await inquirer.prompt([{
                type: 'input',
                name: 'optChoice',
                message: `Pilih dari opsi di atas (1-${candidates.length} atau ketik nama lagi, mis: large/medium):`,
                filter: s => String(s || '').trim()
              }]);

              const oc = String(optChoice || '').trim();
              if (!oc) {
                selectedCustom = defaultCustom;
                log.success(`Using default: ${selectedCustom.SUB_ITEM_NM}`);
                break;
              } else if (/^\d+$/.test(oc)) {
                const idx2 = Number(oc) - 1;
                const temp = candidates[idx2];
                if (!temp) {
                  log.warning(`âŒ Nomor tidak valid (1-${candidates.length}). Silakan pilih lagi.`);
                  continue; // Re-prompt dari awal
                } else {
                  selectedCustom = temp;
                  log.success(`Selected: ${selectedCustom.SUB_ITEM_NM}`);
                  break;
                }
              } else {
                // Refinement kedua khusus dari subset candidates
                let refined = smartFilterOptionsByName(candidates, oc);
                if (refined.length === 1) {
                  selectedCustom = refined[0];
                  log.success(`Selected: ${selectedCustom.SUB_ITEM_NM}`);
                  break;
                } else if (refined.length > 1) {
                  console.log(chalk.cyan(`\nğŸ” Masih ada ${refined.length} opsi. Perjelas lagi, misalnya ketik "large" atau "medium":`));
                  const refinedTable = new CliTable({
                    head: ['#', 'Option Name', 'Extra Cost'],
                    wordWrap: true,
                    style: { head: ['cyan'] },
                    colWidths: [4, 30, 14]
                  });

                  refined.forEach((opt, i) => {
                    const addAmt = Number(opt.ADD_AMT || 0);
                    const labelCost = addAmt > 0 ? `+${toRp(addAmt)}` : 'Free';
                    refinedTable.push([
                      chalk.white.bold(i + 1),
                      chalk.cyan(opt.SUB_ITEM_NM || '-'),
                      chalk.yellow(labelCost)
                    ]);
                  });
                  console.log(refinedTable.toString());

                  const { finalChoice } = await inquirer.prompt([{
                    type: 'input',
                    name: 'finalChoice',
                    message: `Pilih opsi final (1-${refined.length} atau ketik kata pembeda, mis: large/medium):`,
                    filter: s => String(s || '').trim()
                  }]);

                  const fc = String(finalChoice || '').trim();
                  if (!fc) {
                    selectedCustom = defaultCustom;
                    log.success(`Using default: ${selectedCustom.SUB_ITEM_NM}`);
                    break;
                  } else if (/^\d+$/.test(fc)) {
                    const idx3 = Number(fc) - 1;
                    const temp = refined[idx3];
                    if (!temp) {
                      log.warning(`âŒ Nomor tidak valid (1-${refined.length}). Silakan pilih lagi.`);
                      continue; // Re-prompt dari awal
                    } else {
                      selectedCustom = temp;
                      log.success(`Selected: ${selectedCustom.SUB_ITEM_NM}`);
                      break;
                    }
                  } else {
                    const finalFiltered = smartFilterOptionsByName(refined, fc);
                    if (finalFiltered.length === 1) {
                      selectedCustom = finalFiltered[0];
                      log.success(`Selected: ${selectedCustom.SUB_ITEM_NM}`);
                      break;
                    } else {
                      log.warning(`âŒ Tidak ada opsi yang cocok dengan "${fc}". Silakan pilih lagi.`);
                      continue; // Re-prompt dari awal
                    }
                  }
                } else {
                  log.warning(`âŒ Tidak ada opsi yang cocok dengan "${oc}". Silakan pilih lagi.`);
                  continue; // Re-prompt dari awal
                }
              }
              } else {
                // No match from candidates
                log.warning(`âŒ Tidak ada opsi yang cocok dengan "${customInput}". Silakan pilih lagi.`);
                continue; // Re-prompt dari awal
              }
            }
          } // end while (!selectedCustom)

          if (selectedCustom) {
            const addAmount = Number(selectedCustom.ADD_AMT || 0);
            finalPrice += addAmount;
            if (addAmount > 0) {
              console.log(chalk.green(`ğŸ’° Added cost: ${toRp(addAmount)}`));
            }
            
            finalItemChild.push({
              SUB_ITEM_NM: selectedCustom.SUB_ITEM_NM,
              REP_PRD_CD: selectedCustom.REP_PRD_CD,
              CHOICE_PRD_CD: selectedCustom.CHOICE_PRD_CD,
              ADD_AMT: addAmount,
              RCNT: selectedCustom.RCNT || 1,
              GOODS_CD: String(selectedItem.conce_id)
            });
          }
        }
      }
      
      if (finalPrice > itemBasePrice) {
        console.log(chalk.green(`\nğŸ’° Final price: ${toRp(itemBasePrice)} â†’ ${toRp(finalPrice)} (+${toRp(finalPrice - itemBasePrice)})`));
      }
    } else {
      log.info('Item ini tidak memiliki opsi customization.');
    }

    // 8. Quantity Selection
    const AUTO_FNB_QUICK_ORDER = String(process.env.AUTO_FNB_QUICK_ORDER || 'false').toLowerCase() === 'true';
    let quantity = 1;

    if (AUTO_FNB_QUICK_ORDER) {
      // Auto: qty = 1
      quantity = 1;
      log.info('ğŸ“¦ Auto-quick-order: Quantity = 1');
    } else {
      console.log(chalk.cyan('\nğŸ“¦ JUMLAH PESANAN:\n'));
      const { qtyInput } = await inquirer.prompt([{
        type: 'input',
        name: 'qtyInput',
        message: 'Jumlah (Enter=1, y atau angka langsung):',
        filter: s => String(s || '').trim()
      }]);

      const qtyNorm = qtyInput.toLowerCase();

      if (!qtyInput) {
        quantity = 1;
      } else if (/^\d+$/.test(qtyInput)) {
        const num = Number(qtyInput);
        if (num > 0 && num <= 99) {
          quantity = num;
        } else {
          console.log(chalk.yellow('âš ï¸  Jumlah di luar batas (1-99), pakai 1.'));
          quantity = 1;
        }
      } else if (qtyNorm === 'y') {
        const { customQty } = await inquirer.prompt([{
          type: 'input',
          name: 'customQty',
          message: 'Masukkan jumlah:',
          validate: input => {
            const num = Number(input);
            return (num > 0 && num <= 99) ? true : 'Jumlah harus 1-99';
          }
        }]);
        quantity = Number(customQty);
      } else {
        console.log(chalk.yellow('âš ï¸  Input tidak dikenali, jumlah diset ke 1.'));
        quantity = 1;
      }
    }

    // Add to cart
    cart.push({
      conce_id: String(selectedItem.conce_id),
      name: selectedItem.name,
      basePrice: itemBasePrice,
      finalPrice: finalPrice,
      quantity: quantity,
      customizations: finalItemChild,
      item_child: finalItemChild
    });

    const totalItemPrice = finalPrice * quantity;
    
    console.log(chalk.green('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
    console.log(chalk.green('â”‚') + chalk.white.bold('                    ITEM DITAMBAHKAN                       ') + chalk.green('â”‚'));
    console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.green('â”‚') + ` âœ… ${selectedItem.name.slice(0,35).padEnd(35)} ${chalk.white(`${quantity}x`).padEnd(10)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ’° Harga item: ${toRp(totalItemPrice).padEnd(35)} ` + chalk.green('â”‚'));
    const currentCartTotal = cart.reduce((sum, item) => sum + (item.finalPrice * item.quantity), 0);
    console.log(chalk.green('â”‚') + ` ğŸ›’ Total keranjang: ${toRp(currentCartTotal).padEnd(31)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ“¦ Items di keranjang: ${String(cart.length).padEnd(29)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
    
    await appendJsonLog({ event: 'fnb_item_added', item: selectedItem.name, quantity, total: totalItemPrice });

    // 9. Continue shopping?
    if (AUTO_FNB_QUICK_ORDER) {
      // Auto: langsung checkout (tidak tambah item lagi)
      log.info('ğŸ›’ Auto-quick-order: Langsung ke checkout');
      break;
    } else {
      console.log(chalk.cyan('\nğŸ›’ LANJUT BELANJA:'));
      console.log(chalk.gray('   ğŸ’¡ Tips: Anda bisa ketik "cart" di menu kategori untuk review keranjang\n'));

      const { continueInput } = await inquirer.prompt([{
        type: 'input',
        name: 'continueInput',
        message: 'Tambah item lagi? (Enter=selesai & checkout, y=tambah lagi):',
        filter: s => String(s || '').trim()
      }]);

      if (continueInput.toLowerCase() !== 'y') {
        break;
      }
    }
  }

  if (!cart.length) {
    log.warning('Keranjang kosong. Tidak ada yang dipesan.');
    await appendJsonLog({ event: 'fnb_session_end', reason: 'empty_cart' });
    return;
  }

  // 10. Show cart & confirm
  log.section('ğŸ›’ KERANJANG BELANJA F&B');
  const grandTotal = renderCartTable(cart);

  console.log(chalk.green('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
  console.log(chalk.green('â”‚') + chalk.white.bold('                   KONFIRMASI PESANAN F&B                  ') + chalk.green('â”‚'));
  console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
  console.log(chalk.green('â”‚') + ` ğŸ¢ Bioskop   : ${String(selectedCinema.name).slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` ğŸ“ Lokasi    : ${String(selectedCinema.location_name).slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` ğŸ“… Tanggal   : ${`${saleDate.slice(6,8)}/${saleDate.slice(4,6)}/${saleDate.slice(0,4)}`.padEnd(40)} ` + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` ğŸ›ï¸  Items     : ${String(cart.length).padEnd(40)} ` + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` ğŸ’° Total     : ${chalk.white(toRp(grandTotal)).padEnd(40)} ` + chalk.green('â”‚'));
  console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));

  const AUTO_FNB_CONFIRM_CHECKOUT = String(process.env.AUTO_FNB_CONFIRM_CHECKOUT || 'false').toLowerCase() === 'true';

  if (AUTO_FNB_CONFIRM_CHECKOUT) {
    // Auto: langsung checkout
    log.info('âœ… Auto-confirm-checkout: Langsung booking F&B...');
  } else {
    const { confirmOrder } = await inquirer.prompt([{
      type: 'confirm',
      name: 'confirmOrder',
      message: 'Lanjutkan checkout F&B sekarang?',
      default: true
    }]);

    if (!confirmOrder) {
      log.info('Pesanan F&B disimpan. Kamu bisa lanjutkan pembayaran nanti selama belum expired.');
      await appendJsonLog({ event: 'fnb_order_saved_for_later', cart_count: cart.length, sale_date: saleDate });
      return;
    }
  }

  // 11. Book F&B
  log.process('Booking F&B...');
  const bookPayload = {
    order_id: 'undefined',
    cinema_id: String(selectedCinema.id),
    sale_date: saleDate,
    orderData: cart.map(item => ({
      conce_id: String(item.conce_id),
      qty: Number(item.quantity),
      item_child: item.item_child || []
    }))
  };

  const bookRes = await bookFnb(bookPayload, token);
  if (bookRes?.status_code !== 200 || !bookRes?.data) {
    log.error(`Booking F&B gagal: ${bookRes?.message || 'Unknown error'}`);
    await appendJsonLog({ event: 'fnb_book_failed', response: bookRes });
    return;
  }


    const orderData = bookRes.data;
    log.success('Booking F&B berhasil!');
    await appendJsonLog({ event: 'fnb_book_success', order: orderData });

    // Order Summary
    log.section('ğŸ“‹ F&B ORDER SUMMARY');
    const lines = [];
    lines.push(`Account  : ${selectedAccount.email}`);
    lines.push(`Cinema   : ${selectedCinema.name}`);
    lines.push(`Location : ${selectedCinema.location_name}`);
    lines.push(`Date     : ${saleDate.slice(6,8)}/${saleDate.slice(4,6)}/${saleDate.slice(0,4)}`);
    lines.push(`Order ID : ${orderData.id || '-'}`);
    lines.push(`Booking  : ${orderData.booking_code || '-'}`);
    lines.push(`Subtotal : ${toRp(orderData.sub_total_amount || 0)}`);
    lines.push(`Total    : ${toRp(orderData.total_amount || 0)}`);
    lines.push(`Expires  : ${orderData.expired_date || '-'}`);
    console.log(multilineBox(lines));

    // Detail items
    if (Array.isArray(orderData.conces) && orderData.conces.length) {
      console.log(chalk.cyan('\nğŸ“¦ Detail Items:'));
      orderData.conces.forEach((item, i) => {
        console.log(chalk.white(`${i+1}. ${item.name} - ${toRp(item.price)}`));
        if (Array.isArray(item.item_child_all) && item.item_child_all.length) {
          item.item_child_all.forEach(child => {
            console.log(chalk.gray(`   â†³ ${child.SUB_ITEM_NM}`));
          });
        }
      });
    }

    // ===== VOUCHER FLOW F&B =====
    const AUTO_FNB_USE_VOUCHER = String(process.env.AUTO_FNB_USE_VOUCHER || 'false').toLowerCase() === 'true';

    let od = orderData; // Make mutable for voucher updates
    let applied = null;
    let voucherApplied = false;
    let wantVoucher = true;

    if (AUTO_FNB_USE_VOUCHER) {
      log.info('ğŸŸï¸  Auto-use-voucher F&B: Mencoba gunakan voucher...');
      wantVoucher = true;
    } else {
      const { useVoucher } = await inquirer.prompt([{
        type: 'input',
        name: 'useVoucher',
        message: 'ğŸŸï¸  Gunakan voucher F&B? (Enter=Ya / ketik n untuk Tidak):',
        filter: (s) => String(s||'').trim()
      }]);
      wantVoucher = (useVoucher || '').toLowerCase() !== 'n';
    }

    if (wantVoucher) {
      log.process('Menyiapkan voucher list F&B...');
      const selectRes = await couponSelect(String(od.id), token);
      if (selectRes?.status_code !== 200) {
        log.warning('Gagal memuat daftar voucher. Lewati.');
        await appendJsonLog({ event: 'fnb_coupon_select_failed', response: selectRes });
      } else {
        const coupons = Array.isArray(selectRes?.data?.coupons) ? selectRes.data.coupons : [];
        await appendJsonLog({ event: 'fnb_coupon_list', count: coupons.length, coupons });

        // F&B voucher keywords
        const fnbKeywords = ['popcorn', 'birthday', 'drinks', 'drink', 'food', 'beverage', 'combo', 'makanan', 'minuman'];
        const isFnbLike = (c) => {
          const base = `${c?.name||''} ${c?.type||''} ${c?.discount||''}`.toLowerCase();
          return fnbKeywords.some(k => base.includes(k));
        };
        
        const fnbVouchers = coupons.filter(isFnbLike);
        const others = coupons.filter(c => !isFnbLike(c));

        async function tryApplyFnb(discountCode, couponNumber, couponName) {
          log.process(`Mencoba apply voucher F&B: ${discountCode || couponNumber} â€” ${(couponName || '').slice(0, 50)}`);
          
          // Validate first
          const v = await couponValidate(od.id, discountCode||'', couponNumber||'', token);
          if (v?.status_code !== 200) {
            const errorMsg = v?.message || 'Unknown error';
            const statusCode = v?.status_code || 0;
            
            if (statusCode === 429) {
              log.warning(`Rate limit reached (${statusCode}) - ${errorMsg}`);
            } else if (statusCode === 422) {
              log.warning(`Voucher tidak valid (${statusCode}) - ${errorMsg}`);
            } else {
              log.warning(`Validate gagal (${statusCode}) - ${errorMsg}`);
            }
            
            await appendJsonLog({ event: 'fnb_coupon_validate_failed', code: discountCode, response: v });
            return { ok: false, response: v };
          }
          
          await appendJsonLog({ event: 'fnb_coupon_validated', code: discountCode, data: v?.data });
          log.success('âœ… Validate berhasil, melanjutkan ke pay...');
          
          // Delay before pay
          await delay(3000);
          
          const p = await couponPay(od.id, discountCode||'', couponNumber||'', token);
          if (p?.status_code !== 200) {
            const errorMsg = p?.message || 'Unknown error';
            const statusCode = p?.status_code || 0;
            log.warning(`Pay gagal (${statusCode}) - ${errorMsg}`);
            await appendJsonLog({ event: 'fnb_coupon_pay_failed', code: discountCode, response: p });
            return { ok: false, response: p };
          }
          
          await appendJsonLog({ event: 'fnb_coupon_pay_ok', code: discountCode, data: p?.data });
          return { ok: true, data: p?.data };
        }


        // Enhanced F&B voucher filtering with stricter rules
        function isFnbVoucher(voucherName, voucherType = '') {
          const name = (voucherName || '').toLowerCase();
          const type = (voucherType || '').toLowerCase();
          
          // Clear F&B indicators (DITAMBAH 'disc', 'discount', 'concession(s)' untuk cover "HALLOWEEN DISC F&B 20%")
          const fnbKeywords = [
            'combo', 'popcorn', 'drink', 'food', 'snack', 'beverage',
            'birthday treat', '1st visit', 'free popcorn', 'concession', 'concessions',
            'f&b', 'fnb', 'makanan', 'minuman', 'camilan', 'screen pouch',
            'disc', 'discount'
          ];
          
          // Type 02 is usually F&B related
          if (type === '02') return true;
          
          return fnbKeywords.some(keyword => name.includes(keyword));
        }
        
        function isMovieTicketVoucher(voucherName, voucherType = '') {
          const name = (voucherName || '').toLowerCase();
          const type = (voucherType || '').toLowerCase();
          
          // Clear movie ticket indicators - more comprehensive
          const ticketKeywords = [
            'b1g1f', 'buy 1 get 1', 'tiket', 'ticket', 'film', 'movie',
            'bioskop', 'cinema', '(ats)', 'jangan panggil', 'perempuan pembawa',
            'dilanjutkan salah', 'buy one get one', 'beli 1 gratis 1',
            'sep)', 'okt)', 'nov)', 'des)', '(28 sep)', '(22-26 sep)',
            'possible:ticket', 'item is not for the d/c'
          ];
          
          // Type 01 is usually for tickets
          if (type === '01') return true;
          
          return ticketKeywords.some(keyword => name.includes(keyword));
        }

        // Strict filtering - only try vouchers that are clearly F&B
        const confirmedFnbVouchers = coupons.filter(c => 
          isFnbVoucher(c.name, c.type) && !isMovieTicketVoucher(c.name, c.type)
        );
        
        // Exact match with cart items (for F&B only)
        const exactItemVouchers = confirmedFnbVouchers.filter(c => {
          const vName = (c.name || '').toLowerCase();
          return cart.some(item => 
            vName.includes(item.name.toLowerCase()) || 
            item.name.toLowerCase().includes(vName.split(' ')[0])
          );
        });

        // All movie/ticket vouchers to skip
        const movieTicketVouchers = coupons.filter(c => isMovieTicketVoucher(c.name, c.type));
        
        // Unknown vouchers (not clearly F&B, not clearly tickets) - SKIP ALL
        const unknownVouchers = coupons.filter(c => 
          !isFnbVoucher(c.name, c.type) && !isMovieTicketVoucher(c.name, c.type)
        );

        console.log(chalk.cyan('\nğŸ” ANALISIS VOUCHER F&B (STRICT):'));
        console.log(chalk.green(`   âœ… Confirmed F&B Vouchers: ${confirmedFnbVouchers.length}`));
        console.log(chalk.green(`   ğŸ¯ Exact Item Match: ${exactItemVouchers.length}`));
        console.log(chalk.red(`   ğŸ¬ Movie/Ticket Vouchers: ${movieTicketVouchers.length} (SKIP)`));
        console.log(chalk.gray(`   â“ Unknown Vouchers: ${unknownVouchers.length} (SKIP)`));
        console.log(chalk.cyan('   ğŸ›¡ï¸  Strategy: Hanya coba voucher F&B yang jelas untuk menghindari rate limit'));

        // Only try confirmed F&B vouchers - no more guessing
        const totalFnbTries = Math.min(confirmedFnbVouchers.length, 3); // Max 3 attempts
        
        // Declare autoApplyChoice dengan default value
        let autoApplyChoice = 'skip';
        
        if (confirmedFnbVouchers.length === 0) {
          console.log(chalk.yellow('\nğŸš« AUTO-SKIP VOUCHER AUTO-APPLY'));
          console.log(chalk.cyan('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”'));
          console.log(chalk.cyan('â”‚') + ` âŒ Tidak ada voucher F&B yang teridentifikasi dengan jelas `.padEnd(59) + chalk.cyan('â”‚'));
          console.log(chalk.cyan('â”‚') + ` ğŸ¬ ${movieTicketVouchers.length} voucher tiket/film (tidak relevan untuk F&B) `.padEnd(59) + chalk.cyan('â”‚'));
          if (unknownVouchers.length > 0) {
            console.log(chalk.cyan('â”‚') + ` â“ ${unknownVouchers.length} voucher tidak dikenal (dilewati untuk keamanan) `.padEnd(59) + chalk.cyan('â”‚'));
          }
          console.log(chalk.cyan('â”‚') + ` âš¡ Langsung ke opsi manual input voucher F&B `.padEnd(59) + chalk.cyan('â”‚'));
          console.log(chalk.cyan('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜'));
          
          await appendJsonLog({ 
            event: 'fnb_voucher_auto_apply_skipped', 
            reason: 'no_confirmed_fnb_vouchers',
            movie_vouchers: movieTicketVouchers.length,
            unknown_vouchers: unknownVouchers.length
          });
          log.info('Auto-apply voucher F&B di-skip - langsung ke manual input.');
          // PENTING: paksa ke mode manual agar user bisa pilih dari semua voucher
          autoApplyChoice = 'manual';
        } else {
          console.log(chalk.green(`\nğŸ¯ Ditemukan ${totalFnbTries} voucher F&B yang bisa dicoba:`));
          
          // Show what we're about to try
          confirmedFnbVouchers.slice(0, 3).forEach((v, i) => {
            console.log(chalk.cyan(`   ${i+1}. ${v.discount} - ${v.name} (Type: ${v.type})`));
          });

          // Show comprehensive skip info early
          const totalSkipped = movieTicketVouchers.length + unknownVouchers.length;
          if (totalSkipped > 0) {
            console.log(chalk.yellow(`\nâ­ï¸  AKAN DILEWATI TOTAL ${totalSkipped} VOUCHER untuk menghindari rate limit:`));
            console.log(chalk.red(`   ğŸ¬ ${movieTicketVouchers.length} voucher tiket/film (tidak relevan untuk F&B)`));
            if (unknownVouchers.length > 0) {
              console.log(chalk.gray(`   â“ ${unknownVouchers.length} voucher tidak dikenal (untuk keamanan)`));
            }
            console.log(chalk.cyan('   âœ… Strategi: Fokus hanya pada voucher F&B yang jelas\n'));
          }

          // User choice untuk auto-apply atau skip
          if (AUTO_FNB_USE_VOUCHER) {
            // Auto: langsung ke 'auto' mode
            autoApplyChoice = 'auto';
            log.info('ğŸ¤– Auto-use-voucher F&B: Langsung auto-apply voucher...');
          } else {
            const response = await inquirer.prompt([{
              type: 'list',
              name: 'autoApplyChoice',
              message: 'Cara apply voucher F&B:',
              choices: [
                { name: 'ğŸ¤– Auto-apply voucher F&B (coba otomatis)', value: 'auto' },
                { name: 'âœ‹ Skip auto-apply, langsung pilih manual', value: 'manual' },
                { name: 'â­ï¸ Lewati semua voucher', value: 'skip' }
              ]
            }]);

            autoApplyChoice = response.autoApplyChoice;
          }

          if (autoApplyChoice === 'skip') {
            log.info('User memilih lewati semua voucher F&B.');
            await appendJsonLog({ event: 'fnb_voucher_user_skip_all' });
          } else if (autoApplyChoice === 'manual') {
            log.info('User memilih skip auto-apply, langsung ke manual selection.');
            await appendJsonLog({ event: 'fnb_voucher_user_skip_auto' });
            // Skip semua auto-apply logic, langsung ke manual selection
          } else if (autoApplyChoice === 'auto') {
            // lakukan auto-apply HANYA voucher F&B confirmed
            console.log(chalk.green('\nğŸ¤– Memulai auto-apply voucher F&B...'));
            console.log(chalk.cyan(`ğŸ¯ HANYA akan coba ${confirmedFnbVouchers.length} voucher F&B confirmed (SKIP semua movie vouchers)`));
            
            // 1) Try exact item matches first (if any)
            if (exactItemVouchers.length > 0) {
              log.info('ğŸ¯ Prioritas: Voucher F&B yang match dengan items...');
              for (const c of exactItemVouchers.slice(0, 1)) { // Only 1 exact match attempt
                const res = await tryApplyFnb(c.discount, c.number, c.name);
                if (res.ok) { 
                  applied = { type: 'auto_exact_fnb', coupon: c, data: res.data }; 
                  voucherApplied = true;
                  od = res.data; 
                  break; 
                }

                // Check for rate limit and stop immediately
                if (res.response?.status_code === 429) {
                  console.log(chalk.red('âš ï¸  Rate limit detected - menghentikan semua percobaan'));
                  break;
                }
                
                await delay(10000); // Even longer delay
              }
            }

            // 2) Try other confirmed F&B vouchers (if exact match failed)
            if (!applied) {
              const remainingFnb = confirmedFnbVouchers.filter(c => !exactItemVouchers.includes(c));
              if (remainingFnb.length > 0) {
                log.info('ğŸ¿ Mencoba voucher F&B lainnya...');
                for (const c of remainingFnb.slice(0, 2)) { // Max 2 more attempts
                  const res = await tryApplyFnb(c.discount, c.number, c.name);
                  if (res.ok) { 
                    applied = { type: 'auto_fnb_confirmed', coupon: c, data: res.data }; 
                    voucherApplied = true;
                    od = res.data; 
                    break; 
                  }

                  // Check for rate limit and stop immediately
                  if (res.response?.status_code === 429) {
                    console.log(chalk.red('âš ï¸  Rate limit detected - menghentikan semua percobaan'));
                    break;
                  }
                  
                  await delay(10000); // Even longer delay
                }
              }
            }
            
            // HAPUS BAGIAN "fallback: try other vouchers" - TIDAK BOLEH COBA MOVIE VOUCHERS!
            console.log(chalk.cyan('\nâœ… Auto-apply F&B vouchers complete - TIDAK mencoba movie/ticket vouchers untuk menghindari rate limit'));
          }
        }

        // 3) manual selection (hanya jika belum applied dan user tidak skip all)
        if (!applied && coupons.length && autoApplyChoice !== 'skip') {

          // Jika AUTO_FNB_USE_VOUCHER=true dan tidak ada voucher yang berhasil, skip manual selection
          if (AUTO_FNB_USE_VOUCHER) {
            log.info('â­ï¸  Auto-use-voucher F&B: Tidak ada voucher yang berhasil. Skip manual selection.');
            // Set pickVoucherAction = 'skip' untuk lewati manual selection
            var pickVoucherAction = 'skip';
          } else {
            log.section('ğŸŸï¸ DAFTAR VOUCHER TERSEDIA');
            renderCouponsTable(coupons);

            const response = await inquirer.prompt([{
              type: 'input',
              name: 'pickVoucherInput',
              message: 'Pilih opsi voucher (Enter=lewati voucher / y=pilih voucher):',
              filter: s => String(s || '').trim()
            }]);

            const choice = response.pickVoucherInput.toLowerCase();
            if (!choice) {
              // Enter = lewati voucher
              var pickVoucherAction = 'skip';
              log.info('â­ï¸  Lewati voucher (Enter).');
            } else if (choice === 'y') {
              // y = pilih voucher
              var pickVoucherAction = 'pick';
            } else {
              // Input lain = lewati juga
              var pickVoucherAction = 'skip';
              log.info('â­ï¸  Input tidak dikenal, lewati voucher.');
            }
          }

          if (pickVoucherAction === 'pick') {
            const { chosenVoucher } = await inquirer.prompt([{
              type: 'list',
              name: 'chosenVoucher',
              message: 'Pilih voucher:',
              pageSize: 12,
              choices: coupons.map((c,i) => ({
                name: `${String(i+1).padStart(2,'0')}) ${c.discount || c.number || '-'} | ${c.type || '-'} | ${c.name || '-'}`,
                value: c
              }))
            }]);
            const res = await tryApplyFnb(chosenVoucher.discount, chosenVoucher.number, chosenVoucher.name);
            if (res.ok) {
              applied = { type: 'manual_pick', coupon: chosenVoucher, data: res.data };
              od = res.data;
              log.success(`Voucher diterapkan: ${chosenVoucher.discount || chosenVoucher.number || '(unknown)'}`);
            } else {
              log.error(`Voucher gagal diterapkan: ${res?.response?.message || res?.reason || 'Unknown error'}`);
            }
          } else {
            log.info('Lewati voucher.');
          }
        } else if (applied) {
          console.log(chalk.green('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
          console.log(chalk.green('â”‚') + chalk.white.bold('                 VOUCHER F&B BERHASIL DITERAPKAN            ') + chalk.green('â”‚'));
          console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
          console.log(chalk.green('â”‚') + ` ğŸŸï¸  Code: ${(applied.coupon?.discount || applied.coupon?.number || '').padEnd(40)} ` + chalk.green('â”‚'));
          console.log(chalk.green('â”‚') + ` ğŸ“ Name: ${(applied.coupon?.name || '').slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
          console.log(chalk.green('â”‚') + ` ğŸ¤– Type: ${applied.type.replace('_', ' ').toUpperCase().padEnd(40)} ` + chalk.green('â”‚'));
          console.log(chalk.green('â”‚') + ` ğŸ’° Saving: ${(od.discount_value ? toRp(od.discount_value) : 'TBD').padEnd(35)} ` + chalk.green('â”‚'));
          console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
        }


        // Summary setelah voucher
        if (applied && od) {
          log.section('ğŸ“‹ F&B ORDER SUMMARY (setelah voucher)');
          console.log(chalk.cyan('â•­' + 'â”€'.repeat(75) + 'â•®'));
          console.log(chalk.cyan('â”‚') + '  ' + chalk.white.bold('F&B ORDER DETAILS (UPDATED)').padEnd(73) + chalk.cyan('â”‚'));
          console.log(chalk.cyan('â”œ' + 'â”€'.repeat(75) + 'â”¤'));
          console.log(chalk.cyan('â”‚') + `  Order ID : ${chalk.yellow(String(od.id||'-').padEnd(57))}` + chalk.cyan('â”‚'));
          console.log(chalk.cyan('â”‚') + `  Booking  : ${chalk.yellow(String(od.booking_code||'-').padEnd(57))}` + chalk.cyan('â”‚'));
          console.log(chalk.cyan('â”‚') + `  Discount : ${chalk.yellow(((od.discount_code||'-') + (od.discount_name?` | ${od.discount_name}`:'')).padEnd(57))}` + chalk.cyan('â”‚'));
          console.log(chalk.cyan('â”‚') + `  Subtotal : ${chalk.yellow(toRp(od.sub_total_amount||0).padEnd(57))}` + chalk.cyan('â”‚'));
          console.log(chalk.cyan('â”‚') + `  Total    : ${chalk.yellow(toRp(od.total_amount||0).padEnd(57))}` + chalk.cyan('â”‚'));
          console.log(chalk.cyan('â•°' + 'â”€'.repeat(75) + 'â•¯'));
        }
      }
    } else {
      log.info('Lewati voucher (permintaan pengguna).');
    }

    // Update order data setelah voucher (jika ada perubahan)
    if (applied && applied.data) {
      od = applied.data;
    }


    // ===== VALIDASI TOTAL SETELAH VOUCHER =====
    const totalAmount = Number(od.total_amount || 0);
    let monitorResult = null;

// Check if voucher was applied and made order free
if (applied && totalAmount <= 0) {
  console.log(chalk.green('\nğŸ‰ PESANAN F&B GRATIS - OTOMATIS COMPLETE!'));
  console.log(chalk.green('â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
  console.log(chalk.green('â”‚') + chalk.white.bold('                   F&B ORDER COMPLETE (FREE)               ') + chalk.green('â”‚'));
  console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
  console.log(chalk.green('â”‚') + ` ğŸ‰ Total: ${toRp(totalAmount)} - Tidak perlu bayar!`.padEnd(56) + ' ' + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` ğŸŸï¸  Booking: ${(od.booking_code || '-').padEnd(40)} ` + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` ğŸ¿ Status: Order sudah complete otomatis!`.padEnd(56) + ' ' + chalk.green('â”‚'));
  console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
  console.log(chalk.green('â”‚') + ` âœ… F&B siap diambil dengan booking code di counter F&B    ` + chalk.green('â”‚'));
  console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
  
  await appendJsonLog({ 
    event: 'fnb_free_order_complete', 
    order_id: od.id, 
    total: totalAmount,
    voucher_used: od.discount_code 
  });

  // ğŸ”‘ Ekstrak passKey & Sales ID lebih dulu
  let passKeyForFnb = null;
  try {
    const src = od || {};
    passKeyForFnb =
      src.pass_key ||
      src.passKey ||
      (src.data && (src.data.pass_key || src.data.passKey)) ||
      (src.ticket && (src.ticket.pass_key || src.ticket.passKey)) ||
      (src.qr_code && (src.qr_code.pass_key || src.qr_code.passKey)) ||
      null;

    if (passKeyForFnb) {
      console.log(chalk.gray(`ğŸ”‘ Detected F&B passKey (FREE): ${passKeyForFnb}`));
    } else {
      console.log(chalk.yellow('â„¹ï¸ passKey F&B (FREE) tidak ditemukan di object order, lanjut tanpa passKey.'));
    }
  } catch (e) {
    console.log(chalk.yellow(`âš ï¸ Gagal ekstrak passKey F&B FREE: ${e.message}`));
  }

  const salesIdForFnb = extractSalesIdFromOrder(od);
  if (salesIdForFnb) {
    console.log(chalk.gray(`ğŸ†” Detected F&B Sales ID (FREE): ${salesIdForFnb}`));
  } else {
    console.log(chalk.yellow('â„¹ï¸ Sales ID F&B (FREE) tidak ditemukan, akan ditampilkan "-" di Telegram.'));
  }

  // Generate F&B receipt for free order
  console.log(chalk.cyan('\nğŸ“„ Generating F&B receipt (FREE ORDER)...'));

  const freeOrderReceiptData = {
    fnbItems: cart.map(c=>c.name).join(', '),
    cinemaName: selectedCinema.name,
    date: saleDate.slice(6,8) + '/' + saleDate.slice(4,6) + '/' + saleDate.slice(0,4),
    bookingCode: od.booking_code,
    salesId: salesIdForFnb,          // âœ… BUKAN od.id LAGI
    passKey: passKeyForFnb || null,  // âœ… MASUKKAN passKey ke data
    totalAmount: 'FREE (Rp0)',
    itemDetails: cart.map(c => ({
      name: c.name,
      qty: c.quantity,
      customizations: c.customizations?.map(x => x.SUB_ITEM_NM) || []
    }))
  };

  // Send FREE order to Telegram with QR (booking + passKey)
  const freeOrderWithQR = {
    ...freeOrderReceiptData,
    totalAmount: 'FREE (Rp0)',
    // âœ… TAMBAHKAN account info untuk Telegram
    accountEmail: selectedAccount?.email,
    accountPassword: selectedAccount?.password,
    accountName: selectedAccount?.name
  };

  // Check env untuk send QR ke Telegram
  const sendQrFnb = (process.env.SEND_QR_TO_TELEGRAM_FNB || 'false').toLowerCase() === 'true';
  await sendFnBOrderWithQR(freeOrderWithQR, { sendToTelegram: sendQrFnb });



      // âœ… AUTO LOGIN + SCREENSHOT FREE F&B ORDER
      try {
        const accForLogin = selectedAccount || {};
        // FREE order pakai order ID sebagai salesId fallback
        // ğŸ”„ FREE order juga coba cari Sales ID yang benar
        let salesIdForScreenshot = od.sales_id || null;
        
        if (!salesIdForScreenshot) {
          try {
            const txRes = await fetchMembershipTransactions(token);
            const picked = pickRelevantFnbTransaction(
              txRes?.data || [],
              {
                completeDate: new Date().toISOString(),
                orderId: od.id,
                bookingCode: od.booking_code,
                passKey: passKeyForFnb,  // â† gunakan passKey hasil ekstrak
                totalAmount: 0, // FREE order
                fnbItems: cart[0]?.name || 'F&B'
              },
              { preferComplete: true }
            );
            salesIdForScreenshot = picked?.sales_id || od.id;
            console.log(chalk.green(`âœ… FREE F&B Sales ID: ${salesIdForScreenshot}`));
          } catch {
            salesIdForScreenshot = od.id; // fallback ke Order ID
          }
        }

        if (salesIdForScreenshot && accForLogin?.email && accForLogin?.password) {
          console.log(chalk.cyan('\nğŸŒ Auto login m.cgv.id mobile & screenshot FREE F&B tiket...'));

// âœ… SET lastFnbCartSnapshot UNTUK FREE ORDER (agar customizations muncul di filename)
if (Array.isArray(cart) && cart.length) {
  lastFnbCartSnapshot = cart.map(item => ({
    ...item,
    customizations: Array.isArray(item.customizations)
      ? item.customizations.map(x => ({ ...x }))
      : []
  }));
  console.log(chalk.gray(`ğŸ“¦ Cart snapshot saved for filename (${cart.length} items, ${cart.flatMap(c => c.customizations || []).length} customizations)`));
}

// Extract customizations dari cart untuk screenshot
const allCustomizations = cart.flatMap(item =>
  (item.customizations || []).map(c => ({
    SUB_ITEM_NM: c.SUB_ITEM_NM || c.name,
    name: c.name || c.SUB_ITEM_NM
  }))
);

// Check env untuk send screenshot ke Telegram
const sendScreenshotFnb = (process.env.SEND_SCREENSHOT_TO_TELEGRAM_FNB || 'false').toLowerCase() === 'true';

const screenshotResult = await loginAndScreenshotFnbTicket({
  salesId: salesIdForScreenshot,  // âœ… USE salesIdForScreenshot
  email: accForLogin.email,
  password: accForLogin.password,
  bookingCode: od.booking_code,   // âœ… USE od.booking_code
  passKey: passKeyForFnb,         // âœ… USE passKeyForFnb
  outDir: 'orders',
  headless: true,
  sendToTelegram: sendScreenshotFnb, // âœ… USE ENV VARIABLE
  accountEmail: accForLogin.email,      // âœ… TAMBAHKAN
  accountPassword: accForLogin.password,// âœ… TAMBAHKAN
  accountName: accForLogin.name,        // âœ… TAMBAHKAN
  fnbItems: freeOrderReceiptData.fnbItems,     // âœ… USE freeOrderReceiptData
  fnbDetail: freeOrderReceiptData.itemDetails, // âœ… USE freeOrderReceiptData
  customizations: allCustomizations,  // âœ… PASS CUSTOMIZATIONS dari cart
  cinemaName: freeOrderReceiptData.cinemaName  // âœ… PASS CINEMA NAME
});

          
          if (screenshotResult.success) {
            console.log(chalk.green(`ğŸ“¸ Screenshot berhasil: ${screenshotResult.path}`));
            await appendJsonLog({ 
              event: 'fnb_free_mobile_screenshot_success', 
              file: screenshotResult.path,
              sales_id: salesIdForScreenshot,
              booking_code: od.booking_code,
              pass_key: passKeyForFnb || null
            });
          } else {
            console.log(chalk.yellow(`âš ï¸ Screenshot gagal: ${screenshotResult.error}`));
            await appendJsonLog({ 
              event: 'fnb_free_mobile_screenshot_failed', 
              error: screenshotResult.error,
              sales_id: salesIdForScreenshot,
              booking_code: od.booking_code,
              pass_key: passKeyForFnb || null
            });
          }
        } else {
          console.log(chalk.yellow('â„¹ï¸ Skip screenshot (butuh salesId + email + password).'));
        }
      } catch (e) {
        console.log(chalk.red(`âŒ Screenshot error: ${e.message}`));
        await appendJsonLog({ 
          event: 'fnb_free_mobile_screenshot_error', 
          error: e.message,
          sales_id: od.id,
          booking_code: od.booking_code,
          pass_key: passKeyForFnb || null
        });
      }

      
      // Set status complete untuk summary
      monitorResult = { 
        status: 'success', 
        order: { 
          ...od, 
          complete_date: new Date().toISOString(),
          payment_method: 'FREE (Voucher)'
        } 
      };

    } else {
      // ===== PAYMENT FLOW F&B (JIKA MASIH ADA YANG HARUS DIBAYAR) =====
      const AUTO_FNB_PAYMENT_AFTER_VOUCHER = String(process.env.AUTO_FNB_PAYMENT_AFTER_VOUCHER || 'false').toLowerCase() === 'true';
      const AUTO_FNB_PAYMENT_WITHOUT_VOUCHER = String(process.env.AUTO_FNB_PAYMENT_WITHOUT_VOUCHER || 'false').toLowerCase() === 'true';

      let nextAction = '';

      if (applied && AUTO_FNB_PAYMENT_AFTER_VOUCHER) {
        // Voucher berhasil diterapkan, auto payment
        log.info('ğŸ’³ Voucher F&B berhasil. Auto payment enabled. Lanjut ke pembayaran...');
        nextAction = 'pay';
      } else if (!applied && AUTO_FNB_PAYMENT_WITHOUT_VOUCHER) {
        // Tidak ada voucher, auto payment
        log.info('ğŸ’³ Tidak ada voucher F&B. Auto payment enabled. Lanjut ke pembayaran...');
        nextAction = 'pay';
      } else {
        // Manual prompt
        const answer = await inquirer.prompt([{
          type: 'list',
          name: 'nextAction',
          message: 'Langkah berikutnya?',
          choices: [
            { name: 'ğŸ’³ Lanjut ke pembayaran', value: 'pay' },
            { name: 'ğŸ›‘ Batalkan pesanan (cancel order)', value: 'cancel' },
            { name: 'ğŸ’¾ Simpan pesanan (bayar nanti)', value: 'save' }
          ]
        }]);
        nextAction = answer.nextAction;
      }


    // --- Helper lokal untuk pesan Telegram pembayaran F&B ---
    const extractTelegramIds = (msg) => {
      if (!msg) return { chatId: null, messageId: null };
      const base = msg.result || msg; // support bentuk {result:{...}} atau langsung {...}
      const chatId =
        base.chat_id ||
        base.chatId ||
        (base.chat && base.chat.id) ||
        null;
      const messageId =
        base.message_id ||
        base.messageId ||
        null;
      return { chatId, messageId };
    };


    // Auto cleanup pesan Telegram payment init F&B kalau status sudah final
async function cleanupFnbTelegramPaymentMessage(finalStatus, orderForLog) {
  try {
    if (!lastFnbPaymentTelegramMsgId) return;

    const rawStatus = finalStatus;
    const norm = (rawStatus ? String(rawStatus) : '').trim().toLowerCase();

    // status "belum final" (biarin aja, jangan hapus)
    const isPendingLike =
      !norm ||
      norm === 'pending' ||
      norm === 'waiting' ||
      norm === 'wait';

    if (isPendingLike) return;

    console.log(
      chalk.gray(
        `[FNB/TG] Status final "${norm}" â†’ hapus pesan Telegram payment init #${lastFnbPaymentTelegramMsgId}`
      )
    );

    try {
      // asumsi kamu sudah punya helper ini (dipakai juga di movie)
      await deleteTelegramMessageSafe(lastFnbPaymentTelegramMsgId);

      await appendJsonLog({
        event: 'fnb_telegram_payment_init_deleted',
        order_id: orderForLog?.id,
        status: rawStatus,
        message_id: lastFnbPaymentTelegramMsgId
      });
    } catch (eDel) {
      console.log(
        chalk.yellow(
          `[FNB/TG] Gagal hapus pesan Telegram: ${eDel.message || eDel}`
        )
      );
      await appendJsonLog({
        event: 'fnb_telegram_payment_init_delete_failed',
        order_id: orderForLog?.id,
        status: rawStatus,
        message_id: lastFnbPaymentTelegramMsgId,
        error: String(eDel)
      });
    } finally {
      // supaya nggak kepakai di sesi berikut
      lastFnbPaymentTelegramMsgId = null;
    }
  } catch (e) {
    console.log(
      chalk.yellow(
        `[FNB/TG] Error di cleanupFnbTelegramPaymentMessage: ${e.message || e}`
      )
    );
  }
}

    const deleteTelegramMessageSafe = async (chatId, messageId) => {
      try {
        if (!chatId || !messageId) return;
        if (!TELEGRAM_BOT_TOKEN) {
          console.log(chalk.gray('Telegram delete skipped: TELEGRAM_BOT_TOKEN not set'));
          return;
        }
        const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/deleteMessage`;
        await requestJson('POST', url, {
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ chat_id: chatId, message_id: messageId }),
          note: 'telegram-delete-fnb-payment-message'
        });
      } catch (e) {
        console.log(chalk.gray(`Telegram deleteMessage failed: ${e.message || e}`));
      }
    };

    let fnbTelegramMessage = null;

      if (nextAction === 'pay') {
      log.process('Memuat metode pembayaran...');
      const payRes = await fetchPaymentMethods(token);
      if (payRes?.status_code !== 200) {
        log.error('Gagal ambil metode pembayaran.');
        await appendJsonLog({ event: 'fnb_payments_failed', response: payRes });
      } else {

        // === MINI HELPERS E-WALLET (GOPAY & QRIS) ===
        const findGopay = (resp) => {
          const data = resp?.data || [];
          for (const cat of data) {
            const catId = String(
              cat.category_id ?? cat.id ?? cat.categoryId ?? cat.categoryID ?? ''
            );
            if (catId !== '2') continue; // E-WALLET
            for (const it of (cat.items || [])) {
              if (!it?.status) continue; // hanya yg aktif
              const name = String(it.name || '');
              const id   = String(it.id || '');
              if (includesIgnoreCase(name, 'GOPAY') || id === '1') {
                return {
                  ...it,
                  payment_id: String(it.payment_id || it.id),
                  category_id: catId,
                  category: cat.name,
                };
              }
            }
          }
          return null;
        };

        const findQris = (resp) => {
          const data = resp?.data || [];
          for (const cat of data) {
            const catId = String(
              cat.category_id ?? cat.id ?? cat.categoryId ?? cat.categoryID ?? ''
            );
            if (catId !== '2') continue; // E-WALLET
            for (const it of (cat.items || [])) {
              if (!it?.status) continue; // hanya yg aktif
              const name = String(it.name || '');
              const id   = String(it.id || '');
              if (includesIgnoreCase(name, 'QRIS') || id === '2') {
                return {
                  ...it,
                  payment_id: String(it.payment_id || it.id),
                  category_id: catId,
                  category: cat.name,
                };
              }
            }
          }
          return null;
        };

        const findDana = (resp) => {
          const data = resp?.data || [];
          for (const cat of data) {
            const catId = String(
              cat.category_id ?? cat.id ?? cat.categoryId ?? cat.categoryID ?? ''
            );
            if (catId !== '2') continue; // E-WALLET
            for (const it of (cat.items || [])) {
              if (!it?.status) continue; // hanya yg aktif
              const name = String(it.name || '');
              const id   = String(it.id || '');
              if (includesIgnoreCase(name, 'DANA') || id === '5') {
                return {
                  ...it,
                  payment_id: String(it.payment_id || it.id),
                  category_id: catId,
                  category: cat.name,
                };
              }
            }
          }
          return null;
        };

        const findShopeepay = (resp) => {
          const data = resp?.data || [];
          for (const cat of data) {
            const catId = String(
              cat.category_id ?? cat.id ?? cat.categoryId ?? cat.categoryID ?? ''
            );
            if (catId !== '2') continue; // E-WALLET
            for (const it of (cat.items || [])) {
              if (!it?.status) continue; // hanya yg aktif
              const name = String(it.name || '');
              if (includesIgnoreCase(name, 'SHOPEE')) {
                return {
                  ...it,
                  payment_id: String(it.payment_id || it.id),
                  category_id: catId,
                  category: cat.name,
                };
              }
            }
          }
          return null;
        };

        // === MINI HELPERS (khusus CGV Point) â€” ditaruh lokal biar nggak ubah struktur file lain ===
        const cgvPointSelect = async (orderId, token) => {
          const url = `${baseURL}/api/orders/cgv-point/select`;
          const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
          const parts = [
            `--${boundary}`,
            `Content-Disposition: form-data; name="order_id"`,
            ``,
            String(orderId),
            `--${boundary}--`
          ];
          const body = parts.join('\r\n');
          const { json } = await requestJson('POST', url, {
            headers: { Authorization: `Bearer ${token}`, 'content-type': `multipart/form-data; boundary=${boundary}` },
            body
          });
          return json || { status_code: 500, data: null };
        };

        const cgvPointPay = async (orderId, fields, token) => {
          const url = `${baseURL}/api/orders/cgv-point/pay`;
          const boundary = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
          const payload = {
            order_id: String(orderId),
            pin: String(fields.pin || ''),
            member_grade_id: String(fields.member_grade_id || '03'),
            member_tier_id:  String(fields.member_tier_id  || '03'),
            customer_name:    String(fields.customer_name   || ''),
            customer_phone:   String(fields.customer_phone  || ''),
            customer_email:   String(fields.customer_email  || ''),
            customer_address: String(fields.customer_address|| ''),
            customer_city:    String(fields.customer_city   || ''),
            customer_post_code: String(fields.customer_post_code || '')
          };
          const parts = [];
          Object.entries(payload).forEach(([k,v]) => {
            parts.push(`--${boundary}`);
            parts.push(`Content-Disposition: form-data; name="${k}"`);
            parts.push('');
            parts.push(v);
          });
          parts.push(`--${boundary}--`);
          const body = parts.join('\r\n');
          const { json } = await requestJson('POST', url, {
            headers: { Authorization: `Bearer ${token}`, 'content-type': `multipart/form-data; boundary=${boundary}` },
            body
          });
          return json || { status_code: 500, data: null };
        };
        // === END MINI HELPERS ===

        // Baca konfigurasi default payment F&B dari .env
        const defaultPaymentFnb = (process.env.DEFAULT_PAYMENT_FNB || 'GOPAY').toUpperCase();

        let selectedMethod = '';
        let cgvPointFailed = false;
        let cgvPointSuccess = false;

        // Check if auto payment is enabled
        const autoPaymentEnabled =
          (applied && AUTO_FNB_PAYMENT_AFTER_VOUCHER) ||
          (!applied && AUTO_FNB_PAYMENT_WITHOUT_VOUCHER);

        let useDefaultDana = '';

        if (autoPaymentEnabled) {
          // Auto payment: langsung pakai default dari env, no prompt
          useDefaultDana = ''; // Empty = use default
          log.info(`ğŸ’³ Auto payment F&B menggunakan: ${defaultPaymentFnb}`);
        } else {
          // Manual: prompt user untuk pilih payment method
          // Dynamic prompt message based on env config for F&B
          let promptMessage;
          if (defaultPaymentFnb === 'POINT' || defaultPaymentFnb === 'CGV_POINT' || defaultPaymentFnb === 'CGVPOINT') {
            promptMessage = 'Auto CGV POINT untuk F&B? (Enter=CGV Point / ketik d untuk DANA / ketik g untuk GOPAY / ketik s untuk SHOPEEPAY / ketik q untuk QRIS / ketik y untuk pilih metode lain):';
          } else if (defaultPaymentFnb === 'GOPAY') {
            promptMessage = 'Auto GOPAY (E-WALLET) untuk F&B? (Enter=GOPAY / ketik d untuk DANA / ketik s untuk SHOPEEPAY / ketik q untuk QRIS / ketik y untuk pilih metode lain / ketik p untuk CGV Point):';
          } else if (defaultPaymentFnb === 'SHOPEEPAY') {
            promptMessage = 'Auto SHOPEEPAY (E-WALLET) untuk F&B? (Enter=SHOPEEPAY / ketik d untuk DANA / ketik g untuk GOPAY / ketik q untuk QRIS / ketik y untuk pilih metode lain / ketik p untuk CGV Point):';
          } else if (defaultPaymentFnb === 'QRIS') {
            promptMessage = 'Auto QRIS untuk F&B? (Enter=QRIS / ketik d untuk DANA / ketik g untuk GOPAY / ketik s untuk SHOPEEPAY / ketik y untuk pilih metode lain / ketik p untuk CGV Point):';
          } else {
            promptMessage = 'Auto DANA (E-WALLET) untuk F&B? (Enter=DANA / ketik g untuk GOPAY / ketik s untuk SHOPEEPAY / ketik q untuk QRIS / ketik y untuk pilih metode lain / ketik p untuk CGV Point):';
          }

          const response = await inquirer.prompt([{
            type: 'input',
            name: 'useDefaultDana',
            filter: (s)=>String(s||'').trim().toLowerCase(),
            message: promptMessage
          }]);
          useDefaultDana = response.useDefaultDana;
        }

        // Determine payment method based on env config and user input
        if (useDefaultDana === 'y' || useDefaultDana === 'p' || useDefaultDana === 'g' || useDefaultDana === 'd' || useDefaultDana === 'q' || useDefaultDana === 's') {
          selectedMethod = useDefaultDana;
        } else {
          // Enter pressed - use default from env
          if (defaultPaymentFnb === 'POINT' || defaultPaymentFnb === 'CGV_POINT' || defaultPaymentFnb === 'CGVPOINT') {
            selectedMethod = 'p';
          } else if (defaultPaymentFnb === 'GOPAY') {
            selectedMethod = 'g';
          } else if (defaultPaymentFnb === 'SHOPEEPAY') {
            selectedMethod = 's';
          } else if (defaultPaymentFnb === 'QRIS') {
            selectedMethod = 'q';
          } else {
            selectedMethod = 'd';
          }
        }

        const defaultDana = (selectedMethod === 'd');


        // === Jalur cepat CGV POINT (shortcut "p") ===
        if (selectedMethod === 'p') {
          log.section('ğŸ’  PEMBAYARAN â€” CGV POINT (F&B)');

          // Get member info for point balance
          let pointBalance = null, memberCtx = null;
          try {
            const url = `${baseURL}/api/membership/info`;
            const { json } = await requestJson('POST', url, {
              headers: { Authorization: `Bearer ${token}` },
              body: ''
            });
            if (json?.status_code === 200) {
              const m = json?.data?.RESULTS?.ds_mbrList || null;
              if (m) {
                pointBalance = Number(m.ACCU_POINT ?? m.MILEAGE_AMT ?? 0);
                memberCtx = {
                  name: m.MBR_NM || null,
                  gradeId: m.MBR_GRD_CD || '03',
                  tierId: m.MBR_TIER_CD || '03',
                  phone: (m.MOBILE_NO || '').replace(/[^0-9]/g,''),
                  email: m.EMAIL_ID || null,
                  city: m.ADDR_REGION_NM || null
                };
              }
            }
          } catch {}

          if (pointBalance != null) {
            console.log(multilineBox([
              `Saldo Point : ${pointBalance}`,
              `Sumber      : getMemberInfo()`
            ]));
          }

          // Select CGV Point
          const selPt = await cgvPointSelect(od.id, token);
          if (selPt?.status_code !== 200) {
            const selMsg = String(selPt?.message || '').trim();
            log.error(`Select CGV Point gagal: ${selMsg}`);
            await appendJsonLog({ event: 'fnb_payment_point_select_failed', order_id: od.id, response: selPt });

            // Fallback jika CGV Point tidak bisa digunakan (e.g., dengan voucher/coupon)
            if (/cannot be used together with coupon|cannot be used with voucher/i.test(selMsg)) {
              cgvPointFailed = true;

              const fallbackPaymentFnb = (process.env.FALLBACK_PAYMENT_FNB || 'GOPAY').toUpperCase();

              log.warning('âš ï¸  CGV Point tidak bisa digunakan bersama voucher/coupon.');
              log.info(`ğŸ”„ Fallback ke metode pembayaran cadangan: ${fallbackPaymentFnb}`);

              // Set selected method ke fallback payment
              if (fallbackPaymentFnb === 'GOPAY') {
                selectedMethod = 'g';
              } else if (fallbackPaymentFnb === 'SHOPEEPAY') {
                selectedMethod = 's';
              } else if (fallbackPaymentFnb === 'QRIS') {
                selectedMethod = 'q';
              } else {
                selectedMethod = 'd'; // Default DANA
              }
            }
          } else {
            await appendJsonLog({ event: 'fnb_payment_point_select_ok', order_id: od.id, data: selPt?.data });

            // Summary before PIN
            log.section('ğŸ§¾ F&B PAYMENT SUMMARY');
            const preLines = [];
            preLines.push(`F&B Items  : ${cart.map(c => c.name).join(', ')}`);
            preLines.push(`Cinema     : ${selectedCinema?.name || '-'}`);
            preLines.push(`Location   : ${selectedCinema?.location_name || selectedCinema?.city || '-'}`);
            preLines.push(`Date       : ${saleDate ? `${saleDate.slice(6,8)}/${saleDate.slice(4,6)}/${saleDate.slice(0,4)}` : '-'}`);
            preLines.push(`Metode     : CGV Point`);
            preLines.push(`Order ID   : ${od.id}`);
            preLines.push(`Booking    : ${od.booking_code}`);
            preLines.push(`Subtotal   : ${toRp(od.sub_total_amount || 0)}`);
            preLines.push(`Total      : ${toRp(od.total_amount || 0)}`);
            preLines.push(`Batas Waktu: ${od.expired_date || '-'}`);
            console.log(multilineBox(preLines));

            // PIN Strategy: 1x auto ENV, then 2x manual input, then fallback
            const defaultPin = process.env.SET_PIN || '121212';
            let pinRetryCount = 0;
            const maxPinRetry = 3; // Total 3 attempts: 1 auto + 2 manual
            let payPt = null;
            let currentPin = defaultPin;

            while (pinRetryCount < maxPinRetry) {
              // Attempt 1: Auto dari ENV (silent)
              if (pinRetryCount === 0) {
                log.info(`ğŸ” Menggunakan PIN otomatis dari ENV: ${currentPin}`);
              }
              // Attempt 2 & 3: Prompt user manual
              else {
                const { manualPin } = await inquirer.prompt([{
                  type: 'password',
                  name: 'manualPin',
                  message: `Masukkan PIN CGV Point yang benar (attempt ${pinRetryCount + 1}/${maxPinRetry}):`,
                  mask: '*',
                  filter: s => String(s || '').trim()
                }]);
                currentPin = manualPin || currentPin;
                log.info(`ğŸ” Menggunakan PIN manual: ${currentPin}`);
              }

              payPt = await cgvPointPay(od.id, {
                pin: currentPin,
                member_grade_id: memberCtx?.gradeId || '03',
                member_tier_id: memberCtx?.tierId || '03',
                customer_name: memberCtx?.name || selectedAccount?.name || '',
                customer_phone: memberCtx?.phone || '',
                customer_email: memberCtx?.email || selectedAccount?.email || '',
                customer_address: '',
                customer_city: memberCtx?.city || '',
                customer_post_code: ''
              }, token);

              const sc = payPt?.status_code;
              const msg = String(payPt?.message || '').trim();

              // Success
              if (sc === 200) {
                break;
              }

              // Invalid PIN
              if (sc === 422 && /invalid\s*pin/i.test(msg)) {
                pinRetryCount++;
                console.log(chalk.red(`\nâŒ PIN CGV Point salah (attempt ${pinRetryCount}/${maxPinRetry})`));
                console.log(multilineBox([
                  `Status Code   : ${sc}`,
                  `Message       : ${msg}`,
                  `PIN Digunakan : ${currentPin}`
                ]));

                if (pinRetryCount >= maxPinRetry) {
                  log.warning(`âš ï¸  PIN salah setelah ${maxPinRetry}x percobaan.`);
                  log.info('ğŸ”„ Fallback ke metode pembayaran cadangan.');

                  cgvPointFailed = true;
                  const fallbackPaymentFnb = (process.env.FALLBACK_PAYMENT_FNB || 'GOPAY').toUpperCase();
                  log.info(`ğŸ”„ Fallback ke: ${fallbackPaymentFnb}`);

                  await appendJsonLog({
                    event: 'fnb_payment_point_invalid_pin_fallback',
                    order_id: od.id,
                    fallback_method: fallbackPaymentFnb
                  });

                  // Set ke fallback method
                  if (fallbackPaymentFnb === 'GOPAY') {
                    selectedMethod = 'g';
                  } else if (fallbackPaymentFnb === 'SHOPEEPAY') {
                    selectedMethod = 's';
                  } else if (fallbackPaymentFnb === 'QRIS') {
                    selectedMethod = 'q';
                  } else {
                    selectedMethod = 'd'; // DANA
                  }
                  break;
                }
              } else {
                // Other errors (insufficient balance, dll) - tidak retry
                break;
              }
            }

            if (payPt?.status_code === 200) {
              log.success('CGV Point payment berhasil!');
              await appendJsonLog({ event: 'fnb_payment_point_pay_ok', order_id: od.id, data: payPt?.data });

              // ğŸ”’ SET lastFnbCartSnapshot UNTUK CGV POINT (agar customizations muncul di filename)
              if (Array.isArray(cart) && cart.length) {
                lastFnbCartSnapshot = cart.map(item => ({
                  ...item,
                  customizations: Array.isArray(item.customizations)
                    ? item.customizations.map(x => ({ ...x }))
                    : []
                }));
                const totalCustoms = cart.flatMap(c => c.customizations || []).length;
                console.log(chalk.gray(`ğŸ“¦ [CGV POINT] Cart snapshot saved for filename (${cart.length} items, ${totalCustoms} customizations)`));
                if (totalCustoms > 0) {
                  cart.forEach((item, idx) => {
                    console.log(chalk.gray(`   Item ${idx + 1}: ${item.name} (${item.customizations?.length || 0} customs)`));
                    (item.customizations || []).forEach((c, cidx) => {
                      console.log(chalk.gray(`     ${cidx + 1}. ${c.SUB_ITEM_NM || c.name || 'Unknown'}`));
                    });
                  });
                }
              }

              // Monitor payment
              monitorResult = await monitorFnbPaymentLoop({
                orderId: od.id,
                token,
                cinema: selectedCinema,
                fnbItems: cart.map(c => c.name).join(', '),
                selectedAccount,
                methodLabel: 'CGV Point',
                telegramMessage: null
              });

              cgvPointSuccess = true;
            } else if (!cgvPointFailed) {
              // Error handling untuk kasus selain success/invalid PIN (yang sudah di-handle di retry loop)
              const sc = payPt?.status_code;
              const msg = String(payPt?.message || '').trim();

              log.error(`CGV Point Pay gagal: ${payPt?.message || 'Unknown error'}`);
              console.log(chalk.gray('ğŸ” FULL JSON (debug):'));
              console.log(chalk.gray(JSON.stringify(payPt, null, 2)));
              await appendJsonLog({ event: 'fnb_payment_point_pay_failed', order_id: od.id, response: payPt });

              // Fallback jika insufficient balance
              if (sc === 422 && /insufficient\s*balance/i.test(msg)) {
                cgvPointFailed = true;

                const fallbackPaymentFnb = (process.env.FALLBACK_PAYMENT_FNB || 'GOPAY').toUpperCase();

                log.warning('âš ï¸  CGV Point gagal (saldo tidak cukup).');
                log.info(`ğŸ”„ Fallback ke metode pembayaran cadangan: ${fallbackPaymentFnb}`);

                // Set selected method ke fallback payment
                if (fallbackPaymentFnb === 'GOPAY') {
                  selectedMethod = 'g';
                } else if (fallbackPaymentFnb === 'SHOPEEPAY') {
                  selectedMethod = 's';
                } else if (fallbackPaymentFnb === 'QRIS') {
                  selectedMethod = 'q';
                } else {
                  selectedMethod = 'd'; // Default DANA
                }
              } else {
                log.error('âŒ CGV Point gagal dengan error lain.');
              }
            }
          }
        }

        // Continue with fallback payment if CGV Point failed
        if (!cgvPointSuccess && selectedMethod === 'g') {
          log.section('ğŸ’³ PEMBAYARAN â€” GOPAY (shortcut g)');
          const gopay = findGopay(payRes);

          if (!gopay) {
            log.warning('Metode GOPAY tidak tersedia saat ini. Tampilkan daftar metode sebagai alternatif.');
            log.section('ğŸ’³ METODE PEMBAYARAN');
            renderPaymentMethodsTable(payRes);
          } else {
            log.process('Menyiapkan payment partner (select)...');
            const sel = await paymentPartnerSelect(
              String(od.id),
              String(gopay.category_id),
              String(gopay.payment_id),
              token
            );

            if (sel?.status_code !== 200) {
              log.error(`Select payment partner GOPAY gagal: ${sel?.message || 'Unknown error'}`);
              await appendJsonLog({
                event: 'fnb_payment_partner_select_failed',
                response: sel,
                order_id: od.id,
                method: gopay
              });
            } else {
              await appendJsonLog({
                event: 'fnb_payment_partner_selected',
                order_id: od.id,
                method: gopay,
                data: sel?.data
              });

              log.process('Memproses pembayaran F&B (pay) via GOPAY...');
              const pay = await paymentPartnerPay(String(od.id), token);

              if (pay?.status_code !== 200) {
                log.error(`Payment init GOPAY gagal: ${pay?.message || 'Unknown error'}`);
                await appendJsonLog({
                  event: 'fnb_payment_partner_pay_failed',
                  response: pay,
                  order_id: od.id
                });
              } else {
                const pdata = pay.data || {};
                od = pdata;

                await appendJsonLog({
                  event: 'fnb_payment_partner_pay_ok',
                  order_id: od.id,
                  data: pdata
                });

                // Get order detail untuk ambil payment_gateway_transaction_id & booking_code
                let checkoutUrl = '';
                let qrString = '';
                let qrDataUrl = '';

                // RETRY LOGIC: Coba sampai dapat transaction_id (max 10x dengan delay)
                let transactionId = null;
                let retryCount = 0;
                const maxRetries = 10;
                const retryDelay = 1000; // 1 detik

                while (!transactionId && retryCount < maxRetries) {
                  try {
                    const orderDetail = await fetchOrderDetail(od.id, token);
                    if (orderDetail?.status_code === 200 && orderDetail?.data) {
                      const detailData = orderDetail.data;

                      // Update od with detail data (termasuk booking_code jika ada)
                      if (detailData.booking_code) {
                        od.booking_code = detailData.booking_code;
                      }

                      transactionId = detailData.payment_gateway_transaction_id;

                      if (transactionId) {
                        console.log(chalk.green(`âœ… Transaction ID ditemukan: ${transactionId}`));
                        break; // Keluar dari loop
                      } else {
                        retryCount++;
                        if (retryCount < maxRetries) {
                          console.log(chalk.yellow(`â³ Transaction ID belum tersedia, retry ${retryCount}/${maxRetries}...`));
                          await delay(retryDelay);
                        }
                      }
                    } else {
                      retryCount++;
                      if (retryCount < maxRetries) {
                        console.log(chalk.yellow(`â³ Order detail belum siap, retry ${retryCount}/${maxRetries}...`));
                        await delay(retryDelay);
                      }
                    }
                  } catch (err) {
                    retryCount++;
                    if (retryCount < maxRetries) {
                      console.log(chalk.yellow(`âš ï¸ Error fetch order detail: ${err.message}, retry ${retryCount}/${maxRetries}...`));
                      await delay(retryDelay);
                    }
                  }
                }

                // Process transaction_id if found
                if (transactionId) {
                  // Buat URL Midtrans QR Code dari transaction ID
                  checkoutUrl = `${MIDTRANS_GOPAY_API_URL}/${transactionId}/qr-code`;
                  await appendJsonLog({
                    event: 'fnb_gopay_midtrans_qr_generated',
                    order_id: od.id,
                    transaction_id: transactionId,
                    qr_url: checkoutUrl,
                    booking_code: od.booking_code || null
                  });

                  // RETRY LOGIC: Decode QR dari Midtrans dengan retry sampai berhasil
                  const maxQrRetries = 3; // Reduce retry count (3 is enough)
                  let qrRetryCount = 0;

                  while (!qrString && qrRetryCount < maxQrRetries) {
                    qrRetryCount++;
                    console.log(chalk.cyan(`âš¡ Mencoba decode QR (attempt ${qrRetryCount}/${maxQrRetries})...`));

                    // ğŸ†• Add cache-busting untuk force fresh fetch dari server
                    // Retry ke-2 dan seterusnya: tambah timestamp untuk bypass cache
                    let fetchUrl = checkoutUrl;
                    if (qrRetryCount > 1) {
                      const separator = checkoutUrl.includes('?') ? '&' : '?';
                      fetchUrl = `${checkoutUrl}${separator}_t=${Date.now()}`;
                      console.log(chalk.gray(`â„¹ï¸  Cache-busting: ${fetchUrl}`));
                    }

                    const result = await decodeQRFromMidtrans(fetchUrl);

                    // Check if result is string (success) or error object
                    if (typeof result === 'string') {
                      qrString = result;
                      console.log(chalk.green('âœ… QR Code berhasil didecode!'));

                      // Generate QR code image dari string
                      qrDataUrl = await generateQRCodeImage(qrString);

                      // Display QR code in terminal
                      displayQRInTerminal(qrString);

                      await appendJsonLog({
                        event: 'fnb_gopay_qr_decoded',
                        order_id: od.id,
                        qr_length: qrString.length
                      });
                      break; // Berhasil, keluar dari loop
                    }

                    // Failed - retry with increasing delay + re-fetch URL
                    if (qrRetryCount < maxQrRetries) {
                      const retryDelay = Math.min(1000 + (qrRetryCount * 500), 4000); // Progressive delay: 1.5s, 2s, 2.5s, 3s, 3.5s, 4s max
                      const errorMsg = (result && result.error) ? result.error : 'Unknown error';
                      console.log(chalk.yellow(`âš ï¸ Gagal decode QR (${errorMsg}), retry dalam ${retryDelay/1000}s...`));
                      console.log(chalk.gray('â„¹ï¸  Menunggu server memuat image dengan benar...'));
                      await delay(retryDelay);

                      // ğŸ†• Re-fetch URL untuk mendapatkan fresh image
                      // Kadang image belum termuat dengan benar di server
                      if (qrRetryCount > 1) {
                        console.log(chalk.cyan('âš¡ Re-fetch QR URL untuk mendapatkan image yang fresh...'));
                        // URL sama, tapi request baru bisa dapat image yang sudah termuat
                        // Tambah delay ekstra untuk memberi waktu server
                        await delay(1000);
                      }
                    } else {
                      console.log(chalk.red('âŒ Gagal decode QR setelah semua retry, fallback ke link Midtrans'));
                      console.log(chalk.yellow('â„¹ï¸  Jangan khawatir, Anda tetap bisa bayar via link yang dikirim ke Telegram'));
                    }
                  }
                } else {
                  // Fallback jika setelah retry masih gagal
                  console.log(chalk.red('âŒ Gagal mendapatkan transaction_id setelah retry, gunakan fallback link'));
                  try {
                    const orderDetail = await fetchOrderDetail(od.id, token);
                    if (orderDetail?.status_code === 200 && orderDetail?.data) {
                      const detailData = orderDetail.data;
                      checkoutUrl = htmlDecode(
                        detailData.gopay_deeplink || detailData.payment_checkouturl || ''
                      );
                    }
                  } catch (err) {
                    // Final fallback ke pdata
                    checkoutUrl = htmlDecode(
                      pdata.payment_checkouturl || pdata.dana_checkouturl || ''
                    );
                  }
                }

                // ğŸ”’ SET lastFnbCartSnapshot UNTUK GOPAY AUTO (agar customizations muncul di filename)
                if (Array.isArray(cart) && cart.length) {
                  lastFnbCartSnapshot = cart.map(item => ({
                    ...item,
                    customizations: Array.isArray(item.customizations)
                      ? item.customizations.map(x => ({ ...x }))
                      : []
                  }));
                  const totalCustoms = cart.flatMap(c => c.customizations || []).length;
                  console.log(chalk.gray(`ğŸ“¦ [GOPAY AUTO] Cart snapshot saved for filename (${cart.length} items, ${totalCustoms} customizations)`));
                  if (totalCustoms > 0) {
                    cart.forEach((item, idx) => {
                      console.log(chalk.gray(`   Item ${idx + 1}: ${item.name} (${item.customizations?.length || 0} customs)`));
                      (item.customizations || []).forEach((c, cidx) => {
                        console.log(chalk.gray(`     ${cidx + 1}. ${c.SUB_ITEM_NM || c.name || 'Unknown'}`));
                      });
                    });
                  }
                }

                log.section('ğŸ§¾ F&B PAYMENT SUMMARY');
                renderFnbPaymentSummary(pdata, cart, selectedCinema, saleDate);

                if (qrDataUrl) {
                  // ğŸ”” KIRIM QR CODE KE TELEGRAM
                  try {
                    const dateObj = new Date(saleDate.slice(0,4), parseInt(saleDate.slice(4,6))-1, saleDate.slice(6,8));
                    const dateStr = dateObj.toLocaleDateString('id-ID', {
                      weekday: 'long',
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric'
                    });

                    const tgSafe = s => String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                    // Build item list with quantity
                    const fnbItems = cart.map(c => `${c.name} (${c.quantity ?? c.qty ?? 1}x)`).join(', ');

                    // Build customization lines
                    let customLines = '';
                    cart.forEach(item => {
                      const custList = Array.isArray(item.customizations)
                        ? item.customizations
                            .map(x => x.SUB_ITEM_NM || x.name || x.NM || '')
                            .filter(Boolean)
                        : [];
                      if (custList.length) {
                        custList.forEach(cust => {
                          customLines += `  â†³ ${tgSafe(cust)}\n`;
                        });
                      }
                    });

                    // Get voucher info
                    const voucherName = od?.voucher_name ||
                                       od?.voucherName ||
                                       od?.discount_name ||
                                       od?.discountName ||
                                       od?.discount_title ||
                                       od?.discountTitle ||
                                       null;

                    const adminFeeNum = od?.admin_fee || od?.convenience_fee || 0;
                    const totalNum = od?.total_amount || 0;

                    // Get original subtotal (before discount) from API response
                    const subTotalNum = od?.sub_total_amount || od?.subtotal || 0;

                    // Calculate discount amount from difference
                    let discountAmount = od?.discount_amount ||
                                        od?.discountAmount ||
                                        od?.voucher_amount ||
                                        od?.voucherAmount ||
                                        0;

                    // If no explicit discount_amount, calculate from subtotal vs total
                    if (!discountAmount && subTotalNum > 0) {
                      discountAmount = subTotalNum - totalNum + adminFeeNum;
                    }

                    let qrCaption = `ğŸ¿ <b>CGV F&B Auto Order â€” Payment Init</b>\n\n`;
                    qrCaption += `<b>Item:</b> ${tgSafe(fnbItems)}\n`;
                    qrCaption += customLines;
                    qrCaption += `\n<b>Cinema:</b> ${tgSafe(selectedCinema.name)}\n`;
                    qrCaption += `<b>Lokasi:</b> ${tgSafe(selectedCinema.location_name || '-')}\n`;
                    qrCaption += `<b>Tanggal:</b> ${tgSafe(dateStr)}\n`;
                    qrCaption += `<b>Metode:</b> GOPAY (E-WALLET)\n\n`;
                    qrCaption += `<b>Order ID:</b> ${od.id}\n`;
                    qrCaption += `<b>Booking:</b> ${od.booking_code || pdata.booking_code || '-'}\n`;

                    // Show voucher if exists (check both voucher name OR discount amount)
                    if ((voucherName || discountAmount > 0) && subTotalNum > 0) {
                      qrCaption += `<b>Voucher:</b> ${tgSafe(voucherName)}\n\n`;
                      qrCaption += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                      qrCaption += `<b>Harga Asli:</b> ${toRp(subTotalNum)}\n`;
                      qrCaption += `<b>Diskon:</b> -${toRp(discountAmount)}\n`;
                      if (adminFeeNum > 0) {
                        qrCaption += `<b>Admin Fee:</b> ${toRp(adminFeeNum)}\n`;
                      }
                      qrCaption += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                      qrCaption += `<b>Total Bayar:</b> ${toRp(totalNum)}\n\n`;
                    } else {
                      qrCaption += `\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                      qrCaption += `<b>Subtotal:</b> ${toRp(subTotalNum)}\n`;
                      if (adminFeeNum > 0) {
                        qrCaption += `<b>Admin Fee:</b> ${toRp(adminFeeNum)}\n`;
                      }
                      qrCaption += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                      qrCaption += `<b>Total Bayar:</b> ${toRp(totalNum)}\n\n`;
                    }

                    qrCaption += `<b>Expire:</b> ${od.expired_date || '-'}\n\n`;
                    qrCaption += `ğŸ”— <a href="${checkoutUrl}">Link Pembayaran</a>\n\n`;
                    qrCaption += `ğŸ“± <b>Scan QR Code di atas untuk membayar</b>\n`;
                    qrCaption += `ğŸ“Š Status akan dimonitor otomatis oleh bot`;

                    fnbTelegramMessage = await sendTelegramQRCode(qrDataUrl, qrCaption);
                    if (fnbTelegramMessage) {
                      lastFnbPaymentTelegramMsgId = fnbTelegramMessage; // Set global for delete
                    }
                  } catch (e) {
                    console.log(chalk.gray(`Telegram F&B QR (GOPAY) failed: ${e.message || e}`));
                  }
                } else {
                  // Fallback: kirim text message saja
                  try {
                    fnbTelegramMessage = await sendFnbPaymentInitTelegram({
                      order: od,
                      cart: cart,
                      cinema: selectedCinema,
                      saleDate: saleDate,
                      methodLabel: 'GOPAY (E-WALLET)',
                      checkoutUrl: checkoutUrl,
                      selectedAccount: selectedAccount
                    });
                    if (fnbTelegramMessage) {
                      lastFnbPaymentTelegramMsgId = fnbTelegramMessage; // Set global for delete
                    }
                  } catch (e) {
                    console.log(chalk.gray(`Telegram F&B init (GOPAY) failed: ${e.message || e}`));
                  }
                }

                if (checkoutUrl) {
                  console.log(chalk.gray(`Midtrans URL: ${checkoutUrl}`));
                  console.log(chalk.yellow('\nğŸ’¡ Silakan buka link GOPAY atau scan QR Code untuk menyelesaikan pembayaran'));
                }

                console.log(chalk.green('\nâœ… Pembayaran F&B via GOPAY berhasil diinisialisasi!'));
                console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran F&B real-time...'));

                renderFullFnbOrderSummaryBox(
                  od,
                  cart,
                  selectedCinema,
                  selectedAccount,
                  'Pembayaran F&B Diproses'
                );
                await appendJsonLog({
                  event: 'fnb_pre_monitor_summary',
                  order_id: od.id
                });

                monitorResult = await monitorFnbPaymentLoop({
                  orderId: od.id,
                  token,
                  methodLabel: 'GOPAY',
                  fnbItems: cart.map(c => c.name).join(', '),
                  intervalSec: 1,
                  confirmEverySec: 60,
                  initialRapidSec: 20,
                  rapidIntervalSec: 1,
                  selectedAccount
                });

                od = monitorResult?.order || od;
                const finalStatusLabel = statusLabelFromResult(
                  monitorResult?.status,
                  od
                );

                // Skip render summary jika canceled (sudah di-render di cancel handler)
                if (monitorResult?.status !== 'canceled') {
                  renderFullFnbOrderSummaryBox(
                    od,
                    cart,
                    selectedCinema,
                    selectedAccount,
                    finalStatusLabel
                  );
                  await appendJsonLog({
                    event: 'fnb_post_monitor_summary',
                    order_id: od?.id,
                    status: monitorResult?.status
                  });
                }
              }
            }
          }

        // === Jalur cepat QRIS (shortcut "q") â€” jalan kalau QRIS aktif ===
        } else if (!cgvPointSuccess && selectedMethod === 'q') {
          log.section('ğŸ’³ PEMBAYARAN â€” QRIS (shortcut q)');
          const qris = findQris(payRes);

          if (!qris) {
            log.warning('Metode QRIS belum tersedia / tidak aktif. Silakan pilih metode lain.');
            log.section('ğŸ’³ METODE PEMBAYARAN');
            renderPaymentMethodsTable(payRes);
          } else {
            log.process('Menyiapkan payment partner (select)...');
            const sel = await paymentPartnerSelect(
              String(od.id),
              String(qris.category_id),
              String(qris.payment_id),
              token
            );

            if (sel?.status_code !== 200) {
              log.error(`Select payment partner QRIS gagal: ${sel?.message || 'Unknown error'}`);
              await appendJsonLog({
                event: 'fnb_payment_partner_select_failed',
                response: sel,
                order_id: od.id,
                method: qris
              });
            } else {
              await appendJsonLog({
                event: 'fnb_payment_partner_selected',
                order_id: od.id,
                method: qris,
                data: sel?.data
              });

              log.process('Memproses pembayaran F&B (pay) via QRIS...');
              const pay = await paymentPartnerPay(String(od.id), token);

              if (pay?.status_code !== 200) {
                log.error(`Payment init QRIS gagal: ${pay?.message || 'Unknown error'}`);
                await appendJsonLog({
                  event: 'fnb_payment_partner_pay_failed',
                  response: pay,
                  order_id: od.id
                });
              } else {
                const pdata = pay.data || {};
                od = pdata;

                await appendJsonLog({
                  event: 'fnb_payment_partner_pay_ok',
                  order_id: od.id,
                  data: pdata
                });

                const checkoutUrl =
                  pdata.payment_checkouturl ||
                  pdata.dana_checkouturl ||
                  '';

                // ğŸ”” KIRIM KE TELEGRAM (QRIS)
                try {
                  fnbTelegramMessage = await sendFnbPaymentInitTelegram({
                    order: od,
                    cart: cart,
                    cinema: selectedCinema,
                    saleDate: saleDate,
                    methodLabel: 'QRIS',
                    checkoutUrl: checkoutUrl,
                    selectedAccount: selectedAccount
                  });
                  if (fnbTelegramMessage) {
                    lastFnbPaymentTelegramMsgId = fnbTelegramMessage;
                  }
                } catch (e) {
                  console.log(chalk.gray(`Telegram F&B init (QRIS) failed: ${e.message || e}`));
                }

                log.section('ğŸ§¾ F&B PAYMENT SUMMARY');
                renderFnbPaymentSummary(pdata, cart, selectedCinema, saleDate);

                if (checkoutUrl) {
                  console.log(chalk.yellow('\nğŸ’¡ Silakan scan / buka link QRIS berikut untuk menyelesaikan pembayaran:'));
                  console.log(chalk.blue(checkoutUrl));
                }

                console.log(chalk.green('\nâœ… Pembayaran F&B via QRIS berhasil diinisialisasi!'));
                console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran F&B real-time...'));

                renderFullFnbOrderSummaryBox(
                  od,
                  cart,
                  selectedCinema,
                  selectedAccount,
                  'Pembayaran F&B Diproses'
                );
                await appendJsonLog({
                  event: 'fnb_pre_monitor_summary',
                  order_id: od.id
                });

                monitorResult = await monitorFnbPaymentLoop({
                  orderId: od.id,
                  token,
                  methodLabel: 'QRIS',
                  fnbItems: cart.map(c => c.name).join(', '),
                  intervalSec: 1,
                  confirmEverySec: 60,
                  initialRapidSec: 20,
                  rapidIntervalSec: 1,
                  selectedAccount
                });

                od = monitorResult?.order || od;
                const finalStatusLabel = statusLabelFromResult(
                  monitorResult?.status,
                  od
                );

                // Skip render summary jika canceled (sudah di-render di cancel handler)
                if (monitorResult?.status !== 'canceled') {
                  renderFullFnbOrderSummaryBox(
                    od,
                    cart,
                    selectedCinema,
                    selectedAccount,
                    finalStatusLabel
                  );
                  await appendJsonLog({
                    event: 'fnb_post_monitor_summary',
                    order_id: od?.id,
                    status: monitorResult?.status
                  });
                }
              }
            }
          }

        // === Jalur cepat SHOPEEPAY (shortcut "s") ===
        } else if (!cgvPointSuccess && selectedMethod === 's') {
          log.section('ğŸ’³ PEMBAYARAN â€” SHOPEEPAY (shortcut s)');
          const shopeepay = findShopeepay(payRes);

          if (!shopeepay) {
            log.warning('Metode SHOPEEPAY tidak tersedia saat ini. Tampilkan daftar metode sebagai alternatif.');
            log.section('ğŸ’³ METODE PEMBAYARAN');
            renderPaymentMethodsTable(payRes);
          } else {
            log.process('Menyiapkan payment partner (select)...');
            const sel = await paymentPartnerSelect(
              String(od.id),
              String(shopeepay.category_id),
              String(shopeepay.payment_id),
              token
            );

            if (sel?.status_code !== 200) {
              log.error(`Select payment partner SHOPEEPAY gagal: ${sel?.message || 'Unknown error'}`);
              await appendJsonLog({
                event: 'fnb_payment_partner_select_failed',
                response: sel,
                order_id: od.id,
                method: shopeepay
              });
            } else {
              await appendJsonLog({
                event: 'fnb_payment_partner_selected',
                order_id: od.id,
                method: shopeepay,
                data: sel?.data
              });

              log.process('Memproses pembayaran F&B (pay) via SHOPEEPAY...');
              const pay = await paymentPartnerPay(String(od.id), token);

              if (pay?.status_code !== 200) {
                log.error(`Payment init SHOPEEPAY gagal: ${pay?.message || 'Unknown error'}`);
                await appendJsonLog({
                  event: 'fnb_payment_partner_pay_failed',
                  response: pay,
                  order_id: od.id
                });
              } else {
                const pdata = pay?.data || {};
                await appendJsonLog({
                  event: 'fnb_payment_partner_pay_ok',
                  order_id: od.id,
                  data: pdata
                });

                const checkoutUrl = (
                  pdata.payment_checkouturl ||
                  pdata.shopeepay_checkouturl ||
                  ''
                );

                fnbTelegramMessage = await sendFnbPaymentInitTelegram({
                  order: od,
                  cart: cart,
                  cinema: selectedCinema,
                  saleDate: saleDate,
                  methodLabel: 'SHOPEEPAY',
                  checkoutUrl: checkoutUrl,
                  selectedAccount: selectedAccount
                });
                if (fnbTelegramMessage) {
                  lastFnbPaymentTelegramMsgId = fnbTelegramMessage;
                }

                log.section('ğŸ§¾ F&B PAYMENT SUMMARY');
                renderFnbPaymentSummary(pdata, cart, selectedCinema, saleDate);

                if (checkoutUrl) {
                  console.log(chalk.yellow('\nğŸ’¡ Silakan buka link SHOPEEPAY berikut untuk menyelesaikan pembayaran:'));
                  console.log(chalk.cyan(checkoutUrl));
                }

                console.log(chalk.green('\nâœ… Pembayaran F&B via SHOPEEPAY berhasil diinisialisasi!'));
                console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran F&B real-time...'));

                renderFullFnbOrderSummaryBox(
                  od,
                  cart,
                  selectedCinema,
                  selectedAccount,
                  'Pembayaran F&B Diproses'
                );

                monitorResult = await monitorFnbPaymentLoop({
                  orderId: od.id,
                  token,
                  cinema: selectedCinema,
                  fnbItems: cart.map(c => c.name).join(', '),
                  selectedAccount,
                  methodLabel: 'SHOPEEPAY',
                  telegramMessage: fnbTelegramMessage
                });

                await appendJsonLog({
                  event: 'fnb_post_monitor_summary',
                  order_id: od?.id,
                  status: monitorResult?.status
                });
              }
            }
          }

        } else if (!cgvPointSuccess && defaultDana) {
          // === Enter => DANA (auto) ===
          log.section('ğŸ’³ PEMBAYARAN â€” DANA (default)');
          const dana = findDana(payRes);
          if (!dana) {
            log.warning('Metode DANA tidak tersedia saat ini. Tampilkan daftar metode sebagai alternatif.');
            log.section('ğŸ’³ METODE PEMBAYARAN');
            renderPaymentMethodsTable(payRes);
          } else {
            // DANA Payment Flow for F&B
            log.process('Menyiapkan payment partner (select)...');
            const sel = await paymentPartnerSelect(String(od.id), String(dana.category_id), String(dana.payment_id), token);
            if (sel?.status_code !== 200) {
              log.error(`Select payment partner gagal: ${sel?.message || 'Unknown error'}`);
              await appendJsonLog({ event: 'fnb_payment_partner_select_failed', response: sel, order_id: od.id, method: dana });
            } else {
              await appendJsonLog({ event: 'fnb_payment_partner_selected', order_id: od.id, method: dana, data: sel?.data });
              
              log.process('Memproses pembayaran F&B (pay)...');
              const pay = await paymentPartnerPay(String(od.id), token);
              if (pay?.status_code !== 200) {
                log.error(`Payment init gagal: ${pay?.message || 'Unknown error'}`);
                await appendJsonLog({ event: 'fnb_payment_partner_pay_failed', response: pay, order_id: od.id });
              } else {
                const pdata = pay.data || {};
                od = pdata;
                await appendJsonLog({ event: 'fnb_payment_partner_pay_ok', order_id: od.id, data: pdata });

                const checkoutUrl = pdata.dana_checkouturl || pdata.payment_checkouturl || '';

                // ğŸ”” KIRIM KE TELEGRAM (AUTO DANA)
                try {
                  fnbTelegramMessage = await sendFnbPaymentInitTelegram({
                    order: od,
                    cart: cart,
                    cinema: selectedCinema,
                    saleDate: saleDate,
                    methodLabel: 'DANA (E-WALLET)',
                    checkoutUrl: checkoutUrl,
                    selectedAccount: selectedAccount
                  });
                  if (fnbTelegramMessage) {
                    lastFnbPaymentTelegramMsgId = fnbTelegramMessage;
                  }
                } catch (e) {
                  console.log(chalk.gray(`Telegram F&B init (AUTO DANA) failed: ${e.message || e}`));
                }

                log.section('ğŸ§¾ F&B PAYMENT SUMMARY');
                renderFnbPaymentSummary(pdata, cart, selectedCinema, saleDate);

                if (checkoutUrl) {
                  await requestJson('GET', checkoutUrl, {
                    headers: {
                      'user-agent': 'Mozilla/5.0 (Linux; Android 9; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/124.0 Mobile Safari/537.36',
                      accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
                      'accept-language': 'id-ID,id;q=0.9',
                      'X-Requested-With': 'com.blitz.blitzandapp1'
                    },
                    note: 'open: dana fnb checkout'
                  });

                  // Try Puppeteer Full Automation first, fallback to manual
                  let automationSuccess = false;
                  try {
                    console.log(chalk.yellow('ğŸ”„ Membuka DANA dengan full automation...'));
                    // ğŸ”’ Pastikan tidak ada browser serupa yang masih terbuka (termasuk instance Puppeteer pertama)
                    await waitForSameBrowserFree({ label: 'DANA Checkout' });
                    
                    const puppeteer = (await import('puppeteer')).default;
                    
                    const browser = await launchBrowser({
                      headless: false,
                      defaultViewport: null,
                      args: [
                        '--incognito',
                        '--no-sandbox',
                        '--disable-setuid-sandbox',
                        '--disable-dev-shm-usage',
                        '--disable-blink-features=AutomationControlled',
                        '--disable-features=VizDisplayCompositor',
                        '--disable-web-security',
                        '--no-first-run',
                        '--no-default-browser-check',
                        '--disable-extensions',
                        '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                      ]
                    });

                    const page = await browser.newPage();
                    
                    // Override webdriver detection
                    await page.evaluateOnNewDocument(() => {
                      Object.defineProperty(navigator, 'webdriver', {
                        get: () => undefined,
                      });
                    });
                    
                    console.log(chalk.gray('ğŸ“± Loading DANA F&B page...'));
                    await page.goto(checkoutUrl, { waitUntil: 'networkidle2', timeout: 30000 });
                    
                    // Wait for phone input field
                    console.log(chalk.gray('ğŸ” Looking for phone input field...'));
                    await page.waitForSelector('input[type="tel"], input[placeholder*="nomor"], input[id*="phone"], input[name*="phone"]', { timeout: 10000 });
                    
                    // Fill phone number
                    console.log(chalk.gray(`ğŸ“ Filling phone number: ${DANA_PHONE_OVERRIDE}`));
                    const phoneSelector = 'input[type="tel"], input[placeholder*="nomor"], input[id*="phone"], input[name*="phone"]';
                    await page.focus(phoneSelector);
                    await page.evaluate((selector) => {
                      const input = document.querySelector(selector);
                      if (input) input.value = '';
                    }, phoneSelector);
                    await page.type(phoneSelector, DANA_PHONE_OVERRIDE, { delay: 100 });
                    
                    // Wait a bit for validation
                    await delay(2000);
                    
                    // Look for and click continue button
                    console.log(chalk.gray('ğŸ”˜ Looking for continue button...'));
                    let buttonFound = false;
                    
                    // Try XPath for text content
                    try {
                      const [button] = await page.$x(`//button[contains(text(), 'LANJUTKAN') or contains(text(), 'Lanjutkan') or contains(text(), 'CONTINUE')]`);
                      if (button) {
                        console.log(chalk.gray('âœ… Found continue button, clicking...'));
                        await button.click();
                        buttonFound = true;
                      }
                    } catch (e) {
                      // Try CSS selectors
                      const continueSelectors = [
                        '.btn-continue',
                        '#continue-btn',
                        '[data-testid="continue"]',
                        'button[type="submit"]'
                      ];
                      
                      for (const selector of continueSelectors) {
                        try {
                          const button = await page.$(selector);
                          if (button) {
                            console.log(chalk.gray('âœ… Found continue button, clicking...'));
                            await button.click();
                            buttonFound = true;
                            break;
                          }
                        } catch (e) {
                          continue;
                        }
                      }
                    }
                    
                    if (!buttonFound) {
                      console.log(chalk.yellow('âš ï¸  Continue button not found, please click manually'));
                    }
                    
                    console.log(chalk.white('ğŸ”’ Mode penyamaran aktif - bypass bot detection'));
                    console.log(chalk.gray('ğŸ”„ Lanjutkan proses pembayaran di browser'));

                    automationSuccess = true;

                    // ğŸ§¹ Auto-close setelah sukses
                    const AUTO_CLOSE_DELAY_MS = 3000;
                    console.log(chalk.gray(`ğŸ§¹ Menutup browser otomatis dalam ${AUTO_CLOSE_DELAY_MS/1000}s...`));
                    await delay(AUTO_CLOSE_DELAY_MS);
                    try { await page.close({ runBeforeUnload: true }); } catch {}
                    try { await browser.close(); } catch {}
                    console.log(chalk.green('âœ… Browser Puppeteer ditutup otomatis.'));

                  } catch (automationError) {
                    console.log(chalk.yellow(`âš ï¸  Full automation gagal: ${automationError.message}`));
                  }

                  // Final fallback to manual
                  if (!automationSuccess) {
                    console.log(chalk.yellow('\nğŸ’¡ Silakan buka link DANA berikut secara manual:'));
                    console.log(chalk.blue(checkoutUrl));
                    console.log(chalk.gray(`ğŸ“± Isi nomor HP: ${DANA_PHONE_OVERRIDE} kemudian klik LANJUTKAN`));
                  }
                }

                console.log(chalk.green('\nâœ… Pembayaran F&B berhasil diinisialisasi!'));
                console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran F&B real-time...'));

                // Ringkasan lengkap SEBELUM monitoring
                renderFullFnbOrderSummaryBox(od, cart, selectedCinema, selectedAccount, 'Pembayaran F&B Diproses');
                await appendJsonLog({ event: 'fnb_pre_monitor_summary', order_id: od.id });

                monitorResult = await monitorFnbPaymentLoop({
                  orderId: od.id,
                  token,
                  methodLabel: 'DANA',
                  fnbItems: cart.map(c=>c.name).join(', '),
                  intervalSec: 1,
                  confirmEverySec: 60,
                  initialRapidSec: 20,
                  rapidIntervalSec: 1,
                  selectedAccount: selectedAccount
                });

                // Ringkasan lengkap SESUDAH monitoring
                od = monitorResult?.order || od;
                const finalStatusLabel = statusLabelFromResult(monitorResult?.status, od);
                renderFullFnbOrderSummaryBox(od, cart, selectedCinema, selectedAccount, finalStatusLabel);
                await appendJsonLog({ event: 'fnb_post_monitor_summary', order_id: od?.id, status: monitorResult?.status });

              }
            }
          }
        } else if (!cgvPointSuccess && selectedMethod === 'y') {
          // User ingin pilih metode lain (manual selection)
          log.section('ğŸ’³ METODE PEMBAYARAN');
          renderPaymentMethodsTable(payRes);

          // Flatten active methods dgn category_id
          const activeMethods = [];
          (payRes.data||[]).forEach(cat => {
            const catId = (cat?.category_id ?? cat?.id ?? cat?.categoryId ?? cat?.categoryID);
            (cat.items||[]).forEach(it => {
              if (it.status) activeMethods.push({
                id: String(it.id),
                name: it.name,
                category_id: String(catId),
                category: cat.name,
              });
            });
          });
          
          if (!activeMethods.length) {
            log.warning('Tidak ada metode pembayaran aktif yang tersedia saat ini.');
          } else {
            const { chosenPayment } = await inquirer.prompt([{
              type: 'list',
              name: 'chosenPayment',
              message: `Pilih metode pembayaran F&B (Total: ${toRp(od.total_amount||0)}):`,
              choices: activeMethods.map(m => ({ name: `${m.name} (${m.category})`, value: m }))
            }]);
            
            await appendJsonLog({ event: 'fnb_payment_chosen', method: chosenPayment, amount: od.total_amount||0 });

            // Select partner (untuk VA sertakan bank_id)
            log.process('Menyiapkan payment partner (select)...');
            const needBankId = String(chosenPayment.category_id) === '6'; // BANK TRANSFER
            const extra = needBankId ? { bank_id: String(chosenPayment.id) } : {};
            const sel = await paymentPartnerSelect(String(od.id), String(chosenPayment.category_id), String(chosenPayment.id), token, extra);
            if (sel?.status_code !== 200) {
              log.error(`Select payment partner gagal: ${sel?.message || 'Unknown error'}`);
              await appendJsonLog({ event: 'fnb_payment_partner_select_failed', response: sel, order_id: od.id, method: chosenPayment });
            } else {
              await appendJsonLog({ event: 'fnb_payment_partner_selected', order_id: od.id, method: chosenPayment, data: sel?.data });

              // Pay
              log.process('Memproses pembayaran F&B (pay)...');
              const pay = await paymentPartnerPay(String(od.id), token);
              if (pay?.status_code !== 200) {
                log.error(`Payment init gagal: ${pay?.message || 'Unknown error'}`);
                await appendJsonLog({ event: 'fnb_payment_partner_pay_failed', response: pay, order_id: od.id });
              } else {
                const pdata = pay.data || {};
                od = pdata;
                await appendJsonLog({ event: 'fnb_payment_partner_pay_ok', order_id: od.id, data: pdata });

                // Check if DANA or Bank Transfer / lainnya
                const isDana = includesIgnoreCase(chosenPayment.name, 'DANA') || String(chosenPayment.id) === '5';

                // Label & checkoutUrl untuk semua metode
                const methodLabel = isDana ? 'DANA (E-WALLET)' : (chosenPayment.name || 'METODE LAIN');
                const checkoutUrl = isDana
                  ? (pdata.dana_checkouturl || pdata.payment_checkouturl || '')
                  : (pdata.payment_checkouturl || pdata.dana_checkouturl || '');

                // ğŸ‘‰ SELALU kirim ke Telegram (manual-select, apapun metodenya)
                try {
                  fnbTelegramMessage = await sendFnbPaymentInitTelegram({
                    order: od,
                    cart: cart,
                    cinema: selectedCinema,
                    saleDate: saleDate,
                    methodLabel: methodLabel,
                    checkoutUrl: checkoutUrl,
                    selectedAccount: selectedAccount
                  });
                  if (fnbTelegramMessage) {
                    lastFnbPaymentTelegramMsgId = fnbTelegramMessage;
                  }
                } catch (e) {
                  console.log(chalk.gray(`Telegram F&B init (MANUAL SELECT) failed: ${e.message || e}`));
                }

                if (isDana) {
                  // ===== FLOW DANA (manual-select) =====
                  log.section('ğŸ§¾ F&B PAYMENT SUMMARY');
                  renderFnbPaymentSummary(pdata, cart, selectedCinema, saleDate);

                  if (checkoutUrl) {
                    // Prefetch agar mirip alur auto-movie
                    await requestJson('GET', checkoutUrl, {
                      headers: {
                        'user-agent': 'Mozilla/5.0 (Linux; Android 9; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/124.0 Mobile Safari/537.36',
                        accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
                        'accept-language': getRandomLang(),
                        'X-Requested-With': 'com.blitz.blitzandapp1'
                      },
                      note: 'open: dana fnb checkout (manual-select)'
                    });

                    // Full automation dulu â†’ fallback manual
                    let automationSuccess = false;
                    try {
                      console.log(chalk.yellow('ğŸ”„ Membuka DANA F&B dengan full automation (manual-select)...'));
                      // ğŸ”’ Pastikan tidak ada browser serupa yang masih terbuka (termasuk instance Puppeteer pertama)
                      await waitForSameBrowserFree({ label: 'DANA Checkout' });

                      const puppeteer = (await import('puppeteer')).default;

                      const browser = await launchBrowser({
                        headless: false,
                        defaultViewport: null,
                        args: [
                          '--incognito',
                          '--no-sandbox',
                          '--disable-setuid-sandbox',
                          '--disable-dev-shm-usage',
                          '--disable-blink-features=AutomationControlled',
                          '--disable-features=VizDisplayCompositor',
                          '--disable-web-security',
                          '--no-first-run',
                          '--no-default-browser-check',
                          '--disable-extensions',
                          '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                        ]
                      });

                      const page = await browser.newPage();
                      await page.evaluateOnNewDocument(() => {
                        Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
                      });

                      console.log(chalk.gray('ğŸ“± Loading DANA F&B page...'));
                      await page.goto(checkoutUrl, { waitUntil: 'networkidle2', timeout: 30000 });

                      console.log(chalk.gray('ğŸ” Looking for phone input field...'));
                      await page.waitForSelector(
                        'input[type="tel"], input[placeholder*="nomor"], input[id*="phone"], input[name*="phone"]',
                        { timeout: 10000 }
                      );

                      console.log(chalk.gray(`ğŸ“ Filling phone number: ${DANA_PHONE_OVERRIDE}`));
                      const phoneSelector = 'input[type="tel"], input[placeholder*="nomor"], input[id*="phone"], input[name*="phone"]';
                      await page.focus(phoneSelector);
                      await page.evaluate((selector) => {
                        const input = document.querySelector(selector);
                        if (input) input.value = '';
                      }, phoneSelector);
                      await page.type(phoneSelector, DANA_PHONE_OVERRIDE, { delay: 100 });

                      await delay(2000); // beri waktu validasi

                      console.log(chalk.gray('ğŸ”˜ Looking for continue button...'));
                      let buttonFound = false;

                      // by text
                      try {
                        const [button] = await page.$x(`//button[contains(text(), 'LANJUTKAN') or contains(text(), 'Lanjutkan') or contains(text(), 'CONTINUE')]`);
                        if (button) {
                          console.log(chalk.gray('âœ… Found continue button, clicking...'));
                          await button.click();
                          buttonFound = true;
                        }
                      } catch {}

                      // fallback css
                      if (!buttonFound) {
                        const continueSelectors = ['.btn-continue', '#continue-btn', '[data-testid="continue"]', 'button[type="submit"]'];
                        for (const sel of continueSelectors) {
                          let btn = null;
                          try { btn = await page.$(sel); } catch {}
                          if (btn) {
                            console.log(chalk.gray('âœ… Found continue button, clicking...'));
                            await btn.click();
                            buttonFound = true;
                            break;
                          }
                        }
                      }

                      if (!buttonFound) {
                        console.log(chalk.yellow('âš ï¸  Continue button not found, silakan klik manual.'));
                      }

                      console.log(chalk.gray('ğŸ”„ Lanjutkan proses pembayaran di browser'));

                      automationSuccess = true;

                      // Auto-close biar bersih
                      const AUTO_CLOSE_DELAY_MS = 3000;
                      console.log(chalk.gray(`ğŸ§¹ Menutup browser otomatis dalam ${AUTO_CLOSE_DELAY_MS/1000}s...`));
                      await delay(AUTO_CLOSE_DELAY_MS);
                      try { await page.close({ runBeforeUnload: true }); } catch {}
                      try { await browser.close(); } catch {}
                      console.log(chalk.green('âœ… Browser Puppeteer ditutup otomatis.'));
                    } catch (automationError) {
                      console.log(chalk.yellow(`âš ï¸  Full automation gagal: ${automationError.message}`));
                    }

                    // Fallback manual
                    if (!automationSuccess) {
                      console.log(chalk.yellow('\nğŸ’¡ Silakan buka link DANA berikut secara manual:'));
                      console.log(chalk.blue(checkoutUrl));
                      console.log(chalk.gray(`ğŸ“± Isi nomor HP: ${DANA_PHONE_OVERRIDE} kemudian klik LANJUTKAN`));
                    }
                  }

                  // === Penting: lanjut monitoring seperti auto-movie ===
                  console.log(chalk.green('\nâœ… Pembayaran F&B berhasil diinisialisasi!'));
                  console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran F&B real-time...'));

                  renderFullFnbOrderSummaryBox(od, cart, selectedCinema, selectedAccount, 'Pembayaran F&B Diproses');
                  await appendJsonLog({ event: 'fnb_pre_monitor_summary', order_id: od.id });

                  monitorResult = await monitorFnbPaymentLoop({
                    orderId: od.id,
                    token,
                    methodLabel: 'DANA',
                    fnbItems: cart.map(c=>c.name).join(', '),
                    intervalSec: 1,
                    confirmEverySec: 60,
                    initialRapidSec: 20,
                    rapidIntervalSec: 1,
                    selectedAccount: selectedAccount
                  });

                  od = monitorResult?.order || od;
                  const finalStatusLabel = statusLabelFromResult(monitorResult?.status, od);
                  renderFullFnbOrderSummaryBox(od, cart, selectedCinema, selectedAccount, finalStatusLabel);
                  await appendJsonLog({ event: 'fnb_post_monitor_summary', order_id: od?.id, status: monitorResult?.status });

                } else {
                  // BANK TRANSFER / lainnya (tetap sama seperti sebelumnya)
                  log.section('ğŸ§¾ F&B PAYMENT SUMMARY');
                  renderFnbPaymentSummary(pdata, cart, selectedCinema, saleDate);

                  if (String(chosenPayment.category_id) === '6') {
                    if (pdata.virtual_account_bank_number) {
                      console.log(chalk.green('\nğŸ’³ VIRTUAL ACCOUNT DETAILS:'));
                      console.log(chalk.yellow(`Bank: ${pdata.virtual_account_bank_name || chosenPayment.name}`));
                      console.log(chalk.yellow(`VA Number: ${pdata.virtual_account_bank_number}`));
                      console.log(chalk.gray('ğŸ’¡ Transfer ke nomor VA di atas untuk menyelesaikan pembayaran'));
                    }
                  }

                  console.log(chalk.green('\nâœ… Pembayaran F&B berhasil diinisialisasi!'));
                  console.log(chalk.yellow('ğŸ”„ Memulai monitoring status pembayaran F&B real-time...'));

                  renderFullFnbOrderSummaryBox(od, cart, selectedCinema, selectedAccount, 'Pembayaran F&B Diproses');
                  await appendJsonLog({ event: 'fnb_pre_monitor_summary', order_id: od.id });

                  monitorResult = await monitorFnbPaymentLoop({
                    orderId: od.id,
                    token,
                    methodLabel: chosenPayment.name,
                    fnbItems: cart.map(c=>c.name).join(', '),
                    intervalSec: 1,
                    confirmEverySec: 60,
                    initialRapidSec: 20,
                    rapidIntervalSec: 1,
                    selectedAccount: selectedAccount
                  });

                  od = monitorResult?.order || od;
                  const finalStatusLabel = statusLabelFromResult(monitorResult?.status, od);
                  renderFullFnbOrderSummaryBox(od, cart, selectedCinema, selectedAccount, finalStatusLabel);
                  await appendJsonLog({ event: 'fnb_post_monitor_summary', order_id: od?.id, status: monitorResult?.status });
                }
              }
            }
          }
        }
      }
    } else if (nextAction === 'cancel') {
      log.process('Mencoba membatalkan pesanan F&B...');
      const cancelRes = await cancelOrder(String(od.id), token);
      if (cancelRes?.status_code === 200) {
        log.success(`Order F&B ${od.id} dibatalkan (server OK).`);
        await appendJsonLog({ event: 'fnb_order_canceled', order_id: od.id, response: cancelRes });
        monitorResult = { status: 'canceled', order: od };
      } else {
        log.error(`Gagal cancel order F&B: ${cancelRes?.message || 'Unknown error'}`);
        await appendJsonLog({ event: 'fnb_order_cancel_failed', order_id: od.id, response: cancelRes });
        monitorResult = { status: 'pending', order: od };
      }
    } else {
      log.info('Pesanan F&B disimpan. Kamu bisa lanjutkan pembayaran nanti selama belum expired.');
      await appendJsonLog({ event: 'fnb_order_saved_for_later', order_id: od.id });
      monitorResult = { status: 'pending', order: od };
    }
    } // End of payment flow


    // ===== Final comprehensive summary F&B =====

    // ğŸ” Auto-hapus pesan Telegram "payment init" kalau status sudah FINAL
    try {
      await clearFnbTelegramPaymentMessage(
        monitorResult?.status,
        monitorResult?.order || od
      );
    } catch (e) {
      await appendJsonLog({
        event: 'fnb_telegram_payment_init_clear_error_final',
        error: e?.message || String(e)
      });
    }

    const finalStatusForSummary = statusLabelFromResult(
      monitorResult?.status,
      monitorResult?.order || od
    );
    renderFullFnbOrderSummaryBox(
      monitorResult?.order || od,
      cart,
      selectedCinema,
      selectedAccount,
      finalStatusForSummary
    );

    await appendJsonLog({ 
      event: 'fnb_session_end', 
      reason: 'normal', 
      final_order: monitorResult?.order || od, 
      final_status: monitorResult?.status 
    });

    await inquirer.prompt([
      { type: 'input', name: 'pause', message: 'Press Enter to return to menu...' }
    ]);





  } catch (error) {
    const msg = (error && error.message) ? error.message : String(error);
    log.error(`Error in autoOrderFnb: ${msg}`);
    
    // Send error to Telegram dengan context lengkap - dengan safe access
    const errorContext = `ğŸš¨ <b>CRITICAL ERROR: F&B AUTO ORDER</b>\n\n` +
      `Error: <code>${msg}</code>\n\n` +
      `Stack: <pre>${(error?.stack || '').slice(0, 1000)}</pre>\n\n` +
      `Function: autoOrderFnb\n` +
      `Time: ${new Date().toLocaleString('id-ID')}`;
    
    try {
      await sendTelegramMessage(errorContext);
    } catch (telegramError) {
      console.log(chalk.red(`âŒ Telegram notification failed: ${telegramError.message}`));
    }
    
    await appendJsonLog({ event: 'fnb_error', error: msg, stack: error?.stack });
  }
}

// Export untuk digunakan
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { autoOrderFnb };
} else if (typeof window !== 'undefined') {
  window.autoOrderFnb = autoOrderFnb;
}




// masking ringan utk no HP (biar rapi di output)
function maskPhone(p) {
  // Updated: show the phone number as-is (no masking)
  return String(p ?? '-');
}


import pkg from 'https-proxy-agent';
const { HttpsProxyAgent } = pkg;

// === [NEW] Network & retry limits (bisa diatur via ENV)
const LOGIN_MAX_ATTEMPTS    = Number(process.env.LOGIN_MAX_ATTEMPTS    || 6);
const LOGIN_BASE_DELAY_MS   = Number(process.env.LOGIN_BASE_DELAY_MS   || 2500);
const LOGIN_MAX_DELAY_MS    = Number(process.env.LOGIN_MAX_DELAY_MS    || 12000);
const FETCH_TIMEOUT_MS      = Number(process.env.FETCH_TIMEOUT_MS      || 20000);
const STEP_HARD_DEADLINE_MS = Number(process.env.STEP_HARD_DEADLINE_MS || 45000);

// === [NEW] Phone-verify backend confirm & profile update tuning
const MOBILE_CONFIRM_DEADLINE_MS   = Number(process.env.MOBILE_CONFIRM_DEADLINE_MS   || 90000); // max tunggu 60s
const MOBILE_CONFIRM_BASE_WAIT_MS  = Number(process.env.MOBILE_CONFIRM_BASE_WAIT_MS  || 1000);  // start 1s
const MOBILE_CONFIRM_MAX_WAIT_MS   = Number(process.env.MOBILE_CONFIRM_MAX_WAIT_MS   || 5000);  // naik max 5s

const PROFILE_UPDATE_MAX_ATTEMPTS  = Number(process.env.PROFILE_UPDATE_MAX_ATTEMPTS  || 8);
const PROFILE_UPDATE_BASE_DELAY_MS = Number(process.env.PROFILE_UPDATE_BASE_DELAY_MS || 2500);
const PROFILE_UPDATE_MAX_DELAY_MS  = Number(process.env.PROFILE_UPDATE_MAX_DELAY_MS  || 12000);


// Boleh tetap pakai ENV kalau mau, tapi sekarang kita juga bisa pilih dari console
const PROXY_LIST = (process.env.PROXY_LIST || '')
  ? process.env.PROXY_LIST.split(',').map(s => s.trim()).filter(Boolean)
  : [
      'JSbXD9LqK1En8Fe5:8ClzkSozENdY3JRZ_country-id@geo.iproyal.com:12321'
    ];

// === [BARU] Runtime toggle dari console (ganti PROXY_OFF ENV)
let PROXY_DISABLED = false;         // true => DIRECT
let RUNTIME_PROXY_URL = null;       // kalau user isi URL custom, pakai ini


// helper kecil untuk masking host:port saat logging (opsional)
const maskProxy = (u) => {
  try {
    const url = new URL(u.startsWith('http') ? u : `http://${u}`);
    const host = url.hostname;
    const port = url.port ? `:${url.port}` : '';
    return `${url.protocol}//***:***@${host}${port}`;
  } catch { return u; }
};


// Round-robin sekali saat sesi dimulai
let rrIndex = 0;
const nextProxyUrl = () => {
  if (!PROXY_LIST.length) return null;
  const raw = PROXY_LIST[rrIndex++ % PROXY_LIST.length];
  return raw.startsWith('http') ? raw : `http://${raw}`;
};

// Agent aktif untuk seluruh sesi
let sessionAgent = null;
let sessionProxyUrl = null;

function makeAgent(url) {
  if (!url) return undefined;
  try { return new HttpsProxyAgent(url); }
  catch { return undefined; }
}

// === [BARU] Prompt ON/OFF proxy di awal run
async function promptProxyAtStartup() {
  // pakai inquirer yang sudah ada di file ini
  const { choice } = await inquirer.prompt([{
    type: 'list',
    name: 'choice',
    message: 'ğŸŒ Use HTTP proxy?',
    choices: [
      { name: 'OFF (DIRECT)', value: 'off' },
      { name: 'ON - use PROXY_LIST (round-robin)', value: 'on-list' },
      { name: 'ON - input custom URL', value: 'on-custom' },
    ],
  }]);

  if (choice === 'off') {
    PROXY_DISABLED = true;
    RUNTIME_PROXY_URL = null;
  } else if (choice === 'on-list') {
    PROXY_DISABLED = false;
    RUNTIME_PROXY_URL = null; // pakai nextProxyUrl()
  } else {
    const { url } = await inquirer.prompt([{
      type: 'input',
      name: 'url',
      message: 'Proxy URL (contoh: http://user:pass@host:port):',
      validate: v => /^https?:\/\//i.test(String(v).trim()) ? true : 'Harus diawali http:// atau https://',
      filter: v => String(v || '').trim()
    }]);
    PROXY_DISABLED = false;
    RUNTIME_PROXY_URL = url;
  }
}

// Panggil SEKALI di awal sesi
function initSessionAgentIfNeeded() {
  if (PROXY_DISABLED) {
    sessionAgent = null;
    sessionProxyUrl = null;
    try { console.log('[PROXY] mode: OFF (DIRECT)'); } catch {}
    return;
  }
  if (sessionAgent) return; // sudah ada

  const url = RUNTIME_PROXY_URL || nextProxyUrl();
  sessionProxyUrl = url || null;
  sessionAgent = makeAgent(url);
  if (sessionAgent && sessionProxyUrl) {
    try { console.log(`[PROXY] mode: ON â†’ ${maskProxy(sessionProxyUrl)}`); } catch {}
  } else {
    try { console.log('[PROXY] mode: OFF (DIRECT) â€” no proxy configured'); } catch {}
  }
}

/** Kompatibel mundur dengan pemanggilan lama: agent: getRandomProxy() */
function getRandomProxy() {
  return sessionAgent || undefined; // per-sesi & konsisten
}


/* ---------- Cek IP keluar (pakai agent yg sama) ---------- */
async function getCurrentOutboundIP() {
  // beberapa endpoint fallback
  const targets = [
    'https://api.ipify.org?format=json',
    'https://ifconfig.me/ip',
    'https://icanhazip.com'
  ];

  // helper fetch dengan timeout
  async function fetchWithTimeout(url, { agent, timeoutMs = 7000 }) {
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await fetch(url, { agent, signal: controller.signal });
      const ct = (res.headers.get('content-type') || '').toLowerCase();
      if (ct.includes('application/json')) {
        const j = await res.json();
        clearTimeout(t);
        return (j && j.ip) ? String(j.ip).trim() : null;
      }
      const txt = (await res.text()).trim();
      clearTimeout(t);
      return txt || null;
    } catch {
      clearTimeout(t);
      return null;
    }
  }

  for (const url of targets) {
    // pakai batas dari FETCH_TIMEOUT_MS tapi clamp ke 7s untuk checker ini
    const ip = await fetchWithTimeout(url, {
      agent: getRandomProxy(),
      timeoutMs: Math.min(FETCH_TIMEOUT_MS, 7000)
    });
    if (ip) return ip;
  }
  return null;
}

/* ========================================================== */


/* ================================================================
   1. ---------- ENDPOINT WRAPPERS (ASLI) -------------------------
   Semua endpoint asli tidak diubah, hanya ditambahkan agen proxy
   ================================================================ */



// 1.0 CINEMAS LIST (NEW) â€” ambil dari API & cache
const CINEMA_CACHE = { at: 0, list: [] }; // {id,name,location_id,location_name}

/** Ambil daftar bioskop dari CGV (cached, expire 12 jam). */
async function fetchCinemaList(
  ua   = getRandomUA(),
  lang = getRandomLang(),
  opts = {} // { latitude, longitude }
) {
  const TTL = 12 * 60 * 60 * 1000; // 12 jam
  if (CINEMA_CACHE.list.length && Date.now() - CINEMA_CACHE.at < TTL) {
    return CINEMA_CACHE.list;
  }

  const headers = generateRandomHeaders();
  
  // header koordinat opsional (kalau mau ikut behavior app asli)
  if (opts.latitude  != null) headers['latitude']  = String(opts.latitude);
  if (opts.longitude != null) headers['longitude'] = String(opts.longitude);

  try {
    const res  = await fetch('https://v2-api.cgv.id/api/cinemas', {
      method: 'GET',
      headers,
      agent : getRandomProxy()
    });
    const text = await res.text();
    const j    = JSON.parse(text);
    const arr  = Array.isArray(j?.data) ? j.data : [];

    // map ringkas & dedupe by id
    const seen = new Set();
    const list = arr
      .filter(c => c && c.id)
      .map(c => ({
        id            : String(c.id),
        name          : String(c.name || '-'),
        location_id   : String(c.location_id || ''),
        location_name : String(c.location_name || '-')
      }))
      .filter(c => (seen.has(c.id) ? false : (seen.add(c.id), true)));

    CINEMA_CACHE.list = list;
    CINEMA_CACHE.at   = Date.now();
    return list;
  } catch (e) {
    return CINEMA_CACHE.list; // kalau error, balikin cache (bisa kosong)
  }
}

/** Pilih ID bioskop acak; kalau ada prefer lokasi_id, diutamakan. */
async function pickRandomCinemaId(
  ua   = getRandomUA(),
  lang = getRandomLang(),
  preferLocationId = null,
  coords = null // {latitude, longitude}
) {
  const cinemas = await fetchCinemaList(ua, lang, coords || {});
  if (!cinemas.length) return null;
  if (preferLocationId) {
    const near = cinemas.filter(c => c.location_id === String(preferLocationId));
    if (near.length) return near[Math.floor(Math.random() * near.length)].id;
  }
  return cinemas[Math.floor(Math.random() * cinemas.length)].id;
}

/** Cari deskripsi pendek buat logging. */
function describeCinema(id) {
  const c = CINEMA_CACHE.list.find(x => x.id === String(id));
  return c ? `${c.location_name} â€” ${c.name}` : String(id);
}

// 1.1 Email OTP: Kirim (return juga retry_after_ms utk 429)
const getSendOtpEmail = async (emailUse, ua = getRandomUA(), lang = getRandomLang()) => {
  const form = new FormData();
  form.set('email', emailUse);

  const DEBUG_HTTP = String(process.env.DEBUG_HTTP || '1') === '1';
  const MAX_BODY_LOG = Number(process.env.LOG_BODY_MAX_LEN || 600);

  try {
    const res = await fetch('https://v2-api.cgv.id/api/regist-email-otp', {
      method: 'POST',
      headers: generateRandomHeaders({
        'User-Agent': ua,
        'Accept-Language': lang
      }),
      body: form,
      agent: getRandomProxy()
    });

    const text = await res.text();

    // parse retry-after header â†’ ms
    const ra = res.headers.get('retry-after');
    let retry_after_ms;
    if (ra) {
      const n = Number(ra);
      retry_after_ms = Number.isFinite(n) ? n * 1000 : Math.max(0, Date.parse(ra) - Date.now());
    }

    let json;
    try { json = text ? JSON.parse(text) : null; } catch (e) {
      if (DEBUG_HTTP) {
        console.log('');
        console.log(chalk.red.bold('âœ– Send Email OTP FAILED (non-JSON response)'));
        console.log(chalk.gray(`â€¢ status: ${res.status}`));
        console.log(chalk.gray('â€¢ headers:'), {
          'content-type': res.headers.get('content-type'),
          'retry-after': ra,
          'x-ratelimit-limit': res.headers.get('x-ratelimit-limit'),
          'x-ratelimit-remaining': res.headers.get('x-ratelimit-remaining'),
          'x-ratelimit-reset': res.headers.get('x-ratelimit-reset')
        });
        const snip = text.length > MAX_BODY_LOG ? text.slice(0, MAX_BODY_LOG) + ' â€¦(truncated)' : text;
        console.log(chalk.gray('â€¢ body:'), snip);
        console.log('');
      }
      return { status_code: res.status || 520, message: 'Non-JSON response from regist-email-otp', retry_after_ms };
    }

    if (res.status !== 200 || (json && json.status_code && json.status_code !== 200)) {
      if (DEBUG_HTTP) {
        console.log('');
        console.log(chalk.red.bold('âœ– Send Email OTP FAILED'));
        console.log(chalk.gray(`â€¢ status: ${res.status}`));
        console.log(chalk.gray('â€¢ headers:'), {
          'content-type': res.headers.get('content-type'),
          'retry-after': ra,
          'x-ratelimit-limit': res.headers.get('x-ratelimit-limit'),
          'x-ratelimit-remaining': res.headers.get('x-ratelimit-remaining'),
          'x-ratelimit-reset': res.headers.get('x-ratelimit-reset')
        });
        const snip = text.length > MAX_BODY_LOG ? text.slice(0, MAX_BODY_LOG) + ' â€¦(truncated)' : text;
        console.log(chalk.gray('â€¢ body:'), snip);
        console.log(chalk.gray('â€¢ json:'), json);
        console.log('');
      }
    }

    if (json && !json.status_code) json.status_code = res.status;
    if (json) json.retry_after_ms = retry_after_ms;
    return json || { status_code: res.status || 520, message: 'Empty response', retry_after_ms };

  } catch (e) {
    if (String(process.env.DEBUG_HTTP || '1') === '1') {
      console.log('');
      console.log(chalk.red.bold('âœ– Send Email OTP FAILED (network error)'));
      console.log(chalk.gray('â€¢ error:'), e.message || e.name);
      console.log('');
    }
    return { status_code: 500, message: e.message || 'Network error' };
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1.2 Email OTP: Verify (robust, retries + safe JSON parsing)
// â”€â”€ SESUDAH  (ganti seluruh blok)
const getVerifyOtpEmail = async (
  emailUse,
  kodeOtp,
  ua   = getRandomUA(),
  lang = getRandomLang()
) => {
  const form = new FormData();
  form.set('email', emailUse);
  form.set('otp',   kodeOtp);

  const MAX = 5;
  for (let attempt = 1; attempt <= MAX; attempt++) {
    try {
      const res = await fetch('https://v2-api.cgv.id/api/regist-email-verify', {
        method : 'POST',
        headers: generateRandomHeaders({
          'User-Agent': ua,
          'Accept-Language': lang
        }),
        body : form,
        agent: getRandomProxy()
      });

      const text = await res.text();
      return JSON.parse(text);
    } catch (err) {
      if (attempt === MAX) {
        return { status_code: 500, message: err.message };
      }
      await delay(1000);
    }
  }
};


// 1.3 Register account (UPDATED: gender + pref_cinema random dari /cinemas)
const getRegisterAccount = async (
  emailUse,
  kodeOtp,
  nameUse,
  numberUse,
  birthdateUse,
  passwordUse,
  pinUse,
  ua          = getRandomUA(),
  lang        = getRandomLang(),
  genderUse   = '01',        // '01' male, '02' female
  prefCinemaId = null        // kalau null â†’ ambil acak dari API
) => {
  // Tentukan pref_cinema
  let prefCinema = prefCinemaId;
  if (!prefCinema) {
    // kamu bisa isi preferLocationId dari logic kamu sendiri (mis. mapping kota telepon)
    const preferLocationId = null; // atau '013' untuk Bekasi, dll
    prefCinema = await pickRandomCinemaId(ua, lang, preferLocationId);
  }
  if (!prefCinema) prefCinema = '048'; // fallback aman kalau API gagal

  const form = new FormData();
  form.set('email',       emailUse);
  form.set('otp',         kodeOtp);
  form.set('name',        nameUse);
  form.set('mobile_no',   numberUse);
  form.set('birthdate',   birthdateUse);
  form.set('gender',      genderUse);     // â† pakai parameter
  form.set('pref_cinema', prefCinema);    // â† hasil random dari API
  form.set('password',    passwordUse);
  form.set('pin',         pinUse);

  try {
    const res = await fetch('https://v2-api.cgv.id/api/register-v2', {
      method : 'POST',
      headers: generateRandomHeaders({
        'User-Agent': ua,
        'Accept-Language': lang
      }),
      body : form,
      agent: getRandomProxy()
    });
    const j = await res.json();
    // biar gampang debug, sekalian balikin cinema yang dipakai
    return { ...j, _pref_cinema_used: prefCinema };
  } catch (e) {
    return { status_code: 500, message: e.message };
  }
};


// 1.4 Login â€” ROBUST (timeout + safe JSON parse + rate-limit headers surfaced)
const getLoginAccount = async (
  emailUse,
  passwordUse,
  deviceId = generateDeviceId(),
  ua       = getRandomUA(),
  lang     = getRandomLang()
) => {
  const form = new FormData();
  form.set('email',     emailUse);
  form.set('password',  passwordUse);
  form.set('device_id', deviceId);

  // Timeout tegas (ambil dari konstanta global)
  const TIMEOUT_MS = FETCH_TIMEOUT_MS;
  const controller = new AbortController();
  const to = setTimeout(() => controller.abort(), TIMEOUT_MS);

  try {
    const res = await fetch('https://v2-api.cgv.id/api/login', {
      method : 'POST',
      headers: generateRandomHeaders({
        'User-Agent': ua,
        'Accept-Language': lang
      }),
      body   : form,
      agent  : getRandomProxy(),
      signal : controller.signal
    });
    //

    const text = await res.text();
    clearTimeout(to);

    // Coba parse JSON; kalau gagal, tetap return payload generik
    let parsed = null;
    try {
      parsed = text ? JSON.parse(text) : null;
    } catch { /* non-JSON (gateway/anti-bot/HTML) */ }

    // Ambil header rate-limit / retry-after agar caller bisa patuh backoff
    const retryAfterHdr = res.headers.get('retry-after'); // detik atau HTTP-date
    const retry_after = retryAfterHdr ? Number(retryAfterHdr) : undefined;
    let retry_after_ms;
    if (retryAfterHdr) {
      const n = Number(retryAfterHdr);
      if (!Number.isNaN(n)) {
        retry_after_ms = n * 1000;
      } else {
        const until = Date.parse(retryAfterHdr);
        if (!Number.isNaN(until)) retry_after_ms = Math.max(0, until - Date.now());
      }
    }

    const rate_limit = {
      limit    : Number(res.headers.get('x-ratelimit-limit'))    || undefined,
      remaining: Number(res.headers.get('x-ratelimit-remaining'))|| undefined,
      reset    : Number(res.headers.get('x-ratelimit-reset'))    || undefined
    };

    if (parsed) {
      // Selaraskan skema lama
      if (!parsed.status_code) parsed.status_code = res.status;

      // Tambahkan info header penting (tanpa mengubah shape inti)
      return {
        ...parsed,
        status      : res.status,
        ok          : res.ok,
        retry_after,
        retry_after_ms,
        rate_limit
      };
    }

    // Non-JSON / kosong
    if (DEBUG) {
      console.log(chalk.gray(`[DEBUG] Non-JSON login response (${res.status}) for ${emailUse}:`));
      console.log(chalk.gray(text.slice(0, 200)));
    }
    return {
      status_code   : res.status || 520,
      status        : res.status,
      ok            : res.ok,
      message       : 'Non-JSON response from login endpoint',
      retry_after,
      retry_after_ms,
      rate_limit,
      raw           : text.slice(0, 200)
    };

  } catch (e) {
    clearTimeout(to);
    if (DEBUG) console.log(chalk.gray(`[DEBUG] Login fetch error for ${emailUse}: ${e.name === 'AbortError' ? 'timeout' : e.message}`));
    return {
      status_code: 500,
      message    : e.name === 'AbortError' ? `Login failed: timeout after ${TIMEOUT_MS}ms` : `Login failed: ${e.message}`
    };
  }
};




// 1.5 Send SMS OTP
const sendPhoneOtp = async (
  token,
  mobileNo,
  ua   = getRandomUA(),
  lang = getRandomLang()
) => {
  const form = new FormData();
  form.set('mobile_no', mobileNo);
  try {
    const res = await fetch('https://v2-api.cgv.id/api/membership/verify/req-phone-v2', {
      method : 'POST',
      headers: generateRandomHeaders({
        Authorization     : `Bearer ${token}`,
        'User-Agent': ua,
        'Accept-Language': lang
      }),
      body : form,
      agent: getRandomProxy()
    });
    return await res.json();
  } catch (e) {
    return { status_code: 500, message: e.message };
  }
};

// 1.6 Verify SMS OTP
const verifyPhoneOtp = async (
  token,
  mobileNo,
  otp,
  ua   = getRandomUA(),
  lang = getRandomLang()
) => {
  const form = new FormData();
  form.set('mobile_no', mobileNo);
  form.set('otp',       otp);
  try {
    const res = await fetch('https://v2-api.cgv.id/api/membership/verify/phone-v2', {
      method : 'POST',
      headers: {
        Authorization     : `Bearer ${token}`,
        'User-Agent'      : ua,
        'Accept-Language' : lang,
        Connection        : 'Keep-Alive',
        Accept            : 'application/json, text/plain, */*',
        'Accept-Encoding' : 'gzip',
      },
      body : form,
      agent: getRandomProxy()
    });
    return await res.json();
  } catch (e) {
    return { status_code: 500, message: e.message };
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1.7 Update profile (robust, retries + safe JSON parsing)
const updateProfile = async (
  token,
  payload,
  ua   = getRandomUA(),
  lang = getRandomLang()
) => {
  const MAX = 5;
  for (let i = 1; i <= MAX; i++) {
    try {
      const res = await fetch('https://v2-api.cgv.id/api/membership/promo-profile/update', {
        method : 'POST',
        headers: generateRandomHeaders({
          Authorization     : `Bearer ${token}`,
          'User-Agent': ua,
          'Accept-Language': lang,
          'Content-Type': 'application/json'
        }),
        body : JSON.stringify(payload),
        agent: getRandomProxy()
      });
      return await res.json();
    } catch (err) {
      if (i === MAX) return { status_code: 500, message: err.message };
      await delay(1000);
    }
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1.8 Member Info: robust (safe JSON parse + retry)
const getMemberInfo = async (
  token,
  ua   = getRandomUA(),
  lang = getRandomLang()
) => {
  const form = new FormData();
  const MAX = 5;
  for (let i = 1; i <= MAX; i++) {
    try {
      const res = await fetch('https://v2-api.cgv.id/api/membership/info', {
        method : 'POST',
        headers: generateRandomHeaders({
          'Authorization': `Bearer ${token}`,
          'User-Agent': ua,
          'Accept-Language': lang
        }),
        body : form,
        agent: getRandomProxy()
      });

      const text = await res.text();            // â† baca sebagai teks dulu
      try {
        const j = JSON.parse(text);             // â† coba parse JSON
        if (!j.status_code) j.status_code = res.status;
        return j;
      } catch {
        if (i < MAX) {                          // retry kalau non-JSON
          await delay(800);
          continue;
        }
        return {
          status_code: res.status || 520,
          message: 'Non-JSON response from membership/info',
          raw: text.slice(0, 200)
        };
      }
    } catch (err) {
      if (i === MAX) return { status_code: 500, message: err.message };
      await delay(800);
    }
  }
};



// 1.9 Delete membership  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const deleteMembership = async (token, password, message = '', ua = getRandomUA(), lang = getRandomLang()) => {
  const form = new FormData();
  form.set('password', password);
  form.set('message',  message);

  try {
    const res = await fetch('https://v2-api.cgv.id/api/membership/delete', {
      method : 'POST',
      headers: generateRandomHeaders({
        Authorization     : `Bearer ${token}`,
        'User-Agent': ua,
        'Accept-Language': lang
      }),
      body : form,
      agent: getRandomProxy()
    });
    return await res.json();
  } catch (e) {
    return { status_code: 500, message: e.message };
  }
};
/* ================================================================
   2. ---------- HELPER & GENERATOR -------------------------------
   Tambahan: dot-trick, plus-trick, alias Gmail
   ================================================================ */

// â”€â”€ 2.1  dot-trick  (iqra.nur â†’ iqra nur kombinasi titik) â”€â”€â”€â”€â”€â”€â”€
function generateDotTricks(fullEmail) {
  const [user, domain] = fullEmail.split('@');
  if (domain.toLowerCase() !== 'gmail.com') return [fullEmail];

  const results = new Set();

  const dfs = (prefix = '', idx = 0) => {
    if (idx === user.length) {
      results.add(`${prefix}@${domain}`);
      return;
    }
    // tanpa titik
    dfs(prefix + user[idx], idx + 1);
    // pakai titik (bukan di depan)
    if (idx > 0) dfs(prefix + '.' + user[idx], idx + 1);
  };

  dfs();
  return [...results];
}

// â”€â”€ 2.2  plus-trick  (iqra+1@gmail.com, iqra+2â€¦) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generatePlusTricks(basePrefix, count = 400) {
  const aliases = new Set();                // menjaga unik
  while (aliases.size < count) {
    const rnd = Math.floor(1e4 + Math.random() * 9e7); // 1000-99 999 999
    aliases.add(`${basePrefix}+${rnd}@gmail.com`);
  }
  return [...aliases];
}

// â”€â”€ 2.3  gabungan & unik â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Â» campur dot-trick & plus-trick secara acak
function generateGmailAliases(basePrefix) {
  // hanya dot-trick biasa
  const dots = generateDotTricks(`${basePrefix}@gmail.com`);
  return dots.sort(() => 0.5 - Math.random()); // acak urutan
}


// â”€â”€ 2.4  baca alias yang belum dipakai â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const readGmailAliasList = async () => {
  const used = new Set();
  try {
    const raw = await fs.readFile('akunLogin.txt', 'utf-8');
    raw.split('\n').forEach(l => {
      const e = l.split('|')[0]?.trim();
      if (e) used.add(e);
    });
  } catch { /* file mungkin belum ada */ }

  return generateGmailAliases(EMAIL_PREFIX).filter(e => !used.has(e));
};


const readAkunLoginList = async (filePath = 'akunLogin.txt') => {
  try {
    const data = await fs.readFile(filePath, 'utf-8');

    return data
      .split('\n')           // pecah per baris
      .map(l => l.trim())    // buang spasi di depan/belakang baris
      .filter(Boolean)       // skip baris kosong
      .map(l => {
        // kolom dipisah â€˜|â€™, lalu trim tiap kolom
        const [emailRaw, passwordRaw] = l.split('|').map(s => s.trim());

        return {
          email:    emailRaw,
          password: passwordRaw
        };
      });

  } catch (err) {
    console.error('âŒ Gagal membaca akunLogin.txt:', err.message);
    return [];
  }
};


/** 
 * Generate birthdate dinamis:
 * - offsetDays: jumlah hari dari hari ini menuju ulang tahun (default 33)
 * - enforce minimal 1 (sudah divalidasi di prompt)
 */
function generateRandomBirthdate(offsetDays = 33) {
  // Gunakan "hari ini" berdasarkan local time proses
  const today = new Date();

  // Tambah offset (hari) ke depan
  const target = new Date(today);
  target.setDate(target.getDate() + Number(offsetDays || 0));

  // Tahun acak 1970â€“1999
  let year  = Math.floor(Math.random() * (2000 - 1970 + 1)) + 1970;
  let month = target.getMonth() + 1; // 1..12
  let day   = target.getDate();      // 1..31

  // Perbaiki 29 Feb jika tahun acak bukan kabisat
  const isLeap = (y) => (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));
  if (month === 2 && day === 29 && !isLeap(year)) {
    day = 28;
  }

  const monthStr = String(month).padStart(2, '0');
  const dayStr   = String(day).padStart(2, '0');
  const birthdate = `${year}${monthStr}${dayStr}`;

  // Updated: human-readable text (e.g., "07 April 2004")
  const monthNames = [
    "Januari","Februari","Maret","April","Mei","Juni",
    "Juli","Agustus","September","Oktober","November","Desember"
  ];
  const pretty = `${dayStr} ${monthNames[month - 1]} ${year}`;

  // Enhanced birthdate display
  console.log();
  console.log(chalk.blue('â”Œ' + 'â”€'.repeat(48) + 'â”'));
  console.log(chalk.blue('â”‚') + chalk.white.bold('  ğŸ‚ BIRTHDATE CONFIGURATION'.padEnd(47)) + chalk.blue('â”‚'));
  console.log(chalk.blue('â”œ' + 'â”€'.repeat(48) + 'â”¤'));
  console.log(chalk.blue('â”‚') + `  Generated: ${chalk.cyan.bold(birthdate)} (offset: ${offsetDays} days)`.padEnd(48) + chalk.blue('â”‚'));
  console.log(chalk.blue('â”‚') + `  Birthday:  ${chalk.yellow.bold(pretty)}`.padEnd(48) + chalk.blue('â”‚'));
  console.log(chalk.blue('â””' + 'â”€'.repeat(48) + 'â”˜'));
  console.log();

  return birthdate;
}



function generatePhoneNumber() {
  const p = [
    '0811','0812','0813','0821','0822','0823',
    '0852','0853','0851','0817','0818','0819',
    '0859','0877','0878','0895','0896','0897',
    '0898','0899','0881','0882','0883','0884','0838'
  ];
  const pre = p[Math.floor(Math.random() * p.length)];
  const num = String(Math.floor(Math.random() * 1e7)).padStart(7, '0');
  return pre + num;
}

function generateRandomProfile(mobileNo, email) {
  const cities = ['024','007','012'];        // city id tetap pakai mapping CGV
  const genres = ['01','02','03','04','05','06','07','08','09','10','11','12','13','14','15','16','17'];
  const shuffle = a => a.sort(() => 0.5 - Math.random());
  const pg = shuffle([...genres]).slice(0, Math.floor(Math.random() * 3) + 1);

  return {
    // faker otomatis bikin nama random, laki/perempuan
    name: faker.person.fullName(),
    gender: faker.person.sex() === 'male' ? '01' : '02',
    address: faker.location.streetAddress(true), // contoh: "Jl. Melati No. 45, Jakarta"
    marital_status_id: ['01','02','03'][Math.floor(Math.random() * 3)], // tetap random
    city_id: cities[Math.floor(Math.random() * cities.length)],
    pref_genre: pg,
    eligible_id: null,
    mobile_no: mobileNo,
    email
  };
}


function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }


/* ================================================================
   3. ---------- PROMPT UTILITIES --------------------------------
   inquirer prompts untuk jumlah, OTP email, nomor ponsel, OTP SMS
   ================================================================ */
async function inputJumlahCreate() {
  const { jumlahCreate } = await inquirer.prompt([{
    type: 'number', 
    name: 'jumlahCreate',
    message: 'ğŸ¯ How many accounts do you want to create?',
    validate: v => Number.isInteger(v) && v > 0 ? true : 'Enter a positive integer'
  }]);
  return jumlahCreate;
}

async function inputKodeOtp() {
  const { otp } = await inquirer.prompt([{
    type: 'input', 
    name: 'otp',
    message: 'ğŸ“§ Enter Email OTP (6 digits):',
    validate: v => /^\d{6}$/.test(v) ? true : 'OTP must be 6 digits'
  }]);
  return otp.trim();
}

async function inputPhoneNumber(defaultNum) {
  const { phone } = await inquirer.prompt([{
    type: 'input', 
    name: 'phone',
    message: `ğŸ“± Phone number (default: ${maskPhone(defaultNum)}):`
  }]);
  return (phone || '').trim() || defaultNum;
}

async function promptSmsOtp() {
  const { otpSms } = await inquirer.prompt([{
    type: 'input', 
    name: 'otpSms',
    message: 'ğŸ“± Enter SMS OTP (6 digits) or /cancel:',
    validate: v => v.toLowerCase() === '/cancel' || /^\d{6}$/.test(v)
      ? true : 'OTP must be 6 digits or /cancel'
  }]);
  return otpSms.trim();
}

/* NEW: prompt file nomor (default: nomor.txt) */
async function promptNomorFilename() {
  const { filename } = await inquirer.prompt([{
    type: 'input',
    name: 'filename',
    message: 'ğŸ“„ Phone number file name (default: nomor.txt):',
    default: 'nomor.txt',
    filter: v => (v || 'nomor.txt').trim()
  }]);
  return filename || 'nomor.txt';
}

/* NEW: prompt offset birthdate (default 33, warn if <30) */
async function promptBirthdateOffsetDays() {
  while (true) {
    const { days } = await inquirer.prompt([{
      type: 'number',
      name: 'days',
      message: 'ğŸ‚ Days from today to set birthdate? (min 30, default 33):',
      default: 33,
      validate: v => Number.isInteger(v) && v > 0 ? true : 'Enter a positive integer'
    }]);
    if (days >= 30) return days;

    const { confirmText } = await inquirer.prompt([{
      type: 'input',
      name: 'confirmText',
      message: chalk.yellow(`âš ï¸  Offset ${days} < 30 days. Type "YES" to confirm, or leave empty to cancel & retry:`),
    }]);
    if ((confirmText || '').trim().toUpperCase() === 'YES') {
      return days;
    }
    console.log(chalk.gray('â€¢ Cancelled. Please enter offset days again (â‰¥ 30, or <30 with "YES" confirmation).'));
  }
}

/* === [ADD] Random Password Helpers ================================== */

/* === [REPLACE] Human-ish Strong Password Helpers ===================== */

// Prompt sekali per sesi: Enter = Default (SET_PASSWORD), y = Random (human-ish)
async function promptPasswordMode() {
  const { ans } = await inquirer.prompt([{
    type: 'input',
    name: 'ans',
    message: 'ğŸ” Random password? Enter=Default (SET_PASSWORD), y=Random (human-ish):',
    filter: v => String(v || '').trim().toLowerCase()
  }]);
  return (ans === 'y') ? 'random' : 'default';
}

// Generator â€œmanusiawi tapi kuatâ€: 2 kata + angka 2â€“3 digit + 1 simbol, leetspeak ringan
function generateHumanishPassword() {
  const WORDS_L = ['Solar','Crimson','Silver','Pixel','Turbo','Velvet','Neon','Quantum','Arctic','Zenith','Aero','Echo','Falcon','Nimbus','Nova','Orion','Titan','Vortex','Zephyr','Cosmic','Bambu','Sunda','Atlas','Kopi','Batik','Bulan','Samudra','Senja','Pelangi'];
  const WORDS_R = ['Mango','Drift','Tiger','Comet','Glacier','Harbor','Jelly','Lynx','Mocha','Noodle','Omega','Panda','Quill','Raven','Sushi','Tango','Umbra','Viper','Waffle','Kuda','Kenari','Merapi','Sagu','Roti','Angkasa','Payon','Kelapa','Berlian','Purnama'];
  const SYMS = ['!','@','#','$','%','&','*','?'];

  const rInt = (a,b)=>a+Math.floor(Math.random()*(b-a+1));
  const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
  const shuffle = (s)=>s.split('').sort(()=>Math.random()-0.5).join('');

  const maybeLeet = (w) => {
    if (Math.random() < 0.5) return w;
    return w
      .replace(/a/gi, m => (Math.random()<0.35 ? '@' : m))
      .replace(/i/gi, m => (Math.random()<0.25 ? '1' : m))
      .replace(/o/gi, m => (Math.random()<0.25 ? '0' : m));
  };

  const ensurePolicy = (pwd) => {
    let s = pwd;
    if (!/[A-Z]/.test(s)) s += String.fromCharCode(65 + Math.floor(Math.random()*26));
    if (!/[a-z]/.test(s)) s += String.fromCharCode(97 + Math.floor(Math.random()*26));
    if (!/\d/.test(s))    s += String(rInt(0,9));
    if (!/[!@#$%&*?]/.test(s)) s += pick(SYMS);
    if (s.length < 10) s += String(rInt(10,99));
    if (s.length > 18) s = s.slice(0, 18);
    return shuffle(s);
  };

  const w1 = maybeLeet(pick(WORDS_L));
  const w2 = maybeLeet(pick(WORDS_R));
  const sep = Math.random() < 0.5 ? '-' : (Math.random()<0.5 ? '.' : '');
  const num = Math.random() < 0.6 ? String(rInt(10,99)) : String(rInt(100,999));
  const sym = pick(SYMS);

  let candidate = `${w1}${sep}${w2}${num}${sym}`;
  if (Math.random() < 0.18) candidate += String(rInt(1,9));
  return ensurePolicy(candidate);
}

/* ==================================================================== */


/* ================== [ADD] email.txt + sukses_email.json helpers ================== */

// util acak integer
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

// ----- sukses_email.json (list email yang sudah berhasil) -----
const SUCCESS_FILE = 'sukses_email.json';

async function loadSuccessEmails() {
  try {
    const raw = await fs.readFile(SUCCESS_FILE, 'utf-8');
    const parsed = JSON.parse(raw);
    // support format lama (array of objects) maupun baru (obj dengan emails[])
    if (Array.isArray(parsed)) {
      const list = parsed.map(x => String(x.email || x).toLowerCase());
      return { list, set: new Set(list) };
    }
    const list = Array.isArray(parsed.emails) ? parsed.emails.map(x => String(x).toLowerCase()) : [];
    return { list, set: new Set(list) };
  } catch {
    return { list: [], set: new Set() };
  }
}

async function saveSuccessEmail(email) {
  const norm = String(email||'').trim().toLowerCase();
  if (!norm) return;
  let j = { generated_at: new Date().toISOString(), total: 0, emails: [] };
  try {
    const raw = await fs.readFile(SUCCESS_FILE, 'utf-8');
    const prev = JSON.parse(raw);
    if (Array.isArray(prev)) {
      // migrate format lama -> baru
      j.emails = prev.map(x => String(x.email || x).toLowerCase());
    } else if (prev && Array.isArray(prev.emails)) {
      j = prev;
    }
  } catch {}
  if (!j.emails.includes(norm)) j.emails.push(norm);
  j.total = j.emails.length;
  j.generated_at = new Date().toISOString();
  await fs.writeFile(SUCCESS_FILE, JSON.stringify(j, null, 2), 'utf-8');
}

// [NEW] removeSuccessEmail -> buat auto-bersih pas ban
async function removeSuccessEmail(email) {
  const norm = String(email||'').trim().toLowerCase();
  if (!norm) return;
  let j = { generated_at: new Date().toISOString(), total: 0, emails: [] };
  try {
    const raw = await fs.readFile(SUCCESS_FILE, 'utf-8');
    const prev = JSON.parse(raw);
    if (Array.isArray(prev)) {
      j.emails = prev.map(x => String(x.email || x).toLowerCase());
    } else if (prev && Array.isArray(prev.emails)) {
      j = prev;
    }
  } catch {}
  j.emails = Array.isArray(j.emails)
    ? j.emails.filter(e => e !== norm)
    : [];
  j.total = j.emails.length;
  j.generated_at = new Date().toISOString();
  try {
    await fs.writeFile(SUCCESS_FILE, JSON.stringify(j, null, 2), 'utf-8');
    console.log(chalk.gray('(Removed from sukses_email.json)'));
  } catch (e) {
    console.log(chalk.red(`(Failed to update sukses_email.json: ${e.message})`));
  }
}

// ----- email.txt watcher & helpers -----
let EMAIL_FILE = 'email.txt';

// pastikan file email.txt ada
async function ensureEmailFileExists() {
  try { await fs.access(EMAIL_FILE); }
  catch { await fs.writeFile(EMAIL_FILE, '', 'utf-8'); }
}

// auto-buka editor
async function openEmailFileInEditor() {
  try {
    const { spawn } = await import('child_process');
    const plat = process.platform;
    if (plat === 'win32') {
      spawn('cmd', ['/c', 'start', '""', EMAIL_FILE], { detached: true, stdio: 'ignore' });
    } else if (plat === 'darwin') {
      spawn('open', [EMAIL_FILE], { detached: true, stdio: 'ignore' });
    } else {
      const p = spawn('xdg-open', [EMAIL_FILE], { detached: true, stdio: 'ignore' });
      p.on('error', () => spawn('nano', [EMAIL_FILE], { stdio: 'inherit' }));
    }
  } catch {
    try {
      const { spawn } = await import('child_process');
      if (process.platform === 'win32') spawn('notepad', [EMAIL_FILE], { stdio: 'inherit' });
      else spawn('nano', [EMAIL_FILE], { stdio: 'inherit' });
    } catch {}
  }
}

// baca email pending (tambahkan @gmail.com bila tak ada) & skip yang sudah sukses
async function readPendingEmails(successSet) {
  try {
    const raw = await fs.readFile(EMAIL_FILE, 'utf-8');
    const lines = raw.split('\n')
      .map(s => s.trim())
      .filter(s => s && !s.startsWith('#'))
      .map(e => (e.includes('@') ? e : `${e}@gmail.com`).toLowerCase());
    return lines.filter(e => !successSet.has(e));
  } catch {
    return [];
  }
}

// tunggu sampai email.txt terisi; auto-open; lanjut setelah Ctrl+S
async function waitForEmailsFilled(minCount = 1, successSet = new Set()) {
  log.warning(`File ${EMAIL_FILE} is empty or all emails are already used.`);
  console.log(chalk.gray('ğŸ“ Opening editor for email.txt â€” add one email per line, then Ctrl+Sâ€¦'));
  await openEmailFileInEditor();

  const fsRaw = await import('fs');
  let watcher = null;
  let poll = null;
  let resolved = false;

  const readNow = async () => {
    try {
      const arr = await readPendingEmails(successSet);
      return (arr.length >= minCount) ? arr : null;
    } catch { return null; }
  };

  const first = await readNow();
  if (first) return first;

  return await new Promise((resolve) => {
    const tryResolve = async () => {
      if (resolved) return;
      const arr = await readNow();
      if (arr) {
        resolved = true;
        try { watcher && watcher.close(); } catch {}
        if (poll) clearInterval(poll);
        resolve(arr);
      }
    };

    try {
      watcher = fsRaw.watch(EMAIL_FILE, async (eventType) => {
        if (eventType === 'change' || eventType === 'rename') await tryResolve();
      });
    } catch {}

    poll = setInterval(() => { tryResolve(); }, 1000);
  });
}

// util acak integer (pakai yang sudah ada; hapus ini jika sudah didefinisikan)
const randIntBucket = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

// Hitung bucket dari basis â†’ 30â†’30â€“39, 33â†’30â€“39, 40â†’40â€“49, 55â†’50â€“59, dst (min 30)
function bucketFromBasis(basisDays) {
  const b = Math.max(30, Number(basisDays || 30));
  const decade = Math.floor(b / 10) * 10;
  return { min: decade, max: decade + 9 };
}

/*
  Prompt sekali di awal sesi:
  - Enter  â†’ ON dengan bucket mengikuti "Days from today..." yang diisi sebelumnya.
             Contoh: isi 40 â†’ 40â€“49; isi 55 â†’ 50â€“59.
  - y      â†’ ON dengan basis kustom (dibucket per dekade).
  - n      â†’ OFF (fallback 30 utk generator agar tetap valid).
*/
async function promptBirthdayOffsetConfigOnce(priorBasisDays) {
  const { ans } = await inquirer.prompt([{
    type: 'input',
    name: 'ans',
    message: 'ğŸ‚ Random birthday offset? Enter=ON (use prior basis), y=ON (custom basis), n=OFF:',
    filter: v => String(v||'').trim().toLowerCase()
  }]);

  if (ans === 'n') {
    return { mode: 'inactive', bucketMin: 30, bucketMax: 39, fallback: 30 };
  }

  if (!ans) {
    const buck = bucketFromBasis(priorBasisDays);
    return { mode: 'active', bucketMin: buck.min, bucketMax: buck.max, fallback: 30 };
  }

  if (ans === 'y') {
    const { basis } = await inquirer.prompt([{
      type: 'number',
      name: 'basis',
      message: 'Basis offset (mis. 33â†’30â€“39, 40â†’40â€“49, 55â†’50â€“59):',
      default: Number(priorBasisDays || 33),
      validate: v => Number.isInteger(v) && v >= 1 ? true : 'Masukkan bilangan bulat â‰¥ 1'
    }]);
    const buck = bucketFromBasis(basis);
    return { mode: 'active', bucketMin: buck.min, bucketMax: buck.max, fallback: 30 };
  }

  // default aman
  const buck = bucketFromBasis(priorBasisDays);
  return { mode: 'active', bucketMin: buck.min, bucketMax: buck.max, fallback: 30 };
}


/* ================================================================ */
const autoCreateAccount = async (mode = 'auto') => {
  // â”€â”€ identitas â€œper-deviceâ€ akan diisi ulang PER AKUN di dalam loop â”€â”€
  let deviceId; 
  let ua;       
  let lang;     

// === PROXY: pilih mode dari console, lalu init & tampilkan IP awal ===
await promptProxyAtStartup();       // â† [BARU] tampilkan menu ON/OFF
initSessionAgentIfNeeded();

const sessionIp = await getCurrentOutboundIP();
// Clean proxy status display
const proxyMode = sessionProxyUrl ? 'ON' : 'OFF';
const proxyInfo = sessionProxyUrl ? maskProxy(sessionProxyUrl) : 'DIRECT';
console.log(chalk.cyan('â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
console.log(chalk.cyan('â”‚') + chalk.white.bold('                    PROXY CONFIGURATION                    ') + chalk.cyan('â”‚'));
console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
console.log(chalk.cyan('â”‚') + ` ğŸŒ Mode     : ${proxyMode.padEnd(40)} ` + chalk.cyan('â”‚'));
console.log(chalk.cyan('â”‚') + ` ğŸ”— Proxy    : ${proxyInfo.slice(0,40).padEnd(40)} ` + chalk.cyan('â”‚'));
console.log(chalk.cyan('â”‚') + ` ğŸ“¡ IP       : ${(sessionIp || 'Unknown').padEnd(40)} ` + chalk.cyan('â”‚'));
console.log(chalk.cyan('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));



  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  // ====== BEARER/PASSWORD HELPERS (simpan ke account.json) =====
  const normEmail = s => String(s||'').trim().toLowerCase();

  const wrapBearer3_local = (token) => {
    const s = String(token || '');
    if (!s) return [];
    const part = Math.ceil(s.length / 3);
    return [ s.slice(0, part), s.slice(part, part*2), s.slice(part*2) ];
  };

  // NEW: upsert kolom password ke account.json
  async function upsertAccountJsonPassword_local(email, password) {
    if (!email || !password) return;
    let data = { generated_at: new Date().toISOString(), total_accounts: 0, checked: 0, items: [] };
    try {
      const raw = await fs.readFile('account.json', 'utf-8');
      const j = JSON.parse(raw);
      if (j && Array.isArray(j.items)) data = j;
    } catch {}
    const nowIso = new Date().toISOString();
    const idx = data.items.findIndex(x => normEmail(x.email) === normEmail(email));
    if (idx >= 0) {
      data.items[idx] = {
        ...data.items[idx],
        email,
        password,
        password_updated_at: nowIso
      };
    } else {
      data.items.push({
        no: data.items.length + 1,
        created_at: nowIso,
        login_ok: true,
        email,
        password,
        password_updated_at: nowIso
      });
    }
    data.items = data.items.map((x,i)=>({ ...x, no: i+1 }));
    data.total_accounts = data.items.length;
    data.checked = data.items.length;
    data.generated_at = nowIso;
    await fs.writeFile('account.json', JSON.stringify(data, null, 2), 'utf-8');
  }

  async function upsertAccountJsonBearer_local(email, token) {
    if (!email || !token) return;
    let data = { generated_at: new Date().toISOString(), total_accounts: 0, checked: 0, items: [] };
    try {
      const raw = await fs.readFile('account.json', 'utf-8');
      const j = JSON.parse(raw);
      if (j && Array.isArray(j.items)) data = j;
    } catch {}
    const idx = data.items.findIndex(x => normEmail(x.email) === normEmail(email));
    const nowIso = new Date().toISOString();
    if (idx >= 0) {
      data.items[idx] = {
        ...data.items[idx],
        email,
        bearer: token,
        bearer_wrapped: wrapBearer3_local(token),
        bearer_updated_at: nowIso
      };
    } else {
      data.items.push({
        no: data.items.length + 1,
        login_ok: true,
        email,
        bearer: token,
        bearer_wrapped: wrapBearer3_local(token),
        bearer_updated_at: nowIso,
        created_at: nowIso
      });
    }
    data.items = data.items.map((x,i)=>({ ...x, no: i+1 }));
    data.total_accounts = data.items.length;
    data.checked = data.items.length;
    data.generated_at = nowIso;
    await fs.writeFile('account.json', JSON.stringify(data, null, 2), 'utf-8');
  }
  // =============================================================

  // [ADD] helper purgeTextFilesForEmailSingle (hapus akun dari file txt lokal)
  async function purgeTextFilesForEmailSingle(email) {
    const emKey = String(email || '').trim().toLowerCase();

    // akunLogin.txt
    try {
      const raw = await fs.readFile('akunLogin.txt','utf-8');
      const lines = raw.split('\n').map(l=>l.trim()).filter(Boolean);
      const kept  = lines.filter(l => {
        const oldEmail = (l.split('|')[0] || '').trim().toLowerCase();
        return oldEmail !== emKey;
      });
      await fs.writeFile('akunLogin.txt', kept.join('\n') + (kept.length ? '\n' : ''), 'utf-8');
      console.log(chalk.gray('(Removed from akunLogin.txt)'));
    } catch (e) {
      if (e.code !== 'ENOENT') {
        console.log(chalk.red(`(Failed to update akunLogin.txt: ${e.message})`));
      }
    }

    // data.txt
    try {
      const raw = await fs.readFile('data.txt','utf-8');
      const lines = raw.split('\n').map(s=>s.trim()).filter(Boolean);
      const kept  = lines.filter(l => {
        return l.toLowerCase() !== emKey;
      });
      await fs.writeFile('data.txt', kept.join('\n') + (kept.length ? '\n' : ''), 'utf-8');
      console.log(chalk.gray('(Removed from data.txt)'));
    } catch (e) {
      if (e.code !== 'ENOENT') {
        console.log(chalk.red(`(Failed to update data.txt: ${e.message})`));
      }
    }

    // data_format.txt
    try {
      const raw = await fs.readFile('data_format.txt','utf-8');
      const lines = raw.split('\n').map(s=>s.trim()).filter(Boolean);
      const kept  = lines.filter(l => {
        const oldEmail = (l.split('|')[0] || '').trim().toLowerCase();
        return oldEmail !== emKey;
      });
      await fs.writeFile('data_format.txt', kept.join('\n') + (kept.length ? '\n' : ''), 'utf-8');
      console.log(chalk.gray('(Removed from data_format.txt)'));
    } catch (e) {
      if (e.code !== 'ENOENT') {
        console.log(chalk.red(`(Failed to update data_format.txt: ${e.message})`));
      }
    }
  }

  // [ADD] helper removeAccountFromAccountJson (hapus item dari account.json)
  async function removeAccountFromAccountJson(email) {
    try {
      const raw = await fs.readFile('account.json','utf-8');
      const j = JSON.parse(raw || '{}');
      if (!Array.isArray(j.items)) {
        console.log(chalk.red('account.json malformed (no items array)'));
        return;
      }

      const beforeLen = j.items.length;
      j.items = j.items.filter(it => {
        return String(it.email || '').trim().toLowerCase() !== String(email || '').trim().toLowerCase();
      });

      if (j.items.length !== beforeLen) {
        await fs.writeFile('account.json', JSON.stringify(j, null, 2), 'utf-8');
        console.log(chalk.gray('(Removed from account.json)'));
      } else {
        console.log(chalk.gray('(Account not found in account.json or already removed)'));
      }
    } catch (e) {
      console.log(chalk.red(`Failed to update account.json: ${e.message}`));
    }
  }

  // [ADD] helper banCurrentAccountFlow
  async function banCurrentAccountFlow(email, password, tokenRef, deviceIdRef, uaRef, langRef) {
    console.log(chalk.red('\nğŸš« BAN REQUESTED â€” attempting remote delete + local purge'));

    let workingToken = tokenRef;

    async function tryDeleteWithToken(tok, pwd) {
      try {
        const delRes = await deleteMembership(tok, pwd, '', uaRef, langRef);
        return delRes;
      } catch (e) {
        return { status_code: 0, message: e.message || 'deleteMembership error' };
      }
    }

    // 1. coba delete dengan token saat ini
    let delAttempt = await tryDeleteWithToken(workingToken, password);

    // 2. kalau token invalid, coba re-login, lalu delete ulang
    if (
      delAttempt.status_code === 401 ||
      /unauth|invalid token|expired/i.test(String(delAttempt.message||''))
    ) {
      console.log(chalk.yellow('â†» Token invalid/expired, re-logging before delete...'));

      const relog = await getLoginAccount(email, password, deviceIdRef, uaRef, langRef);
      if (relog && relog.status_code === 200 && relog.token) {
        workingToken = relog.token;
        delAttempt = await tryDeleteWithToken(workingToken, password);
      } else {
        console.log(chalk.red(`âš ï¸ Re-login failed before delete: ${relog?.message || relog?.status_code || 'unknown'}`));
      }
    }

    // 3. status delete
    if (delAttempt && delAttempt.status_code === 200) {
      console.log(chalk.green('âœ… Remote delete success (CGV membership deleted)'));
    } else {
      console.log(chalk.yellow(`âš ï¸ Remote delete not confirmed (${delAttempt?.status_code || '???'} ${delAttempt?.message || ''})`));
      console.log(chalk.yellow('   Will still purge locally.'));
    }

    // 4. purge lokal
    await purgeTextFilesForEmailSingle(email);
    await removeAccountFromAccountJson(email);

    // 5. purge dari sukses_email.json juga (BARU)
    try {
      await removeSuccessEmail(email);
    } catch (e) {
      console.log(chalk.red(`(Failed to purge from sukses_email.json: ${e.message})`));
    }

    console.log(chalk.red('ğŸš« Account banned & purged locally. Moving on...\n'));
  }

  // NEW helper: cari akun lokal di account.json berdasarkan email
  async function findLocalAccountByEmail(email) {
    const target = normEmail(email);
    try {
      const raw = await fs.readFile('account.json', 'utf-8');
      const j = JSON.parse(raw);
      if (!j || !Array.isArray(j.items)) return null;
      const hit = j.items.find(it => normEmail(it.email) === target);
      if (!hit) return null;
      return {
        email: hit.email,
        password: hit.password || null,
        bearer: hit.bearer || null,
        phone: hit.phone || null,
        verified_phone: !!hit.verified_phone,
        verified_email: !!hit.verified_email,
      };
    } catch {
      return null;
    }
  }

  // helper flow untuk akun recovery BERDASARKAN EMAIL (dipanggil saat step2 ketemu "already registered")
  async function processRecoveredAccountFlow(existingAccRec, emailUse, numberUse) {
    console.log(chalk.yellow('\nğŸ“‹ EXISTING ACCOUNT (EMAIL MATCH) DETECTED'));
    console.log(chalk.cyan('â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
    console.log(chalk.cyan('â”‚') + chalk.white.bold('            PROCESSING RECOVERED ACCOUNT (EMAIL)            ') + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.cyan('â”‚') + ` ğŸ“§ Email     : ${emailUse.slice(0,40).padEnd(40)} `.padEnd(58) + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”‚') + ` ğŸ“± New Phone : ${maskPhone(numberUse).padEnd(40)} `.padEnd(58) + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â”‚') + ` ğŸ”„ Action    : Re-login, SMS verify if needed`.padEnd(58) + chalk.cyan('â”‚'));
    console.log(chalk.cyan('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));

    // simpan/update password ke account.json (pastikan tetap ada)
    try { await upsertAccountJsonPassword_local(emailUse, existingAccRec.password); } catch {}

    // 1. Login dengan password dari account.json
    let loginResOld = await getLoginAccount(emailUse, existingAccRec.password, deviceId, ua, lang);
    if (loginResOld.status_code !== 200) {
      log.error(`Login failed for recovered account: ${loginResOld.message || loginResOld.status_code}`);
      return; // gagal recovery
    }
    let tokenOld = loginResOld.token;

    // simpan/refresh bearer
    try { await upsertAccountJsonBearer_local(emailUse, tokenOld); } catch {}

    // 2. Cek status verifikasi HP
    let infoOld = await getMemberInfo(tokenOld, ua, lang);
    let verifiedHP = infoOld.RESULTS?.ds_mbrList?.VERF_MOB_YN === '1';

    // Kalau belum verified -> kita pakai nomorUse (nomor yang lagi kita pakai sekarang)
    if (!verifiedHP) {
      while (true) {
        const req = await sendPhoneOtp(tokenOld, numberUse, ua, lang);
        if (req.status_code === 200) {
          log.success('SMS OTP sent for recovered account verification');
          break;
        }
        log.error(`Failed to send SMS OTP: ${req.message || req.status_code}`);
        const { action } = await inquirer.prompt([{
          type: 'input',
          name: 'action',
          message: 'ğŸ”„ Type /resend to try again or /cancel:',
          validate: v => /^\/resend$|^\/cancel$/i.test(v) ? true : 'Type /resend or /cancel'
        }]);
        if (/^\/cancel$/i.test(action)) {
          await snapshotAndSave({ token: tokenOld, email: emailUse, phone: numberUse });
          return;
        }
        if (req.status_code === 429) {
          log.warning('Rate limited - waiting 60 seconds...');
          await delay(60000);
        } else {
          await delay(1500);
        }
      }

      // Loop verifikasi fleksibel SMS OTP
      let cancelled = false;
      for (let i = 0; i < 15 && !verifiedHP && !cancelled; i++) {
        const code = await promptSmsOtpFlexible();

        if (/^\/cancel$/i.test(code)) {
          log.warning('Verification cancelled by user');
          cancelled = true;
          break;
        }
        if (/^\/resend$/i.test(code)) {
          const rr = await sendPhoneOtp(tokenOld, numberUse, ua, lang);
          if (rr.status_code === 429) {
            log.warning('Rate limited - waiting 60 seconds...');
            await delay(60000);
          } else if (rr.status_code === 200) {
            log.success('New SMS OTP sent successfully');
          } else {
            log.error(`Failed to resend SMS OTP: ${rr.message || rr.status_code}`);
          }
          i--;
          continue;
        }

        // NOTE: /ban tidak relevan di flow recovery lama, jadi tidak dipakai di sini

        const vr = await verifyPhoneOtp(tokenOld, numberUse, code, ua, lang);
        if (vr.status_code === 200) {
          verifiedHP = true;
          log.success('Phone number verified for recovered account');
          break;
        }
        if (vr.status_code === 429) {
          log.warning('Too many attempts - waiting 60 seconds...');
          await delay(60000);
          i--;
          continue;
        }
        log.error('Invalid SMS OTP - please try again or type /resend /cancel');
      }

      // snapshot apapun hasilnya
      await snapshotAndSave({ token: tokenOld, email: emailUse, phone: numberUse });

      // Jika sudah verified, re-login & cek flag
      if (verifiedHP) {
        loginResOld = await getLoginAccount(emailUse, existingAccRec.password, deviceId, ua, lang);
        if (loginResOld.status_code === 200) {
          tokenOld = loginResOld.token;
          // refresh bearer setelah re-login
          try { await upsertAccountJsonBearer_local(emailUse, tokenOld); } catch {}

          let mobileConfirmed = false;
          for (let i = 0; i < 10; i++) {
            infoOld = await getMemberInfo(tokenOld, ua, lang);
            if (infoOld.RESULTS?.ds_mbrList?.VERF_MOB_YN === '1') {
              mobileConfirmed = true;
              log.success('Phone status confirmed on backend for recovered account');
              break;
            }
            await delay(1000);
          }
          if (!mobileConfirmed) {
            log.warning('Backend has not confirmed phone status yet (recovered account) - continuing.');
          }
        }
      } else {
        log.error('Phone verification not completed for recovered account');
      }
    } else {
      log.success('Phone already verified for recovered account');
    }

    // 3. Update profile random (idempotent)
    const payloadOld = generateRandomProfile(numberUse, emailUse);
    const upOld = await updateProfile(tokenOld, payloadOld, ua, lang);
    if (upOld.status_code === 200) {
      log.success('Profile updated for recovered account');
    } else {
      log.error(`Failed to update profile for recovered account: ${upOld.message || upOld.status_code}`);
    }

    // 4. Snapshot final
    await snapshotAndSave({ token: tokenOld, email: emailUse, phone: numberUse });

    log.success('Recovered account processed successfully');
  }

  // NEW: EMAIL PREFIX dari ENV (acak salah satu) + DOT-TRICK (tanpa plus-tag)
  function getEnvEmailPrefixes() {
    const raw = (process.env.EMAIL_PREFIX || '').trim();
    if (!raw) return [];
    return raw.split(',').map(s => s.trim()).filter(Boolean);
  }
  function pickOne(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }
  // Sisipkan titik secara acak di antara karakter (bukan di awal/akhir), minimal 1 titik jika panjang > 1
  function dotifyLocalPart(prefix) {
    const clean = String(prefix || '')
      .toLowerCase()
      .replace(/\s+/g, '')
      .replace(/\./g, ''); // buang titik bawaan, kita random ulang
    const n = clean.length;
    if (n <= 1) return clean;           // tak ada ruang untuk titik
    const boundaries = Array.from({ length: n - 1 }, (_, i) => i + 1); // posisi di antara char
    // jumlah titik acak 1..floor(n/2) (menyesuaikan panjang username)
    const maxDots = Math.max(1, Math.floor(n / 2));
    const numDots = Math.floor(Math.random() * maxDots) + 1;

    // acak boundary dan ambil numDots unik
    for (let i = boundaries.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [boundaries[i], boundaries[j]] = [boundaries[j], boundaries[i]];
    }
    const picks = new Set(boundaries.slice(0, Math.min(numDots, boundaries.length)));
    // bangun hasil
    let out = '';
    for (let i = 0; i < n; i++) {
      out += clean[i];
      if (picks.has(i + 1)) out += '.';
    }
    return out;
  }
  function buildGmailFromPrefixDot(prefix) {
    const domain = (process.env.EMAIL_DOMAIN || 'gmail.com').trim();
    const local = dotifyLocalPart(prefix);
    return `${local}@${domain}`;
  }

  // nama aman (tanpa karakter spesial)
  const cgvSafeName = () => {
    for (let i = 0; i < 10; i++) {
      let name = `${faker.person.firstName()} ${faker.person.lastName()}`;
      name = name
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/[^A-Za-z ]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();

      let parts = name.split(' ').filter(Boolean);
      if (parts.length < 2) {
        parts = [faker.person.firstName(), faker.person.lastName()]
          .map(w => String(w).normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^A-Za-z]/g, ''));
        name = parts.join(' ').trim();
      }

      name = name
        .split(' ')
        .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
        .join(' ');

      if (name.length > 30) {
        let cut = name.slice(0, 30);
        const lastSpace = cut.lastIndexOf(' ');
        if (lastSpace >= 3) cut = cut.slice(0, lastSpace);
        name = cut.trim();
      }

      if (/^[A-Za-z ]+$/.test(name) && name.replace(/ /g, '').length >= 3) return name;
    }
    const pick = () => Array.from({length: 5 + Math.floor(Math.random()*4)}, () =>
      String.fromCharCode(65 + Math.floor(Math.random()*26))
    ).join('');
    return `${pick()} ${pick()}`;
  };

  // OTP prompts fleksibel
  async function promptEmailOtpFlexible() {
    const { otp } = await inquirer.prompt([{
      type: 'input',
      name: 'otp',
      message: 'Enter Email OTP (6 digits) or /resend or /cancel:',
      validate: v => (/^\d{6}$/.test(v) || /^\/resend$/i.test(v) || /^\/cancel$/i.test(v))
        ? true : 'Masukkan 6 digit, /resend, atau /cancel'
    }]);
    return otp.trim();
  }

  // UPDATED: promptSmsOtpFlexible sekarang support /ban
  async function promptSmsOtpFlexible() {
    const { otpSms } = await inquirer.prompt([{
      type: 'input',
      name: 'otpSms',
      message: 'Enter SMS OTP (6 digits) or /resend or /cancel or /ban:',
      validate: v =>
        (/^\d{6}$/.test(v)
          || /^\/resend$/i.test(v)
          || /^\/cancel$/i.test(v)
          || /^\/ban$/i.test(v)
        )
          ? true
          : 'Masukkan 6 digit, /resend, /cancel, atau /ban'
    }]);
    return otpSms.trim();
  }

  // normalisasi HP ke 08xxxxxxxxxx
  function normalizePhone(raw) {
    if (!raw) return '';
    let n = String(raw).replace(/\D/g, '');
    if (n.startsWith('62')) n = '0' + n.slice(2);
    else if (n.startsWith('8')) n = '0' + n;
    else if (!n.startsWith('0')) n = '0' + n;
    return n;
  }

  // baca list nomor dari file
  async function readPhoneList(filePath = 'nomor.txt') {
    try {
      const raw = await fs.readFile(filePath, 'utf-8');
      return raw.split('\n').map(s => s.trim()).filter(Boolean);
    } catch {
      return [];
    }
  }

  // YYYYMMDD -> YYYY-MM-DD
  const d8 = s => /^[0-9]{8}$/.test(s) ? `${s.slice(0,4)}-${s.slice(4,6)}-${s.slice(6)}` : '-';

  // umur akun (hari) dari YYYYMMDD
  const ageDaysFromD8 = (s) => {
    if (!/^\d{8}$/.test(s)) return null;
    const y = Number(s.slice(0,4)), m = Number(s.slice(4,6))-1, d = Number(s.slice(6,8));
    const start = new Date(y, m, d);
    const now   = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const diff  = Math.floor((today - start) / 86400000);
    return diff >= 0 ? diff : null;
  };

  // deteksi voucher ulang tahun dari arrays kupon/gift  (FIX: tanpa theGifts)
  function hasBirthdayVoucherFrom(info) {
    const coupons = info.RESULTS?.ds_CPN_LIST ?? [];
       const gifts   = info.RESULTS?.ds_GFT_LIST ?? [];
    const vouchers = [...coupons, ...gifts];
    return vouchers.some(v =>
      /birthday/i.test(v.DSC_NM || v.GFTCERT_NM || '') ||
      /birthday/i.test(v.ON_CUST_NOTY_CONT || '')
    );
  }

  // â†³ FORMAT & SIMPAN BARIS AKUN (baru)
  const formatAkunLine = (email, pass, phone, pin) =>
    `${String(email).padEnd(35)} | ${String(pass).padEnd(10)} | ${String(phone).padEnd(15)} | ${String(pin).padEnd(8)}\n`;

  async function appendLineUnique(file, line) {
    try {
      let dup = false;
      try {
        const raw = await fs.readFile(file, 'utf-8');
        const emailNew = line.split('|')[0].trim().toLowerCase();
        dup = raw.split('\n').some(row => {
          const r = row.trim();
          if (!r) return false;
          const emailOld = r.split('|')[0]?.trim().toLowerCase();
          return emailOld === emailNew;
        });
      } catch { /* file belum ada â†’ lanjut append */ }
      if (!dup) await fs.appendFile(file, line, 'utf-8');
    } catch (e) {
      console.log(chalk.red(`â†’ Gagal menulis ke ${file}: ${e.message}`));
    }
  }

  // buat snapshot JSON dari member info
  function buildAccountItem({ email, phone, fallbackName, fallbackBirthday }, info) {
    const m = info.RESULTS?.ds_mbrList || {};
    const joinDate = d8(m.SITE_JOIN_DY);
    const ageDays  = ageDaysFromD8(m.SITE_JOIN_DY);
    const genderName = m.SEC_CD === '01' ? 'Male'
                     : m.SEC_CD === '02' ? 'Female'
                     : '-';
    return {
      login_ok: true,
      email,
      name: m.MBR_NM || fallbackName || '-',
      gender: genderName,
      tier: m.MBR_TIER_NM || 'NEW',
      points: m.MILEAGE_AMT ?? 0,
      phone: m.MOBILE_NO || phone || '-',
      city: m.ADDR_REGION_NM || '-',            // hanya nama kota
      join_date: joinDate,
      age_days: ageDays === null ? 0 : ageDays,
      birthday: d8(m.BIRTHDAY) || fallbackBirthday || '-',
      verified_phone: m.VERF_MOB_YN === '1',
      visits: m.TOT_VISIT_FOR_UI ?? 0,
      fav_theater: m.JOIN_THAT_NM || '-',
      has_birthday_voucher: hasBirthdayVoucherFrom(info)
    };
  }

  // upsert ke account.json (by email/phone), re-number "no"
  async function upsertAccountJson(item) {
    let data = { generated_at: new Date().toISOString(), total_accounts: 0, checked: 0, items: [] };
    try {
      const raw = await fs.readFile('account.json', 'utf-8');
      data = JSON.parse(raw);
      if (!Array.isArray(data.items)) data.items = [];
    } catch {}

    const idx = data.items.findIndex(x =>
      (x.email && x.email === item.email) || (item.phone && x.phone === item.phone)
    );

    if (idx >= 0) {
      const existingNo = data.items[idx].no;
      data.items[idx] = { ...data.items[idx], ...item, no: existingNo };
    } else {
      data.items.push({ no: data.items.length + 1, ...item, created_at: new Date().toISOString() });
    }

    // resequence no agar rapi (1..N)
    data.items = data.items.map((x, i) => ({ ...x, no: i + 1 }));
    data.total_accounts = data.items.length;
    data.checked = data.items.length;
    data.generated_at = new Date().toISOString();

    await fs.writeFile('account.json', JSON.stringify(data, null, 2), 'utf-8');
  }

  // ambil & simpan snapshot dari token
  async function snapshotAndSave({ token, email, phone, fallbackName, fallbackBirthday }) {
    const info = await getMemberInfo(token, ua, lang);
    const item = buildAccountItem({ email, phone, fallbackName, fallbackBirthday }, info);
    await upsertAccountJson(item);
    console.log(chalk.green(`[âœ“] Saved/updated ${email} in account.json`));
  }

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FIX: editor & watcher nomor.txt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let NOMOR_FILE = 'nomor.txt';

async function ensureNomorFileExists() {
  try { await fs.access(NOMOR_FILE); }
  catch { await fs.writeFile(NOMOR_FILE, '', 'utf-8'); }
}

async function openNomorFileInEditor() {
  try {
    const { spawn } = await import('child_process');
    const plat = process.platform;
    if (plat === 'win32') {
      spawn('cmd', ['/c', 'start', '""', NOMOR_FILE], { detached: true, stdio: 'ignore' });
    } else if (plat === 'darwin') {
      spawn('open', [NOMOR_FILE], { detached: true, stdio: 'ignore' });
    } else {
      const p = spawn('xdg-open', [NOMOR_FILE], { detached: true, stdio: 'ignore' });
      p.on('error', () => spawn('nano', [NOMOR_FILE], { stdio: 'inherit' }));
    }
  } catch {
    try {
      const { spawn } = await import('child_process');
      if (process.platform === 'win32') spawn('notepad', [NOMOR_FILE], { stdio: 'inherit' });
      else spawn('nano', [NOMOR_FILE], { stdio: 'inherit' });
    } catch {}
  }
}

async function waitForNumbersFilled(minCount = 1) {
  log.warning(`File ${NOMOR_FILE} is empty`);
  console.log(chalk.gray('ğŸ“ Opening file editor - add phone numbers (one per line) and save (Ctrl+S)'));
  await openNomorFileInEditor();

  const fsRaw = await import('fs');
  let watcher = null;
  let poll = null;
  let resolved = false;

  const readNow = async () => {
    try {
      const nums = await readPhoneList(NOMOR_FILE);
      return (nums.length >= minCount) ? nums : null;
    } catch { return null; }
  };

  const first = await readNow();
  if (first) return first;

  return await new Promise((resolve) => {
    const tryResolve = async (from) => {
      if (resolved) return;
      const nums = await readNow();
      if (nums) {
        resolved = true;
        try { watcher && watcher.close(); } catch {}
        if (poll) clearInterval(poll);
        resolve(nums);
      }
    };

    try {
      watcher = fsRaw.watch(NOMOR_FILE, async (eventType) => {
        if (eventType === 'change' || eventType === 'rename') {
          await tryResolve(`fs.watch:${eventType}`);
        }
      });
    } catch {}

    // Safety net: polling tiap 1 detik
    poll = setInterval(() => { tryResolve('poll'); }, 1000);
  });
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI awal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  log.header('ğŸ¬ CGV ACCOUNT CREATOR', 'Automated Account Registration System');

  const jumlahCreate = await inputJumlahCreate();
  log.info(`Target accounts to create: ${chalk.white.bold(jumlahCreate)}`);

// NEW: tanya offset birthdate (default 33; <30 minta konfirmasi)
const birthdateOffsetDays = await promptBirthdateOffsetDays();
log.info(`Birthdate offset: ${chalk.white.bold(birthdateOffsetDays)} days`);

// [ADD] Tanya SEKALI: random birthday offset mode (sesi) â€” bucket ikut prior basis
const bdayCfg = await promptBirthdayOffsetConfigOnce(birthdateOffsetDays);
log.info(`[bday] session mode=${bdayCfg.mode} bucket=${bdayCfg.bucketMin}-${bdayCfg.bucketMax} (fallback=${bdayCfg.fallback})`);

// === [REPLACE] Password mode (default vs human-ish random) ============
const sessionPwdMode = await promptPasswordMode();
log.info(`Password mode: ${chalk.white.bold(sessionPwdMode === 'random' ? 'Random human-ish (per account)' : 'Default (SET_PASSWORD)')}`);

// gunakan generator human-ish saat random
const pickPasswordForNewAccount = () =>
  (sessionPwdMode === 'random' ? generateHumanishPassword() : SET_PASSWORD);
// =====================================================================


  // â”€â”€ PILIH SUMBER NOMOR SEKALI DI AWAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const { phoneSource } = await inquirer.prompt([{
    type: 'list',
    name: 'phoneSource',
    message: 'ğŸ“± Choose phone number source:',
    choices: [
      { name: 'âŒ¨ï¸  Manual input (enter numbers manually)', value: 'Manual input' },
      { name: 'ğŸ“„ From file (nomor.txt)', value: 'Dari file nomor.txt' }
    ]
  }]);

  // Jika dari file: tanya nama file (default nomor.txt)
  if (phoneSource === 'Dari file nomor.txt') {
    NOMOR_FILE = await promptNomorFilename(); // â† bisa selain "nomor.txt"
  }

  // untuk file: peek per akun; shift hanya saat sukses
  let numberList = [];
  if (phoneSource === 'Dari file nomor.txt') {
    await ensureNomorFileExists();
    numberList = await readPhoneList(NOMOR_FILE);
    if (!numberList.length) {
      numberList = await waitForNumbersFilled(1);
    }
    log.success(`Loaded ${numberList.length} phone numbers from "${NOMOR_FILE}"`);
  }

  // >>> Pegang nomor manual sampai 1 akun selesai / direset
  let currentManualNumber = null;

  let successCount = 0;

  // NEW: siapkan sumber email untuk mode gmail
  const envPrefixes = getEnvEmailPrefixes();
  let gmailAliases = [];
  // HANYA baca alias file jika ENV kosong (mencegah stuck)
  if (mode === 'gmail' && envPrefixes.length === 0) {
    gmailAliases = await readGmailAliasList();
  }

  // [ADD] siapkan sumber email untuk mode email.txt (dengan auto-monitor jika kosong)
  let emailTxtList = [];
  let successEmailSet = new Set();
  if (mode === 'emailtxt') {
    EMAIL_FILE = 'email.txt';
    await ensureEmailFileExists();

    const loaded = await loadSuccessEmails();
    successEmailSet = loaded.set;

    emailTxtList = await readPendingEmails(successEmailSet);
    if (!emailTxtList.length) {
      // auto open & wait sampai ada isian (Ctrl+S)
      emailTxtList = await waitForEmailsFilled(1, successEmailSet);
    }
    log.success(`Loaded ${emailTxtList.length} pending emails from ${EMAIL_FILE} (skipping sukses_email.json)`);
  }

  log.section('Starting Account Creation Process');

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ loop utama â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
while (successCount < jumlahCreate) {
  const currentAccount = successCount + 1;

  // âœ… identitas perangkat & browser: UNIK utk akun ini, KONSISTEN sampai akun selesai
  deviceId = generateDeviceId();
  ua       = getRandomUA();
  lang     = getRandomLang();

  // (opsional) debug fingerprint tiap akun
  // console.log(chalk.gray(`[fp] UA=${ua}`));
  // console.log(chalk.gray(`[fp] deviceId=${deviceId}`));

  console.log(chalk.cyan('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
  console.log(chalk.cyan('â”‚') + chalk.white.bold(`                PROCESSING ACCOUNT ${currentAccount}/${jumlahCreate}               `) + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
  console.log(chalk.cyan('â”‚') + ` ğŸ¯ Progress  : ${String(currentAccount).padStart(2)}/${jumlahCreate} (${Math.round((successCount/jumlahCreate)*100)}% complete)`.slice(0,56).padEnd(56) + ' ' + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + ` âœ… Success   : ${String(successCount).padEnd(40)} ` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â”‚') + ` ğŸŒ IP        : ${(await getCurrentOutboundIP() || 'Unknown').padEnd(40)} ` + chalk.cyan('â”‚'));
  console.log(chalk.cyan('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));


    // â”€â”€ 0. nomor untuk akun ini
    let numberUse;
    let picked;

    if (phoneSource === 'Manual input') {
      if (!currentManualNumber) {
        const defaultNum = generatePhoneNumber();
        const rawNumber = await inputPhoneNumber(defaultNum);
        currentManualNumber = normalizePhone(rawNumber);
      }
      numberUse = currentManualNumber;
      console.log(chalk.green('â”‚') + ` ğŸ“± Phone    : ${maskPhone(numberUse).padEnd(40)} ` + chalk.green('â”‚'));
    } else {
      // FILE MODE â€” kalau habis, buka editor & tunggu diisi
      if (!numberList.length) {
        log.error('Phone numbers in file exhausted');
        numberList = await waitForNumbersFilled(1);
        log.success(`Reloaded ${numberList.length} phone numbers from file`);
      }
      picked = numberList[0]; // peek; shift hanya saat sukses atau keputusan konsumsi
      numberUse = normalizePhone(picked);
      console.log(chalk.green('â”‚') + ` ğŸ“± Phone    : ${maskPhone(numberUse).padEnd(40)} ` + chalk.green('â”‚'));
    }

    // [ADD] reload email.txt bila habis di tengah proses
    if (mode === 'emailtxt' && emailTxtList.length === 0 && successCount < jumlahCreate) {
      log.warning('Emails exhausted â€” opening email.txt, add more lines then Ctrl+S to continueâ€¦');
      emailTxtList = await waitForEmailsFilled(1, successEmailSet);
    }

    // â”€â”€ PRE-CHECK: kalau nomor sudah ada di akunLogin.txt â†’ proses akun lama (skip OTP email)
    const existingAcc = await (async () => {
      try {
        const raw = await fs.readFile('akunLogin.txt', 'utf-8');
        for (const line of raw.split('\n')) {
          const row = line.trim();
          if (!row) continue;
          const [emailRaw, passwordRaw, phoneRaw, pinRaw] = row.split('|').map(s => s?.trim());
          if (phoneRaw === numberUse) {
            return { email: emailRaw, password: passwordRaw, phone: phoneRaw, pin: pinRaw };
          }
        }
      } catch {}
      return null;
    })();

    if (existingAcc) {
      console.log(chalk.yellow('\nğŸ“‹ EXISTING ACCOUNT DETECTED'));
      console.log(chalk.cyan('â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
      console.log(chalk.cyan('â”‚') + chalk.white.bold('                   PROCESSING EXISTING ACCOUNT              ') + chalk.cyan('â”‚'));
      console.log(chalk.cyan('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
      console.log(chalk.cyan('â”‚') + ` ğŸ“§ Email     : ${existingAcc.email.slice(0,40).padEnd(40)} ` + chalk.cyan('â”‚'));
      console.log(chalk.cyan('â”‚') + ` ğŸ“± Phone     : ${maskPhone(existingAcc.phone).padEnd(40)} ` + chalk.cyan('â”‚'));
      console.log(chalk.cyan('â”‚') + ` ğŸ”„ Action    : Login & verify (skip email OTP)`.padEnd(56) + ' ' + chalk.cyan('â”‚'));
      console.log(chalk.cyan('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));

      // NEW: simpan/update password ke account.json untuk akun existing
      try { await upsertAccountJsonPassword_local(existingAcc.email, existingAcc.password); } catch {}

      // Login akun lama
      let loginResOld = await getLoginAccount(existingAcc.email, existingAcc.password, deviceId, ua, lang);
      if (loginResOld.status_code !== 200) {
        log.error(`Login failed for existing account: ${loginResOld.message || loginResOld.status_code}`);
        // file: buang nomor; manual: reset agar minta nomor baru
        if (phoneSource === 'Dari file nomor.txt') {
          numberList.shift();
          await fs.writeFile(NOMOR_FILE, numberList.join('\n'), 'utf-8');
        } else {
          currentManualNumber = null;
        }
        continue;
      }
      let tokenOld = loginResOld.token;

      // simpan/refresh bearer setelah login existing
      try { await upsertAccountJsonBearer_local(existingAcc.email, tokenOld); } catch {}

      // Cek status verifikasi HP
      let infoOld = await getMemberInfo(tokenOld, ua, lang);
      let verifiedHP = infoOld.RESULTS?.ds_mbrList?.VERF_MOB_YN === '1';
      if (!verifiedHP) {
        // Kirim OTP SMS + resend loop jika gagal
        while (true) {
          const req = await sendPhoneOtp(tokenOld, existingAcc.phone, ua, lang);
          if (req.status_code === 200) {
            log.success('SMS OTP sent for existing account verification');
            break;
          }
          log.error(`Failed to send SMS OTP: ${req.message || req.status_code}`);
          const { action } = await inquirer.prompt([{
            type: 'input',
            name: 'action',
            message: 'ğŸ”„ Type /resend to try again or /cancel:',
            validate: v => /^\/resend$|^\/cancel$/i.test(v) ? true : 'Type /resend or /cancel'
          }]);
          if (/^\/cancel$/i.test(action)) {
            await snapshotAndSave({ token: tokenOld, email: existingAcc.email, phone: existingAcc.phone });
            // file: shift; manual: reset
            if (phoneSource === 'Dari file nomor.txt') {
              numberList.shift();
              await fs.writeFile(NOMOR_FILE, numberList.join('\n'), 'utf-8');
            } else {
              currentManualNumber = null;
            }
            continue; // ke akun berikutnya
          }
          if (req.status_code === 429) {
            log.warning('Rate limited - waiting 60 seconds...');
            await delay(60000);
          } else {
            await delay(1500);
          }
        }

        // loop verifikasi fleksibel
        let cancelled = false;
        for (let i = 0; i < 15 && !verifiedHP && !cancelled; i++) {
          const code = await promptSmsOtpFlexible();

          if (/^\/cancel$/i.test(code)) {
            log.warning('Verification cancelled by user');
            cancelled = true;
            break;
          }
          if (/^\/resend$/i.test(code)) {
            const rr = await sendPhoneOtp(tokenOld, existingAcc.phone, ua, lang);
            if (rr.status_code === 429) {
              log.warning('Rate limited - waiting 60 seconds...');
              await delay(60000);
            } else if (rr.status_code === 200) {
              log.success('New SMS OTP sent successfully');
            } else {
              log.error(`Failed to resend SMS OTP: ${rr.message || rr.status_code}`);
            }
            i--; // tidak dihitung attempt verifikasi
            continue;
          }

          // NOTE: /ban di sini tidak digunakan untuk "existing account path"

          const vr = await verifyPhoneOtp(tokenOld, existingAcc.phone, code, ua, lang);
          if (vr.status_code === 200) {
            verifiedHP = true;
            log.success('Phone number verified for existing account');
            break;
          }
          if (vr.status_code === 429) {
            log.warning('Too many attempts - waiting 60 seconds...');
            await delay(60000);
            i--; // jangan hitung
            continue;
          }
          log.error('Invalid SMS OTP - please try again or type /resend /cancel');
        }

        // snapshot & simpan apa pun hasilnya
        await snapshotAndSave({ token: tokenOld, email: existingAcc.email, phone: existingAcc.phone });

        if (!verifiedHP) {
          log.error('Phone verification failed for existing account - skipping');
          if (phoneSource === 'Dari file nomor.txt') {
            numberList.shift();
            await fs.writeFile(NOMOR_FILE, numberList.join('\n'), 'utf-8');
          } else {
            currentManualNumber = null;
          }
          continue;
        }

        // Re-login & confirm flag backend
        loginResOld = await getLoginAccount(existingAcc.email, existingAcc.password, deviceId, ua, lang);
        if (loginResOld.status_code !== 200) {
          log.error('Re-login failed after verification for existing account');
          if (phoneSource === 'Dari file nomor.txt') {
            numberList.shift();
            await fs.writeFile(NOMOR_FILE, numberList.join('\n'), 'utf-8');
          } else {
            currentManualNumber = null;
          }
          continue;
        }
        tokenOld = loginResOld.token;

        // refresh bearer setelah re-login existing
        try { await upsertAccountJsonBearer_local(existingAcc.email, tokenOld); } catch {}

        let mobileConfirmed = false;
        for (let i = 0; i < 10; i++) {
          infoOld = await getMemberInfo(tokenOld, ua, lang);
          if (infoOld.RESULTS?.ds_mbrList?.VERF_MOB_YN === '1') {
            mobileConfirmed = true;
            log.success('Phone status confirmed on backend for existing account');
            break;
          }
          await delay(1000);
        }
        if (!mobileConfirmed) {
          log.warning('Backend has not confirmed phone status yet - continuing with snapshot');
        }
      } else {
        log.success('Phone already verified for existing account');
      }

      // Update profile (idempotent)
      const payloadOld = generateRandomProfile(existingAcc.phone, existingAcc.email);
      const upOld = await updateProfile(tokenOld, payloadOld, ua, lang);
      if (upOld.status_code === 200) {
        log.success('Profile updated for existing account');
      } else {
        log.error(`Failed to update profile for existing account: ${upOld.message || upOld.status_code}`);
      }

      // Snapshot terbaru setelah update profile
      await snapshotAndSave({ token: tokenOld, email: existingAcc.email, phone: existingAcc.phone });

      // konsumsi nomor kalau sumber file; kalau manual: reset agar minta nomor baru
      if (phoneSource === 'Dari file nomor.txt') {
        numberList.shift();
        await fs.writeFile(NOMOR_FILE, numberList.join('\n'), 'utf-8');
      } else {
        currentManualNumber = null;
      }
      
      log.success(`Existing account processed successfully`);
      continue; // ke iterasi berikutnya (tanpa registrasi)
    }

    // === [ADD] Tentukan password untuk akun ini ==========================
    // Mengambil dari helper prompt "Random password?" (jika ada).
    // Kalau helper belum ditambahkan, fallback ke SET_PASSWORD agar aman.
    const passwordUse = (typeof pickPasswordForNewAccount === 'function')
      ? pickPasswordForNewAccount()
      : SET_PASSWORD;
    // =====================================================================

    // â”€â”€ 1. Pilih email (untuk akun BARU)
    log.step(1, 8, 'Generating / picking email address');
    let emailUse;

    if (mode === 'emailtxt') {
      // Ambil dari email.txt (skip yang sudah sukses)
      while (emailTxtList.length && !emailUse) {
        const cand = String(emailTxtList.shift()).trim();
        if (!cand) continue;
        const norm = cand.includes('@') ? cand : `${cand}@gmail.com`;
        if (!successEmailSet.has(norm.toLowerCase())) {
          emailUse = norm;
        }
      }
      if (!emailUse) {
        // kosong lagi â†’ minta user isi (editor auto kebuka, lanjut setelah Ctrl+S)
        emailTxtList = await waitForEmailsFilled(1, successEmailSet);
        if (!emailTxtList.length) {
          log.error('No more emails available in email.txt (all done or already successful).');
          break;
        }
        const cand = String(emailTxtList.shift()).trim();
        emailUse = (cand.includes('@') ? cand : `${cand}@gmail.com`).toLowerCase();
      }
      console.log(chalk.blue('â”‚') + ` ğŸ“§ Email    : ${emailUse.padEnd(40)} ` + chalk.blue('â”‚'));
    } else if (mode === 'auto') {
      // gunakan passwordUse untuk akun temp-mail
      emailUse = await mailTm.createTempAccount(passwordUse);
      console.log(chalk.blue('â”‚') + ` ğŸ“§ Email    : ${emailUse.padEnd(40)} ` + chalk.blue('â”‚'));
    } else {
      // mode === 'gmail' : Gunakan EMAIL_PREFIX ENV kalau ada; jika tidak, fallback ke alias list
      if (envPrefixes.length) {
        const pickedPrefix = pickOne(envPrefixes);
        emailUse = buildGmailFromPrefixDot(pickedPrefix);
      } else {
        if (!gmailAliases.length) {
          log.error('Gmail aliases exhausted - all have been used');
          break;
        }
        emailUse = gmailAliases.shift();
      }
      console.log(chalk.blue('â”‚') + ` ğŸ“§ Email    : ${emailUse.padEnd(40)} ` + chalk.blue('â”‚'));
    }

// â”€â”€ 2. Send OTP email (auto-retry utk 429/ECONNRESET; 422â‡¢login ulang jika ada di account.json)
console.log(chalk.yellow('\nâš¡ Step 2/8: Sending email OTP...'));

let otpSent = false;
let recoveredProcessed = false; // <- kalau true berarti kita udah proses akun lama & harus lanjut next loop

for (let attempt = 1; attempt <= 50; attempt++) {
  const r = await getSendOtpEmail(emailUse, ua, lang);

  if (r && r.status_code === 200) {
    console.log(chalk.green('âœ… Email OTP sent successfully'));
    otpSent = true;
    break;
  }

  // CASE: email sudah registered di CGV
  if (
    r &&
    r.status_code === 422 &&
    /already\s+registered/i.test(String(r.message || ''))
  ) {
    console.log(chalk.yellow('âš ï¸  Email already registered by CGV'));

    // cek di account.json: hanya kalau ada dan punya password â†’ kita login ulang
    const localAcc = await findLocalAccountByEmail(emailUse);

    if (localAcc && localAcc.password) {
      console.log(chalk.green('âœ… Found matching entry in account.json, will RE-USE this account (login instead of creating new).'));

      // jalankan flow recovered account re-login + verifikasi nomorUse
      await processRecoveredAccountFlow(localAcc, emailUse, numberUse);

      // konsumsi nomor setelah proses recovery
      if (phoneSource === 'Dari file nomor.txt') {
        numberList.shift();
        await fs.writeFile(NOMOR_FILE, numberList.join('\n'), 'utf-8');
      } else {
        currentManualNumber = null;
      }

      recoveredProcessed = true;
    } else {
      console.log(chalk.red('âŒ Email is registered BUT no usable record in local account.json â†’ skip this email.'));
      try { await saveSuccessEmail(emailUse); } catch {}
    }

    break; // keluar dari attempt loop
  }

  // 429: rate limited â†’ tunggu sesuai retry-after atau default 60s
  if (r && r.status_code === 429) {
    const wait = Math.max(Number(r.retry_after_ms || 0), 60000);
    console.log(chalk.yellow(`â³ Rate limited - waiting ${Math.round(wait/1000)}s...`));
    await delay(wait);
    continue;
  }

  // Network/transient: ECONNRESET/timeouts/5xx â†’ backoff linear + jitter
  const msg = String(r?.message || r?.status_code || 'unknown');
  const transient = (r?.status_code >= 500) || /ECONNRESET|timeout|network/i.test(msg);
  const wait = transient ? Math.min(2000 * attempt + Math.floor(Math.random()*800), 15000) : 2000;

  console.log(chalk.yellow(`ğŸ”„ Email OTP attempt ${attempt} failed. Retrying in ${Math.round(wait/1000)}s...`));
  await delay(wait);
}

// jika kita sudah proses recovered account (login ulang akun lama), langsung lanjut ke akun berikutnya
if (recoveredProcessed) {
  continue;
}

// kalau belum terkirim OTP dan bukan recovered â†’ ambil email berikut (lanjut loop utama)
if (!otpSent) {
  console.log(chalk.red('âŒ Failed to send email OTP (or email skipped) - trying next account'));
  continue;
}


    // â”€â”€ 3. Ambil / input OTP
    console.log(chalk.yellow('\nâš¡ Step 3/8: Verifying email OTP...'));
    let kodeOtp = null;
    let verifiedEmail = false;

    if (mode === 'auto') {
      // temp-mail â€” pakai passwordUse saat ambil token
      const tmToken = await mailTm.getToken(emailUse, passwordUse);
      for (let i = 0; i < 10; i++) {
        await delay(2000);
        kodeOtp = await mailTm.fetchLatestOtp(tmToken);
        if (kodeOtp) break;
      }
      if (!kodeOtp) {
        log.error('Email OTP not received from temp-mail service');
        continue;
      }
      console.log(chalk.green(`âœ… Retrieved OTP: ${kodeOtp}`));

      const vOtp = await getVerifyOtpEmail(emailUse, kodeOtp, ua, lang);
      if (vOtp.status_code === 200) {
        verifiedEmail = true;
        console.log(chalk.green('âœ… Email OTP verified successfully'));
      } else {
        console.log(chalk.red(`âŒ Email OTP verification failed: ${vOtp.message || vOtp.status_code}`));
        continue;
      }
    } else {
      // manual (Gmail/email.txt) â€” pakai /resend /cancel
      let attempts = 0;
      while (attempts < 10 && !verifiedEmail) {
        const inp = await promptEmailOtpFlexible();
        if (/^\/cancel$/i.test(inp)) {
          log.warning('Email verification cancelled by user');
          break;
        }
        if (/^\/resend$/i.test(inp)) {
          const r = await getSendOtpEmail(emailUse, ua, lang);
          if (r.status_code === 200) {
            log.success('New email OTP sent successfully');
          } else {
            log.error(`Failed to resend email OTP: ${r.message || r.status_code}`);
          }
          continue;
        }

        kodeOtp = inp;
        log.success(`Got OTP: ${chalk.white.bold(kodeOtp)}`);
        const vOtp = await getVerifyOtpEmail(emailUse, kodeOtp, ua, lang);

        if (vOtp.status_code === 200) {
          verifiedEmail = true;
          log.success('Email OTP verified successfully');
        } else {
          attempts++;
          log.error(`Invalid/expired OTP (attempt ${attempts}/10) - try again, /resend, or /cancel`);
        }
      }
      if (!verifiedEmail) continue;
    }

    // â”€â”€ 4. Register akun baru
    console.log(chalk.yellow('\nâš¡ Step 4/8: Creating new account...'));

    // [CHANGE] Offset per akun: pakai config sesi (acak dalam bucket jika aktif, atau fallback 30)
    const bdayOffsetThis = (bdayCfg.mode === 'active')
      ? randIntBucket(bdayCfg.bucketMin, bdayCfg.bucketMax)
      : bdayCfg.fallback;
    const birthdateUse = generateRandomBirthdate(bdayOffsetThis);

    let randomName   = cgvSafeName();
    const randomGender = faker.person.sex() === 'male' ? '01' : '02';

    // ambil ID cinema acak dari API (sekali per akun)
    const prefCinemaId = await pickRandomCinemaId(ua, lang);

    console.log(chalk.blue('â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
    console.log(chalk.blue('â”‚') + chalk.white.bold('                    ACCOUNT GENERATION                     ') + chalk.blue('â”‚'));
    console.log(chalk.blue('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.blue('â”‚') + ` ğŸ‘¤ Name      : ${randomName.slice(0,40).padEnd(40)} ` + chalk.blue('â”‚'));
    console.log(chalk.blue('â”‚') + ` ğŸ‚ Birthday  : ${bdayOffsetThis} days from today`.padEnd(56) + ' ' + chalk.blue('â”‚'));
    console.log(chalk.blue('â”‚') + ` âš§ Gender    : ${(randomGender === '01' ? 'Male' : 'Female').padEnd(40)} ` + chalk.blue('â”‚'));
    console.log(chalk.blue('â”‚') + ` ğŸ¢ Cinema    : ${describeCinema(prefCinemaId).slice(0,40).padEnd(40)} ` + chalk.blue('â”‚'));
    console.log(chalk.blue('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));

    // Auto-retry untuk gangguan jaringan/5xx/429/timeout tanpa mengubah struktur alur
    const MAX_REG_ATTEMPTS   = Number(process.env.REG_MAX_ATTEMPTS || 6);
    const REG_BASE_DELAY_MS  = Number(process.env.REG_BASE_DELAY_MS || 1200);
    let reg;
    for (let attempt = 1; attempt <= MAX_REG_ATTEMPTS; attempt++) {
      reg = await getRegisterAccount(
        emailUse, kodeOtp, randomName, numberUse,
        birthdateUse, passwordUse, SET_PIN,
        ua, lang, randomGender,
        prefCinemaId
      );

      if (reg?.status_code === 200) break;

      const msg = String(reg?.message || '').toLowerCase();
      // kasus nama â€œspecial charâ€ â†’ regenerasi nama lalu coba lagi cepat
      if (/name/.test(msg) && /special|invalid/.test(msg)) {
        randomName = cgvSafeName();
        log.warning(`Retrying registration with safe name: ${randomName}`);
        await delay(200);
        continue;
      }
      // hard-fail (OTP invalid/expired, already used, atau 4xx non-429) â†’ hentikan retry
      const sc = Number(reg?.status_code || 0);
      const hardFail =
        ((/otp/.test(msg) && (/invalid|expired/.test(msg))) ||
         /already.*in\s*use/.test(msg) ||
         (sc && sc < 500 && sc !== 429));
      if (hardFail) break;

      // transient (network/timeout/5xx/429/â€œrequest ... failed, reason:â€) â†’ backoff & retry
      const transient =
        sc >= 500 || sc === 429 ||
        /failed,\s*reason|network|timeout|econnreset|eai_again|etimedout/.test(msg);
      if (!transient) break;

      const wait = Math.min(REG_BASE_DELAY_MS * attempt + Math.floor(Math.random() * 800), 5000);
      console.log(chalk.yellow(`ğŸ”„ Register attempt ${attempt}/${MAX_REG_ATTEMPTS} failed. Retrying in ${Math.round(wait/1000)}s...`));
      await delay(wait);
    }

    if (reg?.status_code !== 200) {
      log.error(`Account registration failed: ${reg?.message || reg?.status_code || 'unknown'}`);
      if (/already in use/i.test(reg.message || '')) {
        log.warning('Phone number already in use but not recorded in akunLogin.txt - skipping');
        if (phoneSource === 'Dari file nomor.txt') {
          numberList.shift();
          await fs.writeFile(NOMOR_FILE, numberList.join('\n'), 'utf-8');
        } else {
          // manual: reset agar bisa input nomor lain pada iterasi berikutnya
          currentManualNumber = null;
        }
      }
      continue;
    }

    // Jika API register memberi token, simpan sekarang juga
    if (reg.token) {
      try { await upsertAccountJsonBearer_local(emailUse, reg.token); } catch {}
    }

    // NEW: upsert password saat register sukses
    try { await upsertAccountJsonPassword_local(emailUse, passwordUse); } catch {}

    // â”€â”€ 4.1 SIMPAN KE FILE (akunLogin.txt & data.txt)
    const line = formatAkunLine(emailUse, passwordUse, numberUse, SET_PIN); // â† passwordUse
    await appendLineUnique('akunLogin.txt', line);
    await appendLineUnique('data.txt', line);

    // [ADD] catat email sukses â†’ sukses_email.json (untuk skip sesi berikutnya)
    if (mode === 'emailtxt') {
      try { 
        await saveSuccessEmail(emailUse);
        successEmailSet.add(String(emailUse).toLowerCase());
      } catch {}
    }

    successCount++;
    
    console.log(chalk.green('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
    console.log(chalk.green('â”‚') + chalk.white.bold('                 ACCOUNT CREATED SUCCESSFULLY               ') + chalk.green('â”‚'));
    console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
    console.log(chalk.green('â”‚') + ` ğŸ¯ Progress  : ${successCount}/${jumlahCreate} (${Math.round((successCount/jumlahCreate)*100)}%)`.slice(0,56).padEnd(56) + ' ' + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ“§ Email     : ${emailUse.slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ“± Phone     : ${maskPhone(numberUse).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â”‚') + ` ğŸ” Password  : ${passwordUse.slice(0,40).padEnd(40)} ` + chalk.green('â”‚'));
    console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));

    // selesai 1 akun manual â†’ reset agar minta nomor baru untuk akun berikutnya
    if (phoneSource === 'Dari file nomor.txt') {
      numberList.shift();
      await fs.writeFile(NOMOR_FILE, numberList.join('\n'), 'utf-8');
    } else {
      currentManualNumber = null;
    }

// â”€â”€ 5. Login untuk dapat token & kirim SMS OTP (retry/backoff + hard deadline)
console.log(chalk.yellow('\nâš¡ Step 5/8: Logging into new account...'));

let loginRes;
let token;
{
  const startedAt = Date.now(); // hard deadline per langkah
  for (let attempt = 1; attempt <= LOGIN_MAX_ATTEMPTS; attempt++) {
    if (Date.now() - startedAt > STEP_HARD_DEADLINE_MS) {
      console.log(chalk.red(`âŒ Login exceeded deadline (${Math.round(STEP_HARD_DEADLINE_MS/1000)}s)`));
      break;
    }

    loginRes = await getLoginAccount(emailUse, passwordUse, deviceId, ua, lang);

    if (loginRes && loginRes.status_code === 200 && loginRes.token) {
      token = loginRes.token;
      if (attempt > 1) console.log(chalk.green(`âœ… Login successful on attempt ${attempt}/${LOGIN_MAX_ATTEMPTS}`));
      break;
    }

    const base   = LOGIN_BASE_DELAY_MS * attempt;            // backoff linear
    const jitter = Math.floor(Math.random() * 800);          // jitter 0â€“800ms
    const wait   = Math.min(base + jitter, LOGIN_MAX_DELAY_MS);

    const reason = loginRes?.message || loginRes?.status_code || 'unknown';
    console.log(chalk.yellow(`ğŸ”„ Login attempt ${attempt}/${LOGIN_MAX_ATTEMPTS} failed. Retrying in ${Math.round(wait/1000)}s...`));
    await delay(wait);
  }
}

if (!token) {
  console.log(chalk.red('âŒ Login failed - saving account data and continuing'));
  try {
    await snapshotAndSave({
      token: loginRes?.token,
      email: emailUse,
      phone: numberUse,
      fallbackName: randomName,
      fallbackBirthday: birthdateUse
    });
  } catch {}
  continue; // lanjut ke akun berikutnya
}

// simpan bearer setelah login pertama (kalau belum ada dari register)
try { await upsertAccountJsonBearer_local(emailUse, token); } catch {}


    // Kirim SMS OTP dengan loop resend/cancel jika gagal
    console.log(chalk.yellow('\nâš¡ Step 6/8: Sending SMS OTP for phone verification...'));
    // Auto-resend untuk error sementara (network/timeout/5xx/429); tetap skip bila gagal total
    const MAX_SMS_SEND_ATTEMPTS = Number(process.env.SMS_SEND_MAX_ATTEMPTS || 5);
    const SMS_BASE_DELAY_MS     = Number(process.env.SMS_BASE_DELAY_MS || 1500);
    let skipVerify = false;
    {
      let sent = false;
      for (let attempt = 1; attempt <= MAX_SMS_SEND_ATTEMPTS; attempt++) {
        const smsReq = await sendPhoneOtp(token, numberUse, ua, lang);
        if (smsReq?.status_code === 200) {
          console.log(chalk.green('âœ… SMS OTP sent successfully'));
          sent = true;
          break;
        }
        const sc  = Number(smsReq?.status_code || 0);
        const msg = String(smsReq?.message || '').toLowerCase();
        const transient =
          sc >= 500 || sc === 429 ||
          /failed,\s*reason|network|timeout|econnreset|eai_again|etimedout/.test(msg);
        if (!transient) {
          console.log(chalk.red(`âŒ SMS OTP failed: ${smsReq?.message || smsReq?.status_code || 'unknown'}`));
          break;
        }
        const wait = Math.min(SMS_BASE_DELAY_MS * attempt + Math.floor(Math.random() * 800), 8000);
        console.log(chalk.yellow(`ğŸ”„ SMS send failed (attempt ${attempt}/${MAX_SMS_SEND_ATTEMPTS}). Retrying in ${Math.round(wait/1000)}s...`));
        await delay(wait);
      }
      if (!sent) {
        await snapshotAndSave({ token, email: emailUse, phone: numberUse, fallbackName: randomName, fallbackBirthday: birthdateUse });
        skipVerify = true;
      }
    }
    if (skipVerify) continue;

    // â”€â”€ 6. Verify OTP SMS (dengan /resend /cancel /ban)
    console.log(chalk.yellow('\nâš¡ Step 7/8: Verifying SMS OTP...'));
    let smsVerified = false;
    let cancelled   = false;
    let cancelledBan = false; // NEW FLAG

    for (let i = 0; i < 15 && !smsVerified && !cancelled && !cancelledBan; i++) {
      const code = await promptSmsOtpFlexible();

      // /ban branch
      if (/^\/ban$/i.test(code)) {
        console.log(chalk.red('ğŸš« Banning this account by request...'));
        await banCurrentAccountFlow(emailUse, passwordUse, token, deviceId, ua, lang);

        cancelledBan = true;
        break;
      }

      if (/^\/cancel$/i.test(code)) {
        console.log(chalk.yellow('âš ï¸  SMS verification cancelled by user'));
        cancelled = true;
        break;
      }
      if (/^\/resend$/i.test(code)) {
        const r = await sendPhoneOtp(token, numberUse, ua, lang);
        if (r.status_code === 429) {
          console.log(chalk.yellow('â³ Rate limited - waiting 60 seconds...'));
          await delay(60000);
        } else if (r.status_code === 200) {
          console.log(chalk.green('âœ… New SMS OTP sent successfully'));
        } else {
          console.log(chalk.red(`âŒ Failed to resend SMS OTP: ${r.message || r.status_code}`));
        }
        i--;
        continue;
      }

      const smsV = await verifyPhoneOtp(token, numberUse, code, ua, lang);
      if (smsV.status_code === 200) {
        smsVerified = true;
        console.log(chalk.green('âœ… Phone number verified successfully'));
        break;
      }
      if (smsV.status_code === 429) {
        console.log(chalk.yellow('â³ Too many attempts - waiting 60 seconds...'));
        await delay(60000);
        i--;
        continue;
      }
      console.log(chalk.red('âŒ Invalid SMS OTP - try again, /resend, /ban, or /cancel'));
    }

// â”€â”€ 7. Re-login & cek flag backend (kalau sempat verif) â€” with confirm wait window
if (cancelledBan) {
  // akun sudah di-ban & dipurge; jangan snapshot, jangan lanjut Step 8
  continue;
}

let mobileConfirmed = false; // <-- moved outside so we can reuse below

if (smsVerified) {
  // Retry parameters (from ENV)
  const MAX_RELOGIN = Number(process.env.REL0GIN_MAX_ATTEMPTS || 12);
  const BASE_DELAY_MS = Number(process.env.REL0GIN_BASE_DELAY_MS || 2500);

  let loginSuccess = false;
  for (let i = 1; i <= MAX_RELOGIN; i++) {
    const attempt = await getLoginAccount(emailUse, passwordUse, deviceId, ua, lang); // â† passwordUse
    if (attempt.status_code === 200 && attempt.token) {
      token = attempt.token;
      loginSuccess = true;
      log.success(`Re-login after phone verification successful (attempt ${i}/${MAX_RELOGIN})`);
      // refresh bearer setelah re-login (post verify)
      try { await upsertAccountJsonBearer_local(emailUse, token); } catch {}
      break;
    }
    const wait = Math.min(BASE_DELAY_MS * i, 15000);
    log.error(`Re-login attempt ${i}/${MAX_RELOGIN} failed: ${attempt.message || attempt.status_code}. Retrying in ${Math.round(wait/1000)}s...`);
    await delay(wait);
  }

  if (!loginSuccess) {
    log.error('Re-login failed after verification - saving snapshot and skipping profile update for this account');
    try {
      await snapshotAndSave({ token, email: emailUse, phone: numberUse, fallbackName: randomName, fallbackBirthday: birthdateUse });
    } catch {}
    continue;
  }

  // === Tunggu backend confirm VERF_MOB_YN=1 dengan backoff & hard deadline
  mobileConfirmed = false;
  const startedAtConfirm = Date.now();
  let waitMs = MOBILE_CONFIRM_BASE_WAIT_MS; // 1s awal
  while (Date.now() - startedAtConfirm <= MOBILE_CONFIRM_DEADLINE_MS) {
    const info = await getMemberInfo(token, ua, lang);
    if (info.RESULTS?.ds_mbrList?.VERF_MOB_YN === '1') {
      mobileConfirmed = true;
      log.success('Phone status confirmed on backend');
      break;
    }
    await delay(waitMs);
    waitMs = Math.min(Math.round(waitMs * 1.5), MOBILE_CONFIRM_MAX_WAIT_MS); // backoff 1sâ†’1.5sâ†’... capped 5s
  }

  if (!mobileConfirmed) {
    log.warning(`Backend has not confirmed phone status within ~${Math.round(MOBILE_CONFIRM_DEADLINE_MS/1000)}s â€” performing extra re-login attempts to re-check.`);

    // NEW FALLBACK LOOP:
    const EXTRA_CONFIRM_LOGIN_MAX     = Number(process.env.EXTRA_CONFIRM_LOGIN_MAX || 5);
    const EXTRA_CONFIRM_LOGIN_DELAYMS = Number(process.env.EXTRA_CONFIRM_LOGIN_DELAYMS || 10000);

    for (let extraTry = 1; extraTry <= EXTRA_CONFIRM_LOGIN_MAX && !mobileConfirmed; extraTry++) {

      const rel = await getLoginAccount(emailUse, passwordUse, deviceId, ua, lang);
      if (rel.status_code === 200 && rel.token) {
        token = rel.token;
        try { await upsertAccountJsonBearer_local(emailUse, token); } catch {}
        const infoNow = await getMemberInfo(token, ua, lang);
        if (infoNow.RESULTS?.ds_mbrList?.VERF_MOB_YN === '1') {
          mobileConfirmed = true;
          log.success(`Phone status confirmed after extra re-login attempt ${extraTry}/${EXTRA_CONFIRM_LOGIN_MAX}`);
          break;
        } else {
          log.warning(`Extra re-login ${extraTry}/${EXTRA_CONFIRM_LOGIN_MAX} still not confirmed.`);
        }
      } else {
        log.error(`Extra re-login ${extraTry}/${EXTRA_CONFIRM_LOGIN_MAX} failed: ${rel.message || rel.status_code}`);
      }

      await delay(EXTRA_CONFIRM_LOGIN_DELAYMS);
    }

    if (!mobileConfirmed) {
      log.warning('Backend still not reporting verified phone after extra re-login attempts.');
    }
  }
} else {
  // â›”ï¸ Perubahan utama: kalau SMS belum terverifikasi, jangan lanjut Step 8
  log.warning('SMS OTP verification not completed - account will be saved with verified_phone=false');
  try {
    await snapshotAndSave({ token, email: emailUse, phone: numberUse, fallbackName: randomName, fallbackBirthday: birthdateUse });
  } catch (e) {
    log.error(`Failed to save account snapshot: ${e.message}`);
  }
  continue; // â† langsung lompat ke akun berikutnya (SKIP Step 8)
}


// â”€â”€ 8. Update profile random (idempotent + retry until phone-confirm)
console.log(chalk.yellow('\nâš¡ Step 8/8: Updating profile information...'));

if (!mobileConfirmed) {
  // kalau backend BELUM confirm walau sudah extra loop â†’ jangan paksain updateProfile
  log.warning('Phone still not confirmed by backend - skipping profile update for this account.');
} else {
  try {
    const payload = generateRandomProfile(numberUse, emailUse);

    let updated = false;
    let lastErr  = null;

    const hardStart = Date.now();
    for (let attempt = 1; attempt <= PROFILE_UPDATE_MAX_ATTEMPTS; attempt++) {
      // safety: stop kalau sudah melewati deadline step
      if (Date.now() - hardStart > STEP_HARD_DEADLINE_MS) {
        lastErr = `Profile update exceeded deadline (${Math.round(STEP_HARD_DEADLINE_MS/1000)}s)`;
        break;
      }

      const up = await updateProfile(token, payload, ua, lang);
      if (up && up.status_code === 200) {
        updated = true;
        if (attempt > 1) console.log(chalk.green(`âœ… Profile updated (attempt ${attempt}/${PROFILE_UPDATE_MAX_ATTEMPTS})`));
        else console.log(chalk.green('âœ… Profile updated successfully'));
        break;
      }

      // simpan pesan error untuk log
      const msg = String(up?.message || up?.status_code || 'unknown');

      // Jika API jelas meminta verifikasi HP â†’ langsung SKIP & stop retry
      if (/verify.*phone/i.test(msg) || up?.status_code === 412) {
        log.warning('Profile update requires verified phone â†’ skipping profile update for this account.');
        updated = false;
        lastErr = 'requires phone verification';
        break; // â† keluar dari loop update profile (SKIP)
      }

      // error lain (termasuk 400 yang bukan "verify phone"): backoff standar lalu retry
      lastErr = msg;
      const base = PROFILE_UPDATE_BASE_DELAY_MS * attempt;
      const jitter = Math.floor(Math.random() * 800);
      const wait = Math.min(base + jitter, PROFILE_UPDATE_MAX_DELAY_MS);
      console.log(chalk.yellow(`ğŸ”„ Profile failed (${msg}). Retrying in ${Math.round(wait/1000)}s...`));
      await delay(wait);
    }

    if (!updated) {
      console.log(chalk.red(`âŒ Profile update failed: ${lastErr || 'unknown'}`));
    }

  } catch (e) {
    console.log(chalk.red(`âŒ Profile update error: ${e.message}`));
  }
}


    // â”€â”€ 9. Snapshot & simpan ke account.json
    try {
      await snapshotAndSave({ token, email: emailUse, phone: numberUse, fallbackName: randomName, fallbackBirthday: birthdateUse });
    } catch (e) {
      log.error(`Failed to save account snapshot: ${e.message}`);
    }

    // â”€â”€ 10. Delay antar akun
    if (successCount < jumlahCreate) {
      const delayMs = Math.random() * 3000 + 2000;
      console.log(chalk.gray(`\nâ³ Preparing next account in ${Math.round(delayMs/1000)}s...`));
    }
    await delay(Math.random() * 3000 + 2000);
  }

  // Final summary
  console.log(chalk.green('\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®'));
  console.log(chalk.green('â”‚') + chalk.white.bold('                ACCOUNT CREATION COMPLETED                  ') + chalk.green('â”‚'));
  console.log(chalk.green('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤'));
  console.log(chalk.green('â”‚') + ` ğŸ¯ Target     : ${jumlahCreate} accounts`.padEnd(56) + ' ' + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` âœ… Created    : ${successCount} accounts`.padEnd(56) + ' ' + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` ğŸ“Š Success    : ${Math.round((successCount/jumlahCreate) * 100)}%`.padEnd(56) + ' ' + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` ğŸ“ Saved to   : akunLogin.txt & account.json`.padEnd(56) + ' ' + chalk.green('â”‚'));
  console.log(chalk.green('â”‚') + ` â° Completed  : ${new Date().toLocaleString('id-ID')}`.slice(0,56).padEnd(56) + ' ' + chalk.green('â”‚'));
  console.log(chalk.green('â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯'));
};
/* ================================================================ */











/* ================================================================
   5. ---------- XTRAP CODE VOUCHER (TETAP DITAHAN) ---------------
   (Kode ini tidak diubah, sama dengan versi 590 lines aslinya)
   ================================================================ */
const saveInvalidCode = async (c) => await fs.appendFile('invalid_codes.txt', c + '\n');
const saveValidCode   = async (c) => await fs.appendFile('validCodes.txt', c + '\n');
const invalid = (() => {
  if (!fs1.existsSync('invalid_codes.txt')) return new Set();
  return new Set(fs1.readFileSync('invalid_codes.txt', 'utf8').split('\n').filter(Boolean));
})();
function generateVoucherCodeV2() {
  const prefix = 'TSEL', suffix = '10K', cs = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code;
  do {
    let mid = '';
    for (let i = 0; i < 8; i++) mid += cs.charAt(Math.floor(Math.random() * cs.length));
    code = prefix + mid + suffix;
  } while (invalid.has(code));
  return code;
}

const registerCoupon = async (
  token,
  orderId,
  couponNumber,
  emailUse,
  ua   = getRandomUA(),
  lang = getRandomLang()
) => {
  const form = new FormData();
  form.set('order_id',      orderId);
  form.set('coupon_number', couponNumber);
  try {
    const res = await fetch('https://v2-api.cgv.id/api/orders/coupon/register', {
      method : 'POST',
      headers: {
        Authorization     : `Bearer ${token}`,
        'User-Agent'      : ua,
        'Accept-Language' : lang,
        Connection        : 'Keep-Alive',
        Accept            : 'application/json, text/plain, */*',
        'Accept-Encoding' : 'gzip',
      },
      body : form,
      agent: getRandomProxy()
    });
    return await res.json();
  } catch (e) {
    return { status_code: 500, message: e.message };
  }
};

const pilihAkunLogin = async () => {
  const akunList = await readAkunLoginList();
  if (!akunList.length) { console.log(chalk.red('No accounts in akunLogin.txt')); process.exit(0); }
  const { selected } = await inquirer.prompt([{
    type:'list', name:'selected', message:'Select account:',
    choices: akunList.map((a,i)=>({ name:`${i+1}. ${a.email}`, value:a }))
  }]);
  return selected;
};
const XtrapCodeVoucher = async () => {
  console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.cyan('â•‘                  VOUCHER CODE EXTRACTOR                     â•‘'));
  console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
  const { email, password } = await pilihAkunLogin();
  console.log(chalk.yellow(`[!] Using account: ${email}\n`));
  let token = null, attempt = 0, loginStreak = 0;
  const orderId = '21489529';
  const relogin = async () => {
    if (loginStreak >= 3) { console.log(chalk.red('[!] Rate limit. Waiting 60s')); await sleep(60000); loginStreak = 0; }
    const res = await getLoginAccount(email,password);
    if (res.status_code===200) { token=res.token; loginStreak++; }
    else throw new Error(res.message);
  };
  await relogin();
  while(true) {
    if (attempt>0 && attempt%5===0) { console.log('[!] Refresh token'); await relogin(); }
    const voucherUse = generateVoucherCodeV2();
    const check = await registerCoupon(token,orderId,voucherUse,email);
    attempt++;
    if (check.status_code===200) {
      console.log(chalk.green(`[âœ“] VALID: ${voucherUse}`));
      await saveValidCode(voucherUse);
    } else if (check.status_code===429) {
      console.log(chalk.red('[!] 429, wait 60s')); await sleep(60000); attempt=0; loginStreak=0; await relogin();
    } else {
      console.log(chalk.red(`[âœ—] ${voucherUse}`));
      await saveInvalidCode(voucherUse);
      await sleep(Math.random()*1000+500);
    }
  }
};

/* â”€â”€ universalTable() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Mengembalikan constructor Table dari 'cli-table3' tanpa peduli
   apakah project-mu pakai ESM `import` atau CommonJS `require`.
-----------------------------------------------------------------*/
let _TableCtor;
async function universalTable() {
  if (_TableCtor) return _TableCtor;        // cache

  try {                                     // coba sintaks ESM
    const mod = await import('cli-table3');
    _TableCtor = mod.default || mod.Table || mod;
  } catch {
    _TableCtor = require('cli-table3');     // fallback CJS
  }
  return _TableCtor;
}

/* ================================================================
   CHECK VOUCHERS â€” account.json only â†’ bearer cache â†’ auto refresh if invalid
   - Simpan UNUSED: Small Salty/Popcorn (khusus 1st Visit), Combo Solo (termasuk Birthday+Combo Solo),
     Combo Duo (termasuk Birthday+Combo Duo), TELKOMSEL 10K FLATPRICE, 3rd Visit: B1G1 Ticket 2D,
     dan VIP (Private Box 50% / Kitchen-Concessions Drink) â†’ checkVouchers.txt
   - Tabel per akun (universalTable, rapi)
     â€¢ Kolom "Type" mengklasifikasikan kategori voucher: MOVIE / FNB / OTHER
     â€¢ Kolom "Tag" untuk penanda promo: BIRTHDAY / COMBO SOLO / COMBO DUO / BIRTHDAY + COMBO SOLO/DUO / -
   - Static concurrency (worker pool), buffer I/O, batch update account.json (sekali di akhir)
   - (Update) HANYA pakai account.json (email+password). akunLogin.txt diabaikan.
   - (Update) Randomize HTTP headers per akun (aman) seperti listAccounts
   - (New) VIP digabung sebagai satu tipe di file output:
       â€¢ Body: kolom Type â€œVIPâ€ sekali per akun (tanpa total); baris VIP selanjutnya kosong
       â€¢ Summary: â€œVIP : <jumlah voucher VIP>â€ (tanpa â€œ(â€¦ vouchers)â€)
   - (Baru) Grouping per email pada file output:
     baris pertama berisi Email/NOMOR AKUN/Password/Visits/Tier/Points/LastMovie/TxnToday,
     baris-baris selanjutnya (untuk email sama) hanya kolom Type (VIP sekali), Voucher Name, Expired.

   CATATAN PENTING:
   - Password candidates = item.password + ENV DEFAULT_PASSWORDS (comma-separated).
   - Jika login berhasil dengan password berbeda â†’ update HANYA field password + password_updated_at.
   - Jika bearer expired/invalid â†’ update HANYA 3 kolom bearer: bearer, bearer_wrapped, bearer_updated_at.
   - JANGAN PERNAH mengubah generated_at atau menomori ulang no.
   - account.json ditulis SEKALI di akhir.
   ================================================================ */
async function checkVouchers() {
  console.clear();
  console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.cyan('â•‘                       CHECK VOUCHERS                         â•‘'));
  console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));

  /* ===== TUNABLES ===== */
  const ACCOUNT_CONCURRENCY = 8;          // paralel akun
  const PER_WORKER_JITTER_MS = [80, 180]; // jeda kecil antar akun / worker
  const SHOW_TABLES = true;               // tampilkan tabel voucher per akun

  // helper delay
  const delay = (ms)=>new Promise(r=>setTimeout(r,ms));

  // today (YYYY-MM-DD) â†’ untuk TxnToday & hitung sisa hari
  const pad2 = (n) => String(n).padStart(2,'0');

  // formatPoints: 10000 -> "10.000"
  // kalau null/NaN -> "0"
  const formatPoints = (val) => {
    const num = Number(val || 0);
    const absStr = Math.floor(Math.abs(num))
      .toString()
      .replace(/\B(?=(\d{3})+(?!\d))/g, '.');
    return num < 0 ? `-${absStr}` : absStr;
  };

  const todayIso = (() => {
    const d = new Date();
    return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  })();

  // ===== helper tanggal & sisa hari =====
  const parseIsoYmd = (s) => {
    const str = String(s || '').trim();
    const m = /^(\d{4})-(\d{2})-(\d{2})/.exec(str);
    if (!m) return null;
    const d = new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));
    return isNaN(d) ? null : d;
  };

  const calcDaysLeft = (ymd) => {
    const exp = parseIsoYmd(ymd);
    const today = parseIsoYmd(todayIso);
    if (!exp || !today) return null;
    const ms = exp.getTime() - today.getTime();
    return Math.round(ms / 86400000); // bisa negatif kalau sudah lewat
  };

  const formatExpCell = (ymd, daysLeft) => {
    const base = ymd || '-';
    if (daysLeft == null || !isFinite(daysLeft)) return base;
    if (daysLeft < 0) return `${base} (EXPIRED)`;
    if (daysLeft === 0) return `${base} (HARI INI)`;
    return `${base} (${daysLeft} hari lagi)`;
  };

  /* ===== HEADER RANDOMIZATION (aman) â€” mirip listAccounts ===== */
  const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const randomOkHttpUA = () => {
    const vers = choice(['4.9.3','4.10.0','4.11.0','4.12.0']);
    return `okhttp/${vers}`;
  };
  const randomLang = () => choice([
    'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
    'id,en-US;q=0.9,en;q=0.8',
    'en-US,en;q=0.9,id;q=0.8',
    'id-ID,en;q=0.9'
  ]);
  const makeAccountHeaders = () => ({
    'accept': 'application/json, text/plain, */*',
    'accept-encoding': 'gzip',
    'accept-language': randomLang(),
    'user-agent': randomOkHttpUA(),
    'connection': 'Keep-Alive'
  });

  // timeout wrapper
  const withTimeout = (promise, ms, label = 'Timeout') =>
    Promise.race([
      promise,
      new Promise((_, rej) => setTimeout(() => rej(new Error(label)), ms))
    ]);

  // merge headers helper
  const mergeHeaders = (base, extra) => {
    const out = { ...(base || {}) };
    for (const k of Object.keys(extra || {})) out[k.toLowerCase()] = extra[k];
    return out;
  };

  // safe wrappers (dukung headers acak per akun seperti listAccounts)
  const getMemberInfoSafe = async (token, accHeaders) => {
    try {
      try {
        return await withTimeout(getMemberInfo(token, accHeaders), 20000, 'getMemberInfo timeout');
      } catch {
        return await withTimeout(getMemberInfo(token), 20000, 'getMemberInfo timeout');
      }
    } catch { return null; }
  };
  const getLoginAccountSafe = async (email, pwd, accHeaders) => {
    try {
      try {
        return await withTimeout(getLoginAccount(email, pwd, accHeaders), 20000, 'login timeout');
      } catch {
        return await withTimeout(getLoginAccount(email, pwd), 20000, 'login timeout');
      }
    } catch (e) {
      return { status_code: 0, message: e?.message || 'Login error' };
    }
  };

  // === TRANSAKSI API (persis gaya listAccounts, aman)
  const fetchTransactions = async (token, accHeaders) => {
    const baseHeaders = {
      'accept': 'application/json, text/plain, */*',
      'authorization': `Bearer ${token}`,
      'accept-encoding': 'gzip',
      'user-agent': (accHeaders && accHeaders['user-agent']) || 'okhttp/4.10.0',
      'connection': 'Keep-Alive',
      ...(accHeaders?.['accept-language'] ? { 'accept-language': accHeaders['accept-language'] } : {})
    };
    const headers = mergeHeaders(baseHeaders, accHeaders || {});
    try {
      const res = await withTimeout(
        fetch('https://v2-api.cgv.id/api/membership/transactions', { method: 'GET', headers }),
        15000,
        'transactions timeout'
      );
      if (!res.ok) return { ok:false, data:[] };
      const j = await res.json().catch(()=>null);
      const arr = j?.data;
      return { ok:true, data: Array.isArray(arr) ? arr : [] };
    } catch {
      return { ok:false, data:[] };
    }
  };
  const fetchTransactionsSafe = async (token, accHeaders) => {
    try {
      return await withTimeout(fetchTransactions(token, accHeaders), 20000, 'fetchTransactions timeout');
    } catch {
      return { ok:false, data:[] };
    }
  };

  // LAST MOVIE ONLY
  const norm8toIso = (d) =>
    /^[0-9]{8}$/.test(String(d||'')) ? `${String(d).slice(0,4)}-${String(d).slice(4,6)}-${String(d).slice(6,8)}` : null;

  const firstIso = (...vals) => {
    for (const v of vals) {
      if (!v) continue;
      if (typeof v === 'string') {
        const s = v.trim();
        if (!s) continue;
        if (/^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0,10);
        const n8 = norm8toIso(s); if (n8) return n8;
        if (/^\d{4}\/\d{2}\/\d{2}$/.test(s)) return s.replace(/\//g,'-');
      }
      if (typeof v === 'number' && isFinite(v)) {
        const d = new Date(v);
        if (!isNaN(d)) return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
      }
    }
    return null;
  };

  const isMovieTxn = (t) => {
    const txt = [
      t.type, t.ORD_CLSS_NM, t.ORD_CLSS_CD, t.ORD_TYP_NM, t.ORD_TYP_CD,
      t.ITEM_NM, t.MOVIE_NM, t.MOV_TTL_NM, t.TITLE_NM, t.CAT_NM
    ].map(x=>String(x||'').toLowerCase()).join(' ');
    return /ticket|movie|film|b1g1|2d|imax|4dx|studio|cinema|seat/.test(txt);
  };

  const getLastMovieDate = (txnsRaw) => {
    if (!Array.isArray(txnsRaw) || txnsRaw.length === 0) return '-';
    const cand = txnsRaw.filter(isMovieTxn);
    if (!cand.length) return '-';
    const pickDate = (t) => firstIso(
      t.CREATED_AT, t.ORDER_TIME, t.REG_DTTM,
      t.transaction_date_time, t.transaction_date,
      t.PAY_DTTM, t.SALES_DTTM, t.ORD_DTTM, t.TRX_DTTM,
      t.PAY_DY, t.SALE_DY, t.SALES_DY, t.ORD_DY, t.TRX_DY,
      t.PAY_DT, t.SALE_DT, t.SALES_DT, t.ORD_DT, t.TRX_DT
    ) || '-';
    cand.sort((a,b) => (pickDate(b)||'').localeCompare(pickDate(a)||'')); // desc
    return pickDate(cand[0]) || '-';
  };

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     1) MUAT AKUN (HANYA dari account.json) + AUTO-SKIP not_found
  ----------------------------------------------------------------*/
  const normEmail = s => String(s||'').trim().toLowerCase();

  // baca account.json; jika gagal â†’ hentikan
  let accountJsonRaw = null;
  let accountJson = null;
  try {
    accountJsonRaw = await fs.readFile('account.json','utf-8');
    accountJson = JSON.parse(accountJsonRaw);
  } catch (e) {
    console.log(chalk.red('âŒ  account.json tidak ditemukan / rusak.'));
    await delay(1500);
    return;
  }
  const items = Array.isArray(accountJson?.items) ? accountJson.items : [];
  if (!items.length) {
    console.log(chalk.red('âŒ  account.json kosong. Tidak ada akun yang bisa diproses.'));
    await delay(1500);
    return;
  }

  // muat daftar email "not found" dari notfound.json (kalau ada)
  const NOTFOUND_FILE = 'notfound.json';
  const notFoundSet = new Set();
  try {
    const nfRaw = await fs.readFile(NOTFOUND_FILE, 'utf-8');
    const nf = JSON.parse(nfRaw);
    if (Array.isArray(nf)) {
      nf.forEach(r => { if (r && r.email) notFoundSet.add(normEmail(r.email)); });
    }
  } catch { /* silent if missing */ }

  // peta referensi langsung ke objek aslinya (in-memory)
  const itemByEmail = new Map(items.map(it => [normEmail(it.email), it]));

  // cache helper
  const bearerMap = new Map();
  const passMap   = new Map();
  const phoneMap  = new Map();
  for (const it of items) {
    if (it.email && it.bearer)   bearerMap.set(normEmail(it.email), String(it.bearer));
    if (it.email && it.password) passMap.set(normEmail(it.email), String(it.password));
    if (it.email && it.phone)    phoneMap.set(normEmail(it.email), String(it.phone));
  }

  // daftar akun yg diproses
  const itemsFiltered = items.filter(it => {
    if (!it || !it.email) return false;
    const k = normEmail(it.email);
    const flaggedInAccount =
      it.not_found === true ||
      String(it.account_status || '').toLowerCase() === 'not_found' ||
      String(it.status || '').toLowerCase() === 'not_found';
    const flaggedInFile = notFoundSet.has(k);
    return !flaggedInAccount && !flaggedInFile;
  });
  const akunList = itemsFiltered.map(it => ({ email: it.email, password: it.password || '', phone: it.phone }));

  // preview akun yg akan diproses
  {
    const TableCtor = await universalTable();
    const t = new TableCtor({ head:['No','Email'], colWidths:[6,58], style:{head:['yellow']}, wordWrap:true });
    akunList.forEach((a,i)=>t.push([String(i+1).padStart(2,'0'), a.email]));
    console.log(t.toString());
  }
  console.log(chalk.gray(`Total accounts found: ${items.length} | skipped (not_found): ${items.length - akunList.length} | to process: ${akunList.length}\n`));
  if (!akunList.length) {
    console.log(chalk.yellow('Semua akun tersaring (not_found). Tidak ada yang diproses.\n'));
    return;
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     2) BEARER UPDATE helper (IN-MEMORY ONLY)
  ----------------------------------------------------------------*/
  const wrapBearer3 = (token) => {
    const s = String(token || '');
    if (!s) return [];
    const part = Math.ceil(s.length / 3);
    return [ s.slice(0, part), s.slice(part, part*2), s.slice(part*2) ];
  };
  const applyBearerUpdateInMemory = (email, token) => {
    const key = normEmail(email);
    const it = itemByEmail.get(key);
    if (!it) return;
    const nowIso = new Date().toISOString();
    it.bearer = token;
    it.bearer_wrapped = wrapBearer3(token);
    it.bearer_updated_at = nowIso;
    bearerMap.set(key, token);
  };

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     3) LOGIN HELPER
  ----------------------------------------------------------------*/
  const reasonFromLoginError = (res) => {
    const sc = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    if (/invalid credential|invalid password|wrong password/.test(msg) || sc === 401) return 'Wrong password';
    if (sc === 429 || /too many|rate limit/.test(msg))        return 'Rate limited (429)';
    if (sc === 404 || /member not found|not found/.test(msg)) return 'Account not found';
    if (/timeout|network|fetch fail|networkerror|timed out/.test(msg)) return 'Network/Timeout';
    if (/non-json response/.test(msg))                        return 'Anti-bot/gateway (non-JSON)';
    if (sc >= 500)                                            return `Server error (${sc})`;
    if (sc && sc !== 200)                                     return `HTTP ${sc}`;
    return 'Unknown login error';
  };
  const isRetryable = (res) => {
    const sc = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    if (/invalid credential|invalid password|wrong password/.test(msg) || sc === 401) return false;
    return (
      sc === 429 ||
      (sc >= 500) ||
      /timeout|network|fetch fail|networkerror|timed out/.test(msg) ||
      /non-json response/.test(msg)
    );
  };

  // ENV DEFAULT_PASSWORDS
  const envPasswords = (process?.env?.DEFAULT_PASSWORDS || '')
    .split(',').map(s => s.trim()).filter(Boolean);

  const safeLoginPro = async (email, itemPwd, accHeaders) => {
    const cached = bearerMap.get(normEmail(email));
    if (cached) {
      try {
        const info = await getMemberInfoSafe(cached, accHeaders);
        if (info?.RESULTS?.ds_mbrList && info?.status_code === 200) {
          return { ok:true, token: cached, via:'bearer' };
        }
      } catch {}
    }

    const candidates = [...new Set([itemPwd, ...envPasswords].filter(Boolean))];
    const MAX_RETRY_PER_PWD = 8;
    const MAX_TOTAL_SECONDS = 120;
    const startTime = Date.now();

    let last = null;
    for (const pwd of candidates) {
      let attempt = 0, backoff = 1200;
      while (true) {
        if ((Date.now() - startTime)/1000 > MAX_TOTAL_SECONDS) break;
        attempt++;
        try {
          const res = await getLoginAccountSafe(email, pwd, accHeaders);
          last = res;
          if (res?.status_code === 200 && res?.token) {
            applyBearerUpdateInMemory(email, res.token);
            return { ok:true, token: res.token, via: (pwd === itemPwd ? 'item' : 'env'), usedPwd: pwd };
          }
          const retriable = isRetryable(res);
          const msg = res?.message || res?.status_code;
          if (!retriable) {
            console.log(chalk.red(`[âœ—] Login gagal (${email}) attempt ${attempt} dengan password "${pwd}": ${msg}`));
            break;
          }
          console.log(chalk.yellow(`[â†»] Retry (${email}) attempt ${attempt} dengan password "${pwd}" karena: ${msg}`));
          if (attempt >= MAX_RETRY_PER_PWD) break;
          await delay(backoff + Math.floor(Math.random()*300));
          backoff = Math.min(backoff*1.5, 8000);
        } catch(e) {
          console.log(chalk.yellow(`[â†»] Retry (${email}) attempt ${attempt} dengan password "${pwd}" exception: ${e.message}`));
          if (attempt >= MAX_RETRY_PER_PWD) break;
          await delay(backoff + Math.floor(Math.random()*300));
          backoff = Math.min(backoff*1.5, 8000);
        }
      }
    }
    return { ok:false, reason: reasonFromLoginError(last) };
  };

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     4) DETEKTOR & FORMAT (default width; finalnya di-auto-fit saat flush)
  ----------------------------------------------------------------*/
  const SEP = ' â”‚ ';
  const END = ' â”‚';

  const clip = (s, w) => {
    const str = String(s ?? '');
    if (str.length <= w) return str.padEnd(w, ' ');
    if (w <= 1) return 'â€¦';
    return str.slice(0, w - 1) + 'â€¦';
  };

  const fmtDate = d => /^[0-9]{8}$/.test(d)
    ? `${d.slice(0,4)}-${d.slice(4,6)}-${d.slice(6)}`
    : (d || '-');

  const isVoucherUsed = (v) => {
    const useYN  = String(v.USE_YN ?? v.use_yn ?? v.USED_YN ?? v.USE_YN_CD ?? v.USE_YN_NM ?? '').trim().toUpperCase();
    const usedAt = v.USE_DTTM ?? v.REDM_DTTM ?? v.REDEEM_DTTM ?? v.REDEEM_DT ?? v.USE_DT;
    if (['1','Y','YES','USED','T','TRUE'].includes(useYN)) return true;
    if (usedAt != null && String(usedAt).trim() !== '') return true;
    return false;
  };

  const isBirthdayVoucher = (v) =>
    /birthday/i.test(String(v.DSC_NM || v.GFTCERT_NM || v.CPN_NM || '')) ||
    /birthday/i.test(String(v.ON_CUST_NOTY_CONT || v.DSC_DTL || v.REMARK || ''));

  const isPopcornVoucher = (v) =>
    /(popcorn|salty)/i.test(String(v.DSC_NM || v.GFTCERT_NM || ''));

  const isComboSoloVoucher = (v) =>
    /combo\s*solo/i.test(String(v.DSC_NM || v.GFTCERT_NM || v.CPN_NM || '')) ||
    /combo\s*solo/i.test(String(v.ON_CUST_NOTY_CONT || v.DSC_DTL || v.REMARK || ''));

  const isComboDuoVoucher = (v) =>
    /combo\s*duo/i.test(String(v.DSC_NM || v.GFTCERT_NM || v.CPN_NM || '')) ||
    /combo\s*duo/i.test(String(v.ON_CUST_NOTY_CONT || v.DSC_DTL || v.REMARK || ''));

  const detectVoucherCategory = (v) => {
    const name = [
      v.DSC_NM, v.GFTCERT_NM, v.CPN_NM, v.PROMO_NM, v.TTL_NM, v.TITLE_NM
    ].map(x => String(x || '')).join(' ').toLowerCase();
    const note = String(v.ON_CUST_NOTY_CONT || v.DSC_DTL || v.REMARK || '').toLowerCase();
    const text = `${name} ${note}`;
    const FNB_PATTERNS = [
      /popcorn/, /salty/, /combo/, /drink/, /tea/, /coffee/, /snack/, /nachos/,
      /hot\s*dog/, /\bf&b\b/, /mineral\s*water/, /refill/, /upsize/, /kitchen/, /concessions/
    ];
    const MOVIE_PATTERNS = [
      /b1g1/, /buy\s*1\s*get\s*1/, /ticket/, /movie/, /\bfilm\b/, /\b2d\b/, /\b3d\b/,
      /imax/, /4dx/, /screen\s*x/, /studio/, /cinema\s*day/, /seat/, /private\s*box/,
      /e[-\s]?voucher/
    ];
    const OTHER_PATTERNS = [ /pouch|merch|merchandise|souvenir|t.?shirt|screen\s*pouch|gift/ ];
    if (FNB_PATTERNS.some(re => re.test(text))) return 'FNB';
    if (MOVIE_PATTERNS.some(re => re.test(text))) return 'MOVIE';
    if (OTHER_PATTERNS.some(re => re.test(text))) return 'OTHER';
    if (v.MOVIE_NM || v.MOV_TTL_NM || v.TITLE_NM) return 'MOVIE';
    return 'OTHER';
  };

  // deteksi E-Voucher dengan nominal berapapun (25K, 50K, 75K, 100K, 150K, dll)
  const isEVoucher = (v) => {
    const name = [
      v.DSC_NM, v.GFTCERT_NM, v.CPN_NM, v.PROMO_NM, v.TITLE_NM, v.name
    ].map(s => String(s||'')).join(' ').toLowerCase();
    const note = String(v.ON_CUST_NOTY_CONT || v.DSC_DTL || v.REMARK || '').toLowerCase();
    const code = String(v.CPN_NO || v.number || v.code || '').trim().toUpperCase();
    const text = `${name} ${note}`;

    // Deteksi E-Voucher dari:
    // 1. Name mengandung "e-voucher" atau "e voucher"
    // 2. Code dimulai dengan A0 (gift voucher dari website)
    // 3. Kind = "gift" + name mengandung "voucher" + "value"
    const hasEVoucherText = /e[-\s]?voucher/.test(text) || /voucher\s*value/i.test(text);
    const hasA0Code = /^A0\d+/.test(code);
    const isGiftVoucher = String(v.kind || '').toLowerCase() === 'gift' && /voucher/.test(text);

    return hasEVoucherText || hasA0Code || isGiftVoucher;
  };

  // deteksi E-Coupon (Coupon Value) - berbeda dari E-Voucher (tidak butuh PIN)
  const isECoupon = (v) => {
    const name = [
      v.DSC_NM, v.GFTCERT_NM, v.CPN_NM, v.PROMO_NM, v.TITLE_NM, v.name
    ].map(s => String(s||'')).join(' ').toLowerCase();
    const kind = String(v.kind || '').toLowerCase();
    const code = String(v.CPN_NO || v.number || v.code || '').trim().toUpperCase();

    // Deteksi E-Coupon dari:
    // 1. Kind = "coupon" + name mengandung "coupon value"
    // 2. Code seperti "MORE..." (promo code)
    // 3. Name contains "coupon value" (case insensitive)
    const isCouponKind = kind === 'coupon';
    const hasCouponValue = /coupon\s*value/i.test(name);
    const hasMoreCode = /^MORE/i.test(code);

    return (isCouponKind && hasCouponValue) || hasMoreCode;
  };

  // Extract nominal dari nama E-Voucher atau E-Coupon (25K, 50K, 75K, 100K, dll)
  const extractValue = (v) => {
    const name = [
      v.DSC_NM, v.GFTCERT_NM, v.CPN_NM, v.PROMO_NM, v.TITLE_NM, v.name
    ].map(s => String(s||'')).join(' ');

    // Match pattern: 25K, 50K, 75K, 100K, 150K, 200K, dll
    const match = name.match(/\b(\d+)k\b/i);
    if (match) return `${match[1]}K`;

    // Match pattern: 25.000, 50.000, 100.000, dll
    const matchDot = name.match(/\b(\d+)[.\s]0{3}\b/);
    if (matchDot) {
      const num = parseInt(matchDot[1]);
      return `${num}K`;
    }

    return 'Unknown';
  };

  const textAll = (v) => {
    const nm = [v.DSC_NM, v.GFTCERT_NM, v.CPN_NM, v.PROMO_NM, v.TITLE_NM].map(s=>String(s||'')).join(' ');
    const nt = String(v.ON_CUST_NOTY_CONT || v.DSC_DTL || v.REMARK || '');
    return `${nm} ${nt}`.toLowerCase();
  };

  // deteksi E-Voucher baru: [E-Voucher] 2D ALL DAYS Complimentary Member Rewards
  // â†’ akan diperlakukan sebagai Gold Rewards (voucher GOLD)
  const isEVoucherComplimentaryRewards = (v) => {
    const t = textAll(v);
    return /e[-\s]?voucher/.test(t) && /complimentary\s*member\s*rewards/.test(t);
  };

  const isFirstVisitPopcorn = (v) => {
    const t = textAll(v);
    return /1st\s*visit/.test(t) && /(popcorn|salty)/.test(t);
  };


  const isTelkomselFlatprice10k = (v) => {
    const t = textAll(v);
    return /telkomsel/.test(t) && /(10k|flat\s*price|flatprice)/.test(t);
  };

  const isThirdVisitB1G12D = (v) => {
    const t = textAll(v);
    return /(3rd|third)\s*visit/.test(t)
        && /(buy\s*1\s*get\s*1|b1g1)/.test(t)
        && /\b2d\b/.test(t);
  };

  // VIP variants â†’ tetap deteksi, tetapi digabung sebagai "VIP" di output
  const isVIPPrivateBox50 = (v) => {
    const t = textAll(v);
    return /vip/.test(t) && /50\s*%/.test(t) && /private\s*box/.test(t);
  };
  const isVIPKitchenDrink = (v) => {
    const t = textAll(v);
    return /vip/.test(t) && /(kitchen|concessions)/.test(t) && /drink/.test(t);
  };

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     5) OUTPUT BUFFER (file ditulis sekali di akhir)
  ----------------------------------------------------------------*/
  // tambah 'tier', 'points', dan 'daysLeft' ke setiap row
  const fileRows = []; // {email,phone,password,visits,tier,points,lastMovie,txnToday,type,name,from,to,isBirthday,daysLeft}

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     6) PROSES AKUN (pool paralel)
  ----------------------------------------------------------------*/
  let totalChecked         = 0;
  let popcornAccCount      = 0;
  let birthdayComboAccCnt  = 0;
  let comboSoloAccCount    = 0;
  let comboDuoAccCount     = 0;
  let telkomselAccCount    = 0;
  let thirdVisitAccCount   = 0;
  let vipAccCount          = 0;  // akun yang punya setidaknya 1 voucher VIP
  const eVouchersByValue   = new Map();  // Map<value, Set<email>> untuk tracking per nominal E-Voucher
  const eVoucherAccounts   = new Set();  // Set untuk tracking unique accounts dengan E-Voucher
  const eCouponsByValue    = new Map();  // Map<value, Set<email>> untuk tracking per nominal E-Coupon
  const eCouponAccounts    = new Set();  // Set untuk tracking unique accounts dengan E-Coupon

  const processOne = async (acc, idx) => {
    const { email, password } = acc;
    const label = `[ ${String(idx+1).padStart(String(akunList.length).length,'0')}/${akunList.length} ]`;
    const accHeaders = makeAccountHeaders();

    console.log(chalk.yellow(`${label} CHECKING ${email}`));

    const login = await safeLoginPro(email, password, accHeaders);
    if (!login.ok) {
      console.log(chalk.red(`${label} âœ— Akses gagal: ${login.reason || 'Login failed'}`));
      return;
    }
    const token = login.token;

    // update password jika berubah (in-memory)
    if (login.via !== 'bearer' && login.usedPwd != null) {
      const it = itemByEmail.get(normEmail(email));
      if (it && String(it.password || '') !== String(login.usedPwd)) {
        it.password = String(login.usedPwd);
        it.password_updated_at = new Date().toISOString();
      }
    }

    let info;
    try {
      info = await getMemberInfoSafe(token, accHeaders);
    } catch (e) {
      console.log(chalk.red(`${label} âœ— Gagal mengambil member info: ${e.message}`));
      return;
    }
    if (info?.status_code !== 200) {
      console.log(chalk.red(`${label} âœ— Member info error: ${info?.message || info?.status_code}`));
      return;
    }

    // nomor akun/HP & tier & points
    const ds = info.RESULTS?.ds_mbrList;
    const mbr = Array.isArray(ds) ? (ds[0] || {}) : (ds || {});
    const nomorAkun =
      acc.phone ||
      phoneMap.get(normEmail(email)) ||
      mbr.MOBILE_NO || mbr.MOBILE || mbr.PHONE_NO || mbr.PHONE || '-';
    const tierName = mbr.MBR_GRD_NM || mbr.MBR_TIER_NM || '-';

    // Visits
    const visits = Number(mbr.TOT_VISIT_FOR_UI ?? mbr.TOT_VISIT ?? 0);

    // Points
    const points = Number(mbr.ACCU_POINT ?? mbr.MILEAGE_AMT ?? 0);

    // Last Movie
    let lastMovie = '-';
    try {
      const txR = await fetchTransactionsSafe(token, accHeaders);
      const txnsRaw = txR?.ok ? (txR.data || []) : [];
      lastMovie = getLastMovieDate(txnsRaw);
    } catch {}
    const txnToday = (lastMovie && lastMovie !== '-' && lastMovie === todayIso) ? 'Y' : 'X';

    const coupons  = info.RESULTS?.ds_CPN_LIST || [];
    const gifts    = info.RESULTS?.ds_GFT_LIST || [];
    const vouchers = [...coupons, ...gifts];
    if (!vouchers.length) {
      console.log(chalk.gray(`${label} (no vouchers)`));
      return;
    }

    // tabel per akun (opsional)
    let perAccTable = null;
    if (SHOW_TABLES) {
      const TableCtor = await universalTable();
      perAccTable = new TableCtor({
        head: ['#','Name','Type','Tag','Used','Valid From','Expired'],
        colWidths: [4, 48, 10, 24, 8, 12, 12],
        wordWrap: true,
        style: { head: ['cyan'] }
      });
    }

    let wrotePopcornThisAccount      = false;
    let wroteComboSoloThisAccount    = false;
    let wroteComboDuoThisAccount     = false;
    let wroteTelkomselThisAccount    = false;
    let wroteThirdVisitThisAccount   = false;
    let hasBDandCS                   = false;
    let hasVIPThisAccount            = false;
    let wroteEVoucherThisAccount     = false;  // E-Voucher (gift, butuh PIN)
    let wroteEVoucherGoldThisAccount = false;  // E-Voucher Complimentary Member Rewards
    let wroteECouponThisAccount      = false;  // E-Coupon (coupon, tidak butuh PIN)


    vouchers.forEach((v, i) => {
      const name = v.DSC_NM || v.GFTCERT_NM || v.CPN_NM || v.PROMO_NM || v.TITLE_NM || '-';
      const from = fmtDate(v.DSC_AVL_FR_DY || v.GFCERT_REG_DT || v.VALID_FR_DY || '-');
      const to   = fmtDate(v.DSC_AVL_TO_DY || v.EXPR_DY || v.VALID_TO_DY || '-');
      const daysLeft = calcDaysLeft(to);

      const BD   = isBirthdayVoucher(v);
      const CS   = isComboSoloVoucher(v);
      const CD   = isComboDuoVoucher(v);
      const PC   = isPopcornVoucher(v);
      const used = isVoucherUsed(v);

      const cat = detectVoucherCategory(v);
      let catTxt = cat === 'MOVIE' ? chalk.cyan('MOVIE') : (cat === 'FNB' ? chalk.green('FNB') : chalk.gray('OTHER'));

      let tag = '-';
      if (BD && (CS || CD)) tag = `BIRTHDAY + ${CS ? 'COMBO SOLO' : 'COMBO DUO'}`;
      else if (CS)          tag = 'COMBO SOLO';
      else if (CD)          tag = 'COMBO DUO';
      else if (BD)          tag = 'BIRTHDAY';

      let tagTxt = (/^BIRTHDAY \+ COMBO /.test(tag)) ? chalk.magenta(tag)
                 : (tag==='COMBO SOLO'||tag==='COMBO DUO') ? chalk.yellow(tag)
                 : (tag==='BIRTHDAY') ? chalk.blueBright(tag)
                 : chalk.gray('-');

      if (SHOW_TABLES) {
        let tName = name;
        if (cat === 'MOVIE') tName = chalk.cyan(tName);
        else if (cat === 'FNB') tName = chalk.green(tName);
        else tName = chalk.white(tName);
        const usedTxt = used ? chalk.yellow('YES') : chalk.green('NO');
        perAccTable.push([i+1, tName, catTxt, tagTxt, usedTxt, from, to]);
      }

      // FILE OUTPUT â€” 7 jenis (UNUSED saja) + VIP (gabung)
      if (!used && PC && isFirstVisitPopcorn(v) && !wrotePopcornThisAccount) {
        fileRows.push({
          email,
          phone: nomorAkun,
          password,
          visits,
          tier: tierName,
          points,
          lastMovie,
          txnToday,
          type: 'SMALL SALTY',
          name,
          from,
          to,
          isBirthday: false,
          daysLeft
        });
        wrotePopcornThisAccount = true;
      }
      if (!used && CS) {
        fileRows.push({
          email,
          phone: nomorAkun,
          password,
          visits,
          tier: tierName,
          points,
          lastMovie,
          txnToday,
          type: 'COMBO SOLO',
          name,
          from,
          to,
          isBirthday: !!BD,
          daysLeft
        });
        wroteComboSoloThisAccount = true;
      }
      if (!used && CD) {
        fileRows.push({
          email,
          phone: nomorAkun,
          password,
          visits,
          tier: tierName,
          points,
          lastMovie,
          txnToday,
          type: 'COMBO DUO',
          name,
          from,
          to,
          isBirthday: !!BD,
          daysLeft
        });
        wroteComboDuoThisAccount = true;
      }
      if (!used && isTelkomselFlatprice10k(v)) {
        fileRows.push({
          email,
          phone: nomorAkun,
          password,
          visits,
          tier: tierName,
          points,
          lastMovie,
          txnToday,
          type: 'TELKOMSEL 10K',
          name,
          from,
          to,
          isBirthday: false,
          daysLeft
        });
        wroteTelkomselThisAccount = true;
      }
      if (!used && isThirdVisitB1G12D(v)) {
        fileRows.push({
          email,
          phone: nomorAkun,
          password,
          visits,
          tier: tierName,
          points,
          lastMovie,
          txnToday,
          type: 'B1G1 TICKET 2D (3rd VISIT)',
          name,
          from,
          to,
          isBirthday: false,
          daysLeft
        });
        wroteThirdVisitThisAccount = true;
      }
      if (!used && (isVIPPrivateBox50(v) || isVIPKitchenDrink(v))) {
        // internal marker 'VIP:' â†’ akan digabung saat flush (ditampilkan sebagai "VIP" saja)
        fileRows.push({
          email,
          phone: nomorAkun,
          password,
          visits,
          tier: tierName,
          points,
          lastMovie,
          txnToday,
          type: 'VIP:',
          name,
          from,
          to,
          isBirthday: false,
          daysLeft
        });
        hasVIPThisAccount = true;
      }
       // E-Voucher Complimentary Member Rewards (voucher GOLD) â€“ 1x per akun
      if (!used && isEVoucherComplimentaryRewards(v) && !wroteEVoucherGoldThisAccount) {
        fileRows.push({
          email,
          phone: nomorAkun,
          password,
          visits,
          tier: tierName,
          points,
          lastMovie,
          txnToday,
          type: 'E-VOUCHER GOLD',
          name,
          from,
          to,
          isBirthday: false,
          daysLeft
        });
        wroteEVoucherGoldThisAccount = true;
      }
      // E-VOUCHER: deteksi semua nominal (25K, 50K, 75K, 100K, 150K, dll)
      if (!used && isEVoucher(v) && !wroteEVoucherThisAccount) {
        const voucherValue = extractValue(v);

        fileRows.push({
          email,
          phone: nomorAkun,
          password,
          visits,
          tier: tierName,
          points,
          lastMovie,
          txnToday,
          type: `E-VOUCHER ${voucherValue}`,
          name,
          from,
          to,
          isBirthday: false,
          daysLeft
        });
        wroteEVoucherThisAccount = true;

        // Track per nominal
        if (!eVouchersByValue.has(voucherValue)) {
          eVouchersByValue.set(voucherValue, new Set());
        }
        eVouchersByValue.get(voucherValue).add(email.toLowerCase());
        eVoucherAccounts.add(email.toLowerCase());
      }

      // E-COUPON: deteksi semua nominal (25K, 50K, 75K, 100K, 150K, dll) - tidak butuh PIN
      if (!used && isECoupon(v) && !wroteECouponThisAccount) {
        const couponValue = extractValue(v);

        fileRows.push({
          email,
          phone: nomorAkun,
          password,
          visits,
          tier: tierName,
          points,
          lastMovie,
          txnToday,
          type: `E-COUPON ${couponValue}`,
          name,
          from,
          to,
          isBirthday: false,
          daysLeft
        });
        wroteECouponThisAccount = true;

        // Track per nominal
        if (!eCouponsByValue.has(couponValue)) {
          eCouponsByValue.set(couponValue, new Set());
        }
        eCouponsByValue.get(couponValue).add(email.toLowerCase());
        eCouponAccounts.add(email.toLowerCase());
      }

      if (BD && (CS || CD)) hasBDandCS = true;
    });

    if (SHOW_TABLES && perAccTable) console.log(perAccTable.toString());

    if (wrotePopcornThisAccount)   popcornAccCount++;
    if (wroteComboSoloThisAccount) comboSoloAccCount++;
    if (wroteComboDuoThisAccount)  comboDuoAccCount++;
    if (wroteTelkomselThisAccount) telkomselAccCount++;
    if (wroteThirdVisitThisAccount) thirdVisitAccCount++;
    if (hasBDandCS)                birthdayComboAccCnt++;
    if (hasVIPThisAccount)         vipAccCount++;

    console.log(chalk.green(`${label} âœ“ Done (vouchers: ${vouchers.length})`));
  };

  // worker pool
  let cursor = 0;
  const worker = async () => {
    const [lo, hi] = PER_WORKER_JITTER_MS;
    while (true) {
      const i = cursor++;
      if (i >= akunList.length) break;
      try {
        await processOne(akunList[i], i);
      } catch (e) {
        const label = `[ ${String(i+1).padStart(String(akunList.length).length,'0')}/${akunList.length} ]`;
        console.log(chalk.red(`${label} â†¯ Error: ${e.message}`));
      }
      totalChecked++;
      await delay(lo + Math.floor(Math.random()*(hi-lo)));
    }
  };
  await Promise.all(Array.from({ length: Math.min(ACCOUNT_CONCURRENCY, akunList.length) }, worker));

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     7) FLUSH FILE (sekali, gabungan semuanya â†’ checkVouchers.txt)
     (AUTO-FIT kolom; hapus kolom No & Valid From; jaga "NOMOR AKUN")
     â€” VIP digabung menjadi 1 tipe; di baris pertama VIP: tampil "VIP" (tanpa total)
     â€” Tambahan: tampilkan "(X hari lagi)" di kolom Expired
                 + blok khusus "VOUCHER SISA 1â€“20 HARI LAGI EXPIRED"
  ----------------------------------------------------------------*/
  try {
    const rowTypeRank = (r) => {
      const base = String(r.type || '');
      const name = String(r.name || '');
      const tier = String(r.tier || '');
      const lowerName = name.toLowerCase();
      const tierLower = tier.toLowerCase();

      // flag sama persis dengan logika getDisplayType
      const isBirthday =
        !!r.isBirthday ||
        /birthday/i.test(lowerName);

      const isGoldReward =
        !isBirthday && (
          /^gold\s*:/i.test(name) ||
          lowerName.includes('gold') ||
          tierLower.includes('gold')
        );

      // VIP Rewards khusus COMBO DUO non-birthday
      const isVipComboDuo =
        !isBirthday &&
        base === 'COMBO DUO' &&
        (
          tierLower.includes('vip') ||
          /^vip\s*:/i.test(name) ||
          lowerName.includes('vip')
        );

      // URUTAN YANG DIINGINKAN:
      //  0 = 1st Visit
      //  1 = 3rd Visit
      //  2 = Birthday Treat
      //  3 = Gold Rewards
      //  4 = VIP Rewards
      //  5 = Telkomsel 10K
      //  6 = E-Voucher (100K)
      //  7 = lain-lain (kalau ada)

      // 1st Visit (SMALL SALTY internal)
      if (base === 'SMALL SALTY') return 0;

      // 3rd Visit B1G1 2D
      if (base === 'B1G1 TICKET 2D (3rd VISIT)') return 1;

      // Birthday Treat (COMBO SOLO/DUO dengan flag birthday)
      if ((base === 'COMBO SOLO' || base === 'COMBO DUO') && isBirthday) return 2;

      // Gold Rewards (COMBO Gold + E-VOUCHER GOLD)
      if (isGoldReward || base === 'E-VOUCHER GOLD') return 3;

      // VIP Rewards (VIP: ... + COMBO DUO VIP)
      if (base.startsWith('VIP:') || isVipComboDuo) return 4;

      // Telkomsel 10K
      if (base === 'TELKOMSEL 10K' || base === 'TELKOMSEL 10K FLATPRICE') return 5;

      // E-Voucher 100K
      if (base === 'E-VOUCHER 100K') return 6;

      // fallback untuk tipe lain
      return 7;
    };

    // ğŸ‘‰ SUB-RANK KHUSUS GOLD (tanpa mengganggu struktur di atas)
    const goldSubRank = (r) => {
      const name = String(r.name || '');

      // 0 = Gold: Combo Solo (muncul duluan)
      if (/gold:\s*combo\s*solo/i.test(name)) return 0;

      // 1 = [E-Voucher] Complimentary Member Rewards
      if (/\[e-voucher\]/i.test(name) || /complimentary\s*member\s*rewards/i.test(name)) return 1;

      // 2 = lainnya (kalau ada)
      return 2;
    };



    // group per email
    const groupMap = new Map();
    for (const r of fileRows) {
      const key = String(r.email).toLowerCase();
      if (!groupMap.has(key)) groupMap.set(key, []);
      groupMap.get(key).push(r);
    }
    const groupEntries = Array.from(groupMap.entries()).map(([emailKey, rows]) => {
      const rank = Math.min(...rows.map(rowTypeRank));
      return { emailKey, rows, rank };
    });
    groupEntries.sort((a,b) => (a.rank - b.rank) || a.emailKey.localeCompare(b.emailKey));

    // group khusus: hanya voucher dengan sisa 1-30 hari
    const nearExpEntries = groupEntries
      .map(ge => {
        const sub = (ge.rows || []).filter(r => r.daysLeft != null && r.daysLeft >= 1 && r.daysLeft <= 30);
        if (!sub.length) return null;
        return { emailKey: ge.emailKey, rows: sub, rank: ge.rank };
      })
      .filter(Boolean);

    // ====== HELPER: DISPLAY TYPE (untuk kolom Type di output) ======
    const getDisplayType = (r) => {
      const base = String(r.type || '');
      const name = String(r.name || '');
      const tier = String(r.tier || '');
      const lowerName = name.toLowerCase();
      const tierLower = tier.toLowerCase();

      // 1st Visit popcorn (SMALL SALTY internal)
      if (base === 'SMALL SALTY') return '1st Visit';

      // 3rd Visit B1G1 2D
      if (base === 'B1G1 TICKET 2D (3rd VISIT)') return '3rd Visit';

      // COMBO SOLO / DUO â†’ Birthday / Gold / VIP / lain
      if (base === 'COMBO SOLO' || base === 'COMBO DUO') {
        const isBirthday = !!r.isBirthday || /birthday/i.test(lowerName);

        const isGoldReward =
          !isBirthday && (
            /^gold\s*:/i.test(name) ||
            lowerName.includes('gold') ||
            tierLower.includes('gold')
          );

        // VIP Rewards (khusus COMBO DUO non-birthday, dari tier VIP / nama voucher VIP)
        const isVipReward =
          !isBirthday && (
            tierLower.includes('vip') ||
            /^vip\s*:/i.test(name) ||
            lowerName.includes('vip')
          );

        if (isBirthday)                          return 'Birthday Treat';
        if (isGoldReward)                        return 'Gold Rewards';
        if (base === 'COMBO DUO' && isVipReward) return 'VIP Rewards';

        // fallback: COMBO SOLO / COMBO DUO (classic biasa)
        return base;
      }

      // E-Voucher 100K (Value) â†’ tampil sebagai "E-Voucher"
      if (base === 'E-VOUCHER 100K') return 'E-Voucher';

      // E-Voucher Complimentary Member Rewards â†’ "Gold Rewards"
      if (base === 'E-VOUCHER GOLD') return 'Gold Rewards';

      // Telkomsel 10K â†’ tampil Title Case
      if (base === 'TELKOMSEL 10K' || base === 'TELKOMSEL 10K FLATPRICE') return 'Telkomsel 10K';

      // VIP internal (Private Box, Kitchen-Concessions, dsb) â†’ â€œVIP Rewardsâ€
      if (base.startsWith('VIP:')) return 'VIP Rewards';

      return base || '-';
    };



    // ====== AUTO-FIT WIDTHS (tanpa 'No' & 'Valid From') ======
    const labels = {
      email: 'Email',
      phone: 'NOMOR AKUN',
      pwd: 'Password',
      visits: 'Visits',
      tier: 'Tier',
      pts: 'Points',
      lastmov: 'LastMovie',
      today: 'TxnToday',
      type: 'Type',
      vname: 'Voucher Name',
      exp: 'Expired'
    };

    // default widths (min) & caps (max)
    const MIN = {
      email: 28,
      phone: 14,
      pwd: 12,
      visits: 6,
      tier: 6,
      pts: 7,
      lastmov: 10,
      today: 8,
      type: 16,
      vname: 28,
      exp: 10
    };
    const MAX = {
      email: 56,
      phone: 30,
      pwd: 32,
      visits: 7,
      tier: 12,
      pts: 12,
      lastmov: 10,
      today: 8,
      type: 32,
      vname: 64,
      exp: 26          // lebih lebar untuk "YYYY-MM-DD (XX hari lagi)"
    };

    const need = { ...MIN };
    const scan = (s) => String(s ?? '');
    const upd = (key, val) => {
      need[key] = Math.min(MAX[key], Math.max(need[key], scan(val).length, labels[key].length));
    };

    for (const ge of groupEntries) {
      const rows = (ge.rows || []).slice().sort((a, b) => {
        const ar = rowTypeRank(a), br = rowTypeRank(b);
        if (ar !== br) return ar - br;

        // ğŸ‘‰ sama rank (sama-sama Gold Rewards), pakai sub-rank:
        const ga = goldSubRank(a), gb = goldSubRank(b);
        if (ga !== gb) return ga - gb;

        // kalau masih seri, baru pakai nama
        return (a.name || '').localeCompare(b.name || '');
      });
      if (!rows.length) continue;

      const f = rows[0];
      const firstDisplayType = getDisplayType(f);
      const firstExpCell = formatExpCell(f.to, f.daysLeft);

      upd('email', f.email);
      upd('phone', f.phone);
      upd('pwd', f.password);
      upd('visits', String(f.visits ?? 0));
      upd('tier', f.tier || '-');
      upd('pts', formatPoints(f.points));
      upd('lastmov', f.lastMovie || '-');
      upd('today', f.txnToday || 'X');
      upd('type', firstDisplayType || '-');
      upd('vname', f.name || '-');
      upd('exp', firstExpCell || '-');

      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        const typeMeasured = getDisplayType(r);
        const expCell = formatExpCell(r.to, r.daysLeft);
        upd('type', typeMeasured || '-');
        upd('vname', r.name || '-');
        upd('exp', expCell || '-');
      }
    }

    // helper clip untuk exact padding
    const clipExact = (s, w) => {
      const str = String(s ?? '');
      if (str.length < w) return str + ' '.repeat(w - str.length);
      if (w <= 1) return 'â€¦';
      return str.length === w ? str : (str.slice(0, w - 1) + 'â€¦');
    };

    const headerRowDyn = () =>
      `${clipExact(labels.email, need.email)}${SEP}${clipExact(labels.phone, need.phone)}${SEP}` +
      `${clipExact(labels.pwd, need.pwd)}${SEP}${clipExact(labels.visits, need.visits)}${SEP}` +
      `${clipExact(labels.tier, need.tier)}${SEP}${clipExact(labels.pts, need.pts)}${SEP}` +
      `${clipExact(labels.lastmov, need.lastmov)}${SEP}${clipExact(labels.today, need.today)}${SEP}` +
      `${clipExact(labels.type, need.type)}${SEP}${clipExact(labels.vname, need.vname)}${SEP}` +
      `${clipExact(labels.exp, need.exp)}${END}\n`;

    const buildLineDyn = (email, phone, pass, visits, tier, points, lastMovie, txnToday, type, name, expCell) =>
      `${clipExact(email, need.email)}${SEP}${clipExact(phone || '-', need.phone)}${SEP}` +
      `${clipExact(pass || '-', need.pwd)}${SEP}${clipExact(String(visits ?? 0), need.visits)}${SEP}` +
      `${clipExact(tier || '-', need.tier)}${SEP}${clipExact(formatPoints(points), need.pts)}${SEP}` +
      `${clipExact(lastMovie || '-', need.lastmov)}${SEP}${clipExact(txnToday || 'X', need.today)}${SEP}` +
      `${clipExact(type, need.type)}${SEP}${clipExact(name || '-', need.vname)}${SEP}` +
      `${clipExact(expCell || '-', need.exp)}${END}\n`;

    const buildContDyn = (type, name, expCell) =>
      `${clipExact('', need.email)}${SEP}${clipExact('', need.phone)}${SEP}` +
      `${clipExact('', need.pwd)}${SEP}${clipExact('', need.visits)}${SEP}` +
      `${clipExact('', need.tier)}${SEP}${clipExact('', need.pts)}${SEP}` +
      `${clipExact('', need.lastmov)}${SEP}${clipExact('', need.today)}${SEP}` +
      `${clipExact(type, need.type)}${SEP}${clipExact(name || '-', need.vname)}${SEP}` +
      `${clipExact(expCell || '-', need.exp)}${END}\n`;

    const WIDTH =
      need.email + SEP.length +
      need.phone + SEP.length +
      need.pwd + SEP.length +
      need.visits + SEP.length +
      need.tier + SEP.length +
      need.pts + SEP.length +
      need.lastmov + SEP.length +
      need.today + SEP.length +
      need.type + SEP.length +
      need.vname + SEP.length +
      need.exp + END.length;

    const HR = '-'.repeat(WIDTH) + '\n';
    const barLine = (text) => {
      const innerW = Math.max(0, WIDTH - 4); // kiri 'â”‚ ' + kanan ' â”‚'
      return `â”‚ ${clipExact(text, innerW)} â”‚\n`;
    };

    // helper baru: bungkus list nomor akun supaya rapi di dalam box
    const wrapPhones = (phones) => {
      const innerW = Math.max(0, WIDTH - 4);
      const lines = [];
      let current = '';
      for (const p of phones) {
        const token = String(p || '').trim();
        if (!token) continue;
        const candidate = current ? `${current},${token}` : token;
        if (candidate.length > innerW) {
          if (current) lines.push(barLine(current));
          current = token;
        } else {
          current = candidate;
        }
      }
      if (current) lines.push(barLine(current));
      return lines;
    };

    // ====== SUMMARY ======
    const totalAccounts = new Set(fileRows.map(r=>r.email.toLowerCase())).size || 0;
    const vipVouch = fileRows.filter(r=>String(r.type||'').startsWith('VIP:')).length; // total voucher VIP

    // hitung breakdown Combo Solo / Duo
    const firstVisitAccounts = new Set(
      fileRows.filter(r => r.type === 'SMALL SALTY').map(r => r.email.toLowerCase())
    ).size;

    const thirdVisitAccounts = new Set(
      fileRows.filter(r => r.type === 'B1G1 TICKET 2D (3rd VISIT)').map(r => r.email.toLowerCase())
    ).size;

    const comboSoloBirthdayAccounts = new Set(
      fileRows
        .filter(r => r.type === 'COMBO SOLO' && r.isBirthday)
        .map(r => r.email.toLowerCase())
    ).size;

    const comboSoloNonBirthdayRows = fileRows.filter(
      r => r.type === 'COMBO SOLO' && !r.isBirthday
    );

    const comboSoloGoldAccounts = new Set(
      comboSoloNonBirthdayRows
        .filter(r => {
          const nm = String(r.name || '').toLowerCase();
          const tierLower = String(r.tier || '').toLowerCase();
          return /^gold\s*:/i.test(r.name || '') || nm.includes('gold') || tierLower.includes('gold');
        })
        .map(r => r.email.toLowerCase())
    ).size;

    const comboDuoBirthdayAccounts = new Set(
      fileRows
        .filter(r => r.type === 'COMBO DUO' && r.isBirthday)
        .map(r => r.email.toLowerCase())
    ).size;

    // GOLD (voucher baru: [E-Voucher] 2D ALL DAYS Complimentary Member Rewards)
    const goldEVoucherAccounts = new Set(
      fileRows
        .filter(r => r.type === 'E-VOUCHER GOLD')
        .map(r => r.email.toLowerCase())
    ).size;

    // Combo Duo non-birthday kita kategorikan sebagai VIP Rewards
    const comboDuoVipAccounts = new Set(
      fileRows
        .filter(r => {
          if (r.type !== 'COMBO DUO' || r.isBirthday) return false;
          const nm = String(r.name || '').toLowerCase();
          const tierLower = String(r.tier || '').toLowerCase();
          return (
            tierLower.includes('vip') ||      // tier akun VIP
            /^vip\s*:/i.test(r.name || '') || // nama voucher diawali "VIP: ..."
            nm.includes('vip')                // text lain yg ada kata vip
          );
        })
        .map(r => r.email.toLowerCase())
    ).size;


    const summaryLines = [];
    summaryLines.push(HR);
    summaryLines.push(barLine(`Total Accounts                    : ${totalAccounts}`));
    summaryLines.push(HR);
    summaryLines.push(barLine(`1st Visit                         : ${firstVisitAccounts}`));
    summaryLines.push(barLine(`3rd Visit                         : ${thirdVisitAccounts}`));
    summaryLines.push(barLine(`Combo Solo (Birthday)             : ${comboSoloBirthdayAccounts}`));
    summaryLines.push(barLine(`Combo Solo (Gold)                 : ${comboSoloGoldAccounts}`));
    summaryLines.push(barLine(`Combo Duo (Birthday)              : ${comboDuoBirthdayAccounts}`));
    summaryLines.push(barLine(`Combo Duo (VIP)                   : ${comboDuoVipAccounts}`));
    summaryLines.push(barLine(`GOLD                              : ${goldEVoucherAccounts}`));
    summaryLines.push(barLine(`VIP                               : ${vipVouch}`));
    summaryLines.push(barLine(`Telkomsel 10K                     : ${new Set(fileRows.filter(r=>r.type==='TELKOMSEL 10K').map(r=>r.email.toLowerCase())).size}`));

    // E-Voucher per nominal (sorted by value)
    const eVoucherValues = Array.from(eVouchersByValue.keys()).sort((a, b) => {
      const numA = parseInt(a.replace('K', '')) || 0;
      const numB = parseInt(b.replace('K', '')) || 0;
      return numA - numB;
    });

    for (const value of eVoucherValues) {
      const count = eVouchersByValue.get(value).size;
      summaryLines.push(barLine(`E-Voucher ${value.padEnd(23)}  : ${count}`));
    }

    // Total E-Voucher (all values)
    summaryLines.push(barLine(`E-Voucher (Total)                 : ${eVoucherAccounts.size}`));

    // E-Coupon per nominal (sorted by value)
    const eCouponValues = Array.from(eCouponsByValue.keys()).sort((a, b) => {
      const numA = parseInt(a.replace('K', '')) || 0;
      const numB = parseInt(b.replace('K', '')) || 0;
      return numA - numB;
    });

    for (const value of eCouponValues) {
      const count = eCouponsByValue.get(value).size;
      summaryLines.push(barLine(`E-Coupon ${value.padEnd(24)}  : ${count}`));
    }

    // Total E-Coupon (all values)
    summaryLines.push(barLine(`E-Coupon (Total)                  : ${eCouponAccounts.size}`));
    summaryLines.push(HR);

    // === SEGMENT KOLUM 1:
    // nomor akun dengan visit tertinggi & belum transaksi hari ini (TxnToday != 'Y')
    // akun dengan Visits = 15 diletakkan di paling belakang
    const accountInfoMap = new Map();
    for (const ge of groupEntries) {
      const rows = ge.rows || [];
      if (!rows.length) continue;
      const r0 = rows[0];
      const key = String(r0.email || '').toLowerCase();
      if (!key) continue;
      if (!accountInfoMap.has(key)) {
        accountInfoMap.set(key, {
          email:  r0.email,
          phone:  r0.phone,
          visits: Number(r0.visits ?? 0),
          txnToday: r0.txnToday || 'X'
        });
      }
    }

    const visitAccounts = [];
    const specialVisit15 = [];

    for (const info of accountInfoMap.values()) {
      const txn = String(info.txnToday || 'X').toUpperCase();
      if (txn === 'Y') continue;          // sudah transaksi hari ini â†’ skip
      if (!info.phone) continue;          // ga ada nomor akun â†’ skip

      if (info.visits === 15) {
        // akun visit 15 (misal VIP) â†’ dimasukkan tapi diletakkan paling belakang
        specialVisit15.push(info);
      } else {
        visitAccounts.push(info);
      }
    }

    // urutkan utama: visits desc, lalu phone asc
    visitAccounts.sort((a, b) => {
      if (b.visits !== a.visits) return b.visits - a.visits;
      return String(a.phone).localeCompare(String(b.phone));
    });

    const visitPhones = [...visitAccounts, ...specialVisit15].map(i => i.phone);

    const visitSegmentLines = [];
    if (visitPhones.length) {
      visitSegmentLines.push('\n');
      visitSegmentLines.push(HR);
      visitSegmentLines.push(
        barLine('NOMOR AKUN DENGAN VISIT TERTINGGI & BELUM TRANSAKSI HARI INI')
      );
      visitSegmentLines.push(HR);

      // ğŸ”¹ Baris nomor akun TANPA â”‚ biar gampang di-copy
      visitSegmentLines.push(visitPhones.join(',') + '\n');

      visitSegmentLines.push(HR);
    }

    // ====== BODY UTAMA =========
    const bodyLines = [];
    bodyLines.push(headerRowDyn());
    bodyLines.push(HR);

    for (const ge of groupEntries) {
      const rows = (ge.rows || []).slice().sort((a, b) => {
        const ar = rowTypeRank(a), br = rowTypeRank(b);
        if (ar !== br) return ar - br;

        const ga = goldSubRank(a), gb = goldSubRank(b);
        if (ga !== gb) return ga - gb;

        return (a.name || '').localeCompare(b.name || '');
      });
      if (!rows.length) continue;

      const first = rows[0];
      const firstExpCell = formatExpCell(first.to, first.daysLeft);
      const firstDisplayType = getDisplayType(first);

      bodyLines.push(
        buildLineDyn(
          first.email,
          first.phone,
          first.password,
          first.visits,
          first.tier,
          first.points,
          first.lastMovie,
          first.txnToday,
          firstDisplayType,
          first.name,
          firstExpCell
        )
      );

      let vipHeaderPrinted = String(first.type || '').startsWith('VIP:');
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        const expCell = formatExpCell(r.to, r.daysLeft);
        const isVIP = String(r.type || '').startsWith('VIP:');
        const dispType = getDisplayType(r);

        if (isVIP) {
          if (!vipHeaderPrinted) {
            // baris VIP pertama untuk email ini â†’ tulis "VIP"
            bodyLines.push(buildContDyn(dispType, r.name, expCell));
            vipHeaderPrinted = true;
          } else {
            // baris VIP berikutnya â†’ kolom Type kosong
            bodyLines.push(buildContDyn('', r.name, expCell));
          }
        } else {
          bodyLines.push(buildContDyn(dispType, r.name, expCell));
        }
      }

      bodyLines.push(HR);
    }

    // ====== BODY 2: VOUCHER SISA 1â€“20 HARI LAGI EXPIRED ======
    const nearLines = [];
    if (nearExpEntries.length) {
      nearLines.push('\n'); // spasi 1 baris sebelum blok kedua
      nearLines.push(HR);
      nearLines.push(barLine('VOUCHER SISA 1â€“30 HARI LAGI EXPIRED'));
      nearLines.push(HR);
      nearLines.push(headerRowDyn());
      nearLines.push(HR);

      // Flatten semua row yg 1â€“20 hari lagi expired â†’ sort by daysLeft ASC
      const flatNear = [];
      for (const ge of nearExpEntries) {
        for (const r of ge.rows || []) {
          if (r.daysLeft == null) continue;
          flatNear.push(r);
        }
      }

      flatNear.sort((a, b) => {
        const da = a.daysLeft ?? Infinity;
        const db = b.daysLeft ?? Infinity;
        if (da !== db) return da - db;                // paling dekat expired di atas
        const ar = rowTypeRank(a), br = rowTypeRank(b);
        if (ar !== br) return ar - br;                // tie-break pakai rank type
        const ea = String(a.email || '').toLowerCase();
        const eb = String(b.email || '').toLowerCase();
        if (ea !== eb) return ea.localeCompare(eb);   // lalu email
        return (a.name || '').localeCompare(b.name || ''); // terakhir nama voucher
      });

      let lastEmailKey = null;
      let vipHeaderPrinted2 = false;
      let firstGroup = true;

      for (const r of flatNear) {
        const emailKey = String(r.email || '').toLowerCase();
        const isVIP = String(r.type || '').startsWith('VIP:');
        const expCell = formatExpCell(r.to, r.daysLeft);
        const dispType = getDisplayType(r);

        if (emailKey !== lastEmailKey) {
          // email baru â†’ tutup group sebelumnya dengan HR
          if (!firstGroup) nearLines.push(HR);
          firstGroup = false;

          nearLines.push(
            buildLineDyn(
              r.email,
              r.phone,
              r.password,
              r.visits,
              r.tier,
              r.points,
              r.lastMovie,
              r.txnToday,
              dispType,
              r.name,
              expCell
            )
          );

          lastEmailKey = emailKey;
          vipHeaderPrinted2 = isVIP;
        } else {
          // email sama â†’ baris lanjutan (kolom kiri dikosongkan)
          if (isVIP) {
            if (!vipHeaderPrinted2) {
              nearLines.push(buildContDyn(dispType, r.name, expCell)); // 'VIP'
              vipHeaderPrinted2 = true;
            } else {
              nearLines.push(buildContDyn('', r.name, expCell));
            }
          } else {
            nearLines.push(buildContDyn(dispType, r.name, expCell));
          }
        }
      }

      // HR terakhir penutup blok
      nearLines.push(HR);

      // === SEGMENT KOLUM 2:
      // nomor akun yang sudah mau mendekati expired 1â€“20 hari (urut dari paling dekat)
      const phoneSeen = new Set();
      const nearPhones = [];
      for (const r of flatNear) {
        const p = r.phone;
        if (!p) continue;
        if (phoneSeen.has(p)) continue;
        phoneSeen.add(p);
        nearPhones.push(p);
      }

      if (nearPhones.length) {
        nearLines.push('\n');
        nearLines.push(HR);
        nearLines.push(barLine('NOMOR AKUN YANG SUDAH MAU MENDEKATI EXPIRED 1â€“30 HARI'));
        nearLines.push(HR);

        // ğŸ”¹ Baris nomor akun TANPA â”‚ biar gampang di-copy
        nearLines.push(nearPhones.join(',') + '\n');

        nearLines.push(HR);
      }
    }

    // TULIS FILE â€” TANPA BLOK "FORMAT BUAT DICOPY PASTE"
    await fs.writeFile(
      'checkVouchers.txt',
      [...summaryLines, ...bodyLines, ...visitSegmentLines, ...nearLines].join(''),
      'utf-8'
    );

  } catch (e) {
    console.log(chalk.red(`[-] Gagal tulis checkVouchers.txt: ${e.message}`));
  }

  // ====== BATCH WRITE account.json (SEKALI DI AKHIR) ======
  try {
    await fs.writeFile('account.json', JSON.stringify(accountJson, null, 2), 'utf-8');
  } catch (e) {
    console.log(chalk.red(`[-] Gagal update account.json: ${e.message}`));
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     8) SUMMARY (console)
  ----------------------------------------------------------------*/
  // Build E-Voucher summary string
  let eVoucherSummary = '';
  if (eVouchersByValue.size > 0) {
    const eVoucherParts = [];
    for (const [value, accounts] of eVouchersByValue.entries()) {
      eVoucherParts.push(`${value}: ${accounts.size}`);
    }
    eVoucherSummary = ` | E-Voucher (${eVoucherParts.join(', ')})`;
  } else {
    eVoucherSummary = ` | E-Voucher: 0`;
  }

  // Build E-Coupon summary string
  let eCouponSummary = '';
  if (eCouponsByValue.size > 0) {
    const eCouponParts = [];
    for (const [value, accounts] of eCouponsByValue.entries()) {
      eCouponParts.push(`${value}: ${accounts.size}`);
    }
    eCouponSummary = ` | E-Coupon (${eCouponParts.join(', ')})`;
  } else {
    eCouponSummary = ` | E-Coupon: 0`;
  }

  console.log(chalk.cyanBright(
    `\n[SUMMARY] Accounts checked: ${totalChecked}` +
    ` | 1st Visit (Popcorn): ${popcornAccCount}` +
    ` | 3rd Visit B1G1 2D: ${thirdVisitAccCount}` +
    ` | Combo SOLO: ${comboSoloAccCount}` +
    ` | BIRTHDAY + COMBO SOLO/DUO: ${birthdayComboAccCnt}` +
    ` | Combo DUO: ${comboDuoAccCount}` +
    ` | VIP (accounts): ${vipAccCount}` +
    ` | Telkomsel 10K FLATPRICE: ${telkomselAccCount}` +
    eVoucherSummary +
    eCouponSummary
  ));
  console.log(chalk.gray('\n[âœ“] Selesai cek voucher â€“ tekan Enter untuk kembali ke menu.'));
  await inquirer.prompt([{ type:'input', name:'pause', message:'' }]);
}





























// new update
/* ================================================================
   LIST ACCOUNTS â€” PRO (akunLogin.txt only, bearer cache, auto-check all)
   PERUBAHAN (REVISION: account.json-only source & env passwords)
   - Sumber akun: HANYA dari account.json (email + password); tidak lagi bergantung akunLogin.txt
   - Password candidates: ENV DEFAULT_PASSWORDS (comma-separated) + password dari account.json (email tsb)
   - Update account.json: NON-DESTRUCTIVE (tidak regenerate / reindex / ubah generated_at)
     â€¢ Jika login sukses dengan password berbeda â†’ update field password (+ password_updated_at)
     â€¢ Jika bearer expired/invalid â†’ update hanya trio bearer (bearer, bearer_wrapped, bearer_updated_at)
     â€¢ Field lain (profil, points, dsb) di-update di item yang sama TANPA mengubah struktur/urutan/nomor/no
   - Update file dilakukan **sekali di akhir** (single atomic write) agar tidak balapan menulis
   - Selesai proses: auto-tulis ulang akunLogin.txt dengan format:
       email (35) | password (14) | phone (max 16) | 121212
     phone ambil dari data info (MOBILE_NO) atau fallback dari account.json
   - SELURUH struktur & flow utama (tabel, allaccounts.txt, ringkasan voucher, concurrency, random headers,
     timeout/heartbeat, dsb) dipertahankan sesuai kode sebelumnya

   (TAMBAHAN: NOT FOUND FLOW)
   - Deteksi â€œMember/Account not foundâ€
   - Tandai di account.json: not_found=true, account_status="not_found", not_found_at
   - Append ke notfound.json (auto-buat): name,email,phone,password,pin,ts (tanpa overwrite)
   - Auto-skip akun bertanda not_found di run berikutnya
   - Ringkasan akhir: tabel akun not_found sesi ini

   (BARU: GRADE REWARD â€” VIP ONLY)
   - Saat cek akun, KHUSUS Tier VIP â†’ GET /membership/grade-reward
     â€¢ Kalau ada reward: tandai "Tersedia (N opsi)" di kolom GradeRw
     â€¢ Kalau tidak: "Tidak ada"
   - Setelah semua akun selesai:
     â€¢ Jika ada minimal satu VIP dengan reward tersedia â†’ prompt interaktif:
       - Konfirmasi Mau Redeem Sekarang?
       - Pilih akun VIP yg punya reward
       - Tampilkan Grade Info VIP (GET /membership/grade-info) + list opsi reward (ID + ringkasan nama)
       - Pilih ID â†’ POST /membership/select-reward â†’ verifikasi ulang GET /grade-reward
       - Bisa lanjut akun lain atau Selesai / Tutup
     â€¢ Jika tidak ada reward di semua VIP â†’ tampilkan info ringkas â€œTidak ada grade reward tersediaâ€

   (UPDATE DIMINTA USER):
   - Tambahkan kolom Combo Duo dan DuoUsed di header/file allaccounts.txt dan setiap row.
   - Tambahkan blok segment akun yang SUDAH >30 hari (AgeD >= 30), belum transaksi sama sekali, visits=0.
     â€¢ Kasih header dan CSV nomor HP terpisah.
   - Daftar akun yang masih punya voucher Combo Solo / Combo Duo aktif & belum pernah dipakai:
     â€¢ Kumpulkan dan tampilkan setelah segment-segment.
     â€¢ Prefix tipe campaign (misal 'Birthday Treat: Combo Solo' â†’ type=Birthday Treat).
     â€¢ Combo Solo dan Combo Duo dipisah.
     â€¢ Hanya akun dengan has_active=true dan used_times=0 untuk masing-masing tipe.
   - allaccounts.txt tidak boleh ada console log di awal file.

   Catatan:
   â€¢ Data nama voucher + tipe campaign untuk Combo Solo / Combo Duo diambil dari voucher_details_active tiap akun.
     Combo Solo: regex /combo\s*solo/i
     Combo Duo : regex /combo\s*duo/i
   â€¢ Kita anggap DuoUsed paralel dengan ComboUsed, tapi pakai detektor baru detectComboDuoUsage()
     dan status detectComboDuoStatus().

   ================================================================ */
async function listAccounts() {
  console.clear();
  console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.cyan('â•‘                         LIST ACCOUNTS                        â•‘'));
  console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));

  // ====== TUNING SPEED ======
  const DELAY_EMPTY_FILE_MS   = 400;
  const PER_ACCOUNT_DELAY_MS  = 10;
  const RETRY_INFO_BACKOFF_MS = 800;

  // ====== CONCURRENCY & HEADER RANDOMIZATION ======
  const CONCURRENCY = 10; // 10 akun sekaligus per sesi
  const RANDOMIZE_HEADERS_PER_ACCOUNT = true; // per akun, bukan per sesi

  // â”€â”€ util random
  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];

  // UA aman (persona app) â€” variasikan versi okhttp saja
  const randomOkHttpUA = () => {
    const vers = choice(['4.9.3','4.10.0','4.11.0','4.12.0']);
    return `okhttp/${vers}`;
  };
  const randomLang = () => choice([
    'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
    'id,en-US;q=0.9,en;q=0.8',
    'en-US,en;q=0.9,id;q=0.8',
    'id-ID,en;q=0.9'
  ]);

  // Header â€œamanâ€ per akun (tanpa device/x-forwarded-for)
  const makeAccountHeaders = () => ({
    'accept': 'application/json, text/plain, */*',
    'accept-encoding': 'gzip',
    'accept-language': randomLang(),
    'user-agent': randomOkHttpUA(),
    'connection': 'Keep-Alive'
  });

  // Merge helper
  const mergeHeaders = (base, extra) => {
    const out = { ...(base || {}) };
    for (const k of Object.keys(extra || {})) out[k.toLowerCase()] = extra[k];
    return out;
  };

  // ========== Anti-stuck helpers ==========
  const withTimeout = (promise, ms, label = 'Timeout') =>
    Promise.race([
      promise,
      new Promise((_, rej) => setTimeout(() => rej(new Error(label)), ms))
    ]);

  const delay = (ms)=>new Promise(r=>setTimeout(r,ms));

  const fetchWithTimeout = async (url, opts, timeoutMs = 15000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      return await fetch(url, { ...opts, signal: ctrl.signal });
    } finally {
      clearTimeout(t);
    }
  };

  // ====== VISUAL TUNING: BdayLeft Thresholds ======
  const BLEFT_GREEN_MAX   = 7;
  const BLEFT_YELLOW_MAX  = 30;
  const BLEFT_CYAN_MAX    = 30;  // tidak dipakai, tetap agar tidak error
  const BLEFT_OVER30_COLOR = 'red'; // 'dim' | 'red' | 'none'
  const BLEFT_LABEL = 'Hari'; // 'Hari' | 'Days'

  const padN = (n,w) => String(n).padStart(w,'0');
  const normEmail = s => String(s||'').trim().toLowerCase();
  const padR = (s, w) => { const x = String(s ?? ''); return x.length >= w ? x : (x + ' '.repeat(w - x.length)); };

  // [ADDED] Nomor-only: simpan digit & huruf 'x' (mask) saja
  const phoneNomorOnly = (p) => {
    return String(p ?? '')
      .replace(/[^\dx]/gi, '')   // keep angka & 'x'
      .replace(/\s+/g, '')       // hapus spasi
      .toLowerCase();            // x â†’ lowercase
  };

  const todayYmd = (() => {
    const d = new Date();
    const p = n => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`;
  })();

  // ====== EXPIRATION DATE HELPERS (from checkvouchers.js) ======
  const parseIsoYmd = (s) => {
    const str = String(s || '').trim();
    const m = /^(\d{4})-(\d{2})-(\d{2})/.exec(str);
    if (!m) return null;
    const d = new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));
    return isNaN(d) ? null : d;
  };

  const calcDaysLeft = (ymd) => {
    const exp = parseIsoYmd(ymd);
    const today = parseIsoYmd(todayYmd);
    if (!exp || !today) return null;
    const ms = exp.getTime() - today.getTime();
    return Math.round(ms / 86400000);
  };

  const formatExpCell = (ymd, daysLeft) => {
    const base = ymd || '-';
    if (daysLeft == null || !isFinite(daysLeft)) return base;
    if (daysLeft < 0) return `${base} (EXPIRED)`;
    if (daysLeft === 0) return `${base} (HARI INI)`;
    return `${base} (${daysLeft} hari lagi)`;
  };

  const fmtDate = d => /^[0-9]{8}$/.test(d)
    ? `${d.slice(0,4)}-${d.slice(4,6)}-${d.slice(6)}`
    : (d || '-');

  const wrapBearer3 = (token) => {
    const s = String(token || '');
    if (!s) return [];
    const partLen = Math.ceil(s.length / 3);
    return [ s.slice(0, partLen), s.slice(partLen, partLen*2), s.slice(partLen*2) ];
  };

  // ====== NOT FOUND FLOW ======
  const NOTFOUND_FILE = 'notfound.json';
  const PIN_DEFAULT = '121212';
  const notFoundBuffer = []; // {email,name,phone,password,pin,ts}
  const pushNotFound = (rec) => notFoundBuffer.push({ ...rec, ts: new Date().toISOString() });

  // â”€â”€ baca account.json (cache bearer & password) â€” NON-DESTRUCTIVE
  let accountCache = null;
  try {
    const raw = await fs.readFile('account.json', 'utf-8');
    accountCache = JSON.parse(raw);
  } catch {}
  if (!accountCache || !Array.isArray(accountCache.items)) {
    console.log(chalk.red('âŒ  Tidak menemukan account.json atau properti items tidak valid.'));
    await delay(DELAY_EMPTY_FILE_MS);
    return;
  }
  // peta bearer & password & phone & name dari account.json (apa adanya)
  const bearerMap = new Map(); // email(lower) -> token
  const passMap   = new Map(); // email(lower) -> password
  const phoneMap  = new Map(); // email(lower) -> phone (untuk ekspor akunLogin.txt)
  const nameMap   = new Map(); // email(lower) -> name (untuk notfound.json)
  for (const it of (accountCache.items || [])) {
    if (it.email && it.bearer) bearerMap.set(normEmail(it.email), String(it.bearer));
    if (it.email && it.password) passMap.set(normEmail(it.email), String(it.password));
    if (it.email && it.phone) phoneMap.set(normEmail(it.email), String(it.phone));
    if (it.email && it.name) nameMap.set(normEmail(it.email), String(it.name));
  }

  // â”€â”€ muat daftar akun dari account.json saja + SKIP akun not_found
  const rawItems = (accountCache.items || [])
    .filter(x => x && x.email && String(x.email).includes('@'));

  const akunList = rawItems
    .filter(x => !(x.not_found === true || x.account_status === 'not_found' || String(x.status||'').toLowerCase()==='not_found'))
    .map(x => ({ email: x.email, password: x.password }));

  if (!akunList.length) {
    // jika semua skip, tetap tampilkan daftar email untuk konteks
    const Table0 = await universalTable();
    const t0 = new Table0({ head:['No','Email (skipped/not_found)'], colWidths:[6,58], wordWrap:true, style:{head:['yellow']} });
    rawItems.forEach((a,i)=>t0.push([padN(i+1,2), a.email]));
    console.log(t0.toString());
    console.log(chalk.gray(`Total accounts (after skip not_found): 0\n`));
    await delay(DELAY_EMPTY_FILE_MS);
    return;
  }

  // preview SEMUA (tanpa prompt)
  {
    const Table = await universalTable();
    const t = new Table({ head:['No','Email'], colWidths:[6,58], wordWrap:true, style:{head:['yellow']} });
    akunList.forEach((a,i)=>t.push([padN(i+1,2), a.email]));
    console.log(t.toString());
    console.log(chalk.gray(`Total accounts: ${akunList.length}\n`));
  }

  // â”€â”€ util ringkas & retry logic
  const reasonFromLoginError = (res) => {
    const sc = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    if (/member\s*not\s*found|account\s*not\s*found|not\s*found/.test(msg) || sc === 404) return 'Account not found';
    if (typeof looksWrongPassword === 'function' && looksWrongPassword(res)) return 'Wrong password';
    if (/invalid credential|invalid password|wrong password/.test(msg) || sc === 401) return 'Wrong password';
    if (sc === 429 || /too many|rate limit/.test(msg))      return 'Rate limited (429)';
    if (/timeout|network|fetch fail|networkerror|timed out/.test(msg)) return 'Network/Timeout';
    if (/non-json response/.test(msg))                      return 'Anti-bot/gateway (non-JSON)';
    if (sc >= 500)                                          return `Server error (${sc})`;
    if (sc && sc !== 200)                                   return `HTTP ${sc}`;
    return 'Unknown login error';
  };
  const isRetryable = (res) => {
    const sc = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    if (/invalid credential|invalid password|wrong password/.test(msg) || sc === 401) return false;
    if (/member\s*not\s*found|account\s*not\s*found|not\s*found/.test(msg) || sc === 404) return false;
    if (typeof looksWrongPassword === 'function' && looksWrongPassword(res)) return false;
    return (
      sc === 429 ||
      (sc >= 500) ||
      /timeout|network|fetch fail|networkerror|timed out/.test(msg) ||
      /non-json response/.test(msg)
    );
  };

  // â”€â”€ tanggal helpers
  const d8 = s => /^\d{8}$/.test(s) ? `${s.slice(0,4)}-${s.slice(4,6)}-${s.slice(6)}` : '-';
  const ageDaysFromD8 = (s) => {
    if (!/^\d{8}$/.test(s)) return '-';
    const y = Number(s.slice(0,4)), m = Number(s.slice(4,6))-1, d = Number(s.slice(6,8));
    const start = new Date(y, m, d);
    const today = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate());
    const diff  = Math.floor((today - start) / 86400000);
    return diff >= 0 ? String(diff) : '-';
  };

  // (BARU) sisa hari menuju ulang tahun berikutnya
  const daysUntilNextBirthday = (isoYmd) => {
    if (!isoYmd || isoYmd === '-' || !/^\d{4}-\d{2}-\d{2}$/.test(isoYmd)) return '-';
    const [y,m,d] = isoYmd.split('-').map(n=>Number(n));
    const today = new Date();
    const yearNow = today.getFullYear();
    const isLeap = (yr) => (yr%4===0 && yr%100!==0) || (yr%400===0);
    const mm = (m===2 && d===29 && !isLeap(yearNow)) ? 2 : m;
    const dd = (m===2 && d===29 && !isLeap(yearNow)) ? 28 : d;
    const atStartOfDay = (dt) => new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
    let next = new Date(yearNow, mm-1, dd);
    const t0 = atStartOfDay(today).getTime();
    if (next.getTime() < t0) {
      const yearNext = yearNow + 1;
      const mm2 = (m===2 && d===29 && !isLeap(yearNext)) ? 2 : m;
      const dd2 = (m===2 && d===29 && !isLeap(yearNext)) ? 28 : d;
      next = new Date(yearNext, mm2-1, dd2);
    }
    const diffMs = atStartOfDay(next).getTime() - t0;
    return Math.max(0, Math.round(diffMs / 86400000));
  };

  // â”€â”€ formatter angka (id-ID)
  const fmtID = (val) => {
    if (val === '-' || val === null || val === undefined) return '-';
    const num = Number(val);
    if (!Number.isFinite(num)) return String(val);
    try { return num.toLocaleString('id-ID'); }
    catch { return String(Math.trunc(num)).replace(/\B(?=(\d{3})+(?!\d))/g, '.'); }
  };

  // â”€â”€ pewarnaan util
  const colorGold   = (s) => (chalk.hex ? chalk.hex('#FFD700')(s) : chalk.yellowBright(s));
  const colorSilver = (s) => (chalk.hex ? chalk.hex('#C0C0C0')(s) : chalk.gray(s));
  const colorClassic= (s) => chalk.blueBright(s);
  const colorTier = (tierName) => {
    const t = String(tierName || '').trim();
    const low = t.toLowerCase();
    if (/vip|platinum|diamond/.test(low)) return colorSilver(t);
    if (/gold/.test(low))                 return colorGold(t);
    if (/classic|member|regular|new/.test(low)) return colorClassic(t);
    if (/silver/.test(low))               return colorSilver(t);
    return t;
  };
  const colorVisits = (visits, goldMin, vipMin) => {
    const v = Number(visits);
    const g = Number.isFinite(Number(goldMin)) && goldMin > 0 ? goldMin : 8;
    const p = Number.isFinite(Number(vipMin))  && vipMin  > 0 ? vipMin  : Infinity;
    if (v >= p && p !== Infinity) return colorSilver(String(v));
    if (v >= g) return colorGold(String(v));
    return String(v);
  };
  const colorNeedMoney = (v) => (v === '-' ? '-' : (Number(v) <= 0 ? chalk.green('OK') : fmtID(v)));
  const colorNeedVisit = (v) => (v === '-' ? '-' : (Number(v) <= 0 ? chalk.green('OK') : `${v}x`));

  // (BARU) humanizer BLeft plain text "31 Hari"/"31 Days"
  const bleftWord = (n) => {
    const lbl = String(BLEFT_LABEL || '').toLowerCase();
    if (lbl === 'days') return n === 1 ? 'Day' : 'Days';
    return 'Hari';
  };
  const renderBLeftPlain = (v) => {
    if (v === '-' || v === null || v === undefined) return '-';
    const n = Number(v);
    if (!Number.isFinite(n)) return String(v);
    if (n === 0) return 'TODAY';
    return `${n} ${bleftWord(n)}`;
  };

  // angka dengan awareness voucher
  const colorUsagePresence = (count, hasActive) => {
    const c = Number(count || 0);
    if (hasActive) return chalk.green(String(c));
    if (c > 0)     return chalk.yellow(String(c));
    return chalk.red('0');
  };

  // warna BLeft
  const colorBLeft = (v) => {
    if (v === '-' || v === null || v === undefined) return '-';
    const n = Number(v);
    if (!Number.isFinite(n)) return String(v);
    if (n === 0) return chalk.black.bgGreen('TODAY');
    const txt = `${n} ${bleftWord(n)}`;
    if (n <= BLEFT_GREEN_MAX)  return chalk.green(txt);
    if (n <= BLEFT_YELLOW_MAX) return chalk.yellow(txt);
    if (BLEFT_OVER30_COLOR === 'red') return chalk.red(txt);
    if (BLEFT_OVER30_COLOR === 'dim') return chalk.gray(txt);
    return txt;
  };

  // ==== Voucher helpers
  const deepPick = (obj, candidates) => {
    for (const key of candidates) {
      if (!key) continue;
      const path = String(key).split('.');
      let cur = obj, ok = true;
      for (const p of path) {
        if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
        else { ok = false; break; }
      }
      if (!ok) continue;
      if (cur !== undefined && cur !== null && !(typeof cur === 'string' && cur.trim() === '')) return cur;
    }
    return null;
  };
  const parseDateAny = (x) => {
    if (x === null || x === undefined) return null;
    if (typeof x === 'number') {
        const ms = x > 1e12 ? x : x * 1000;
        const d = new Date(ms); return isNaN(d) ? null : d;
    }
    const s = String(x).trim(); if (!s) return null;
    if (/^\d{14}$/.test(s)) {
      const y=s.slice(0,4), m=s.slice(4,6), d=s.slice(6,8), H=s.slice(8,10), M=s.slice(10,12), S=s.slice(12,14);
      const dt = new Date(Number(y), Number(m)-1, Number(d), Number(H), Number(M), Number(S));
      return isNaN(dt) ? null : dt;
    }
    if (/^\d{8}$/.test(s))  {
      const y=s.slice(0,4), m=s.slice(4,6), d=s.slice(6,8);
      const dt = new Date(Number(y), Number(m)-1, Number(d), 0,0,0);
      return isNaN(dt) ? null : dt;
    }
    const d = new Date(s); return isNaN(d) ? null : d;
  };
  const toIsoLocal = (x) => {
    const d = parseDateAny(x); if (!d) return null;
    const pad = (n) => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  };
  const adjustEndInclusive = (rawVal) => {
    if (rawVal == null) return null;
    const s = String(rawVal).trim();
    const d = parseDateAny(rawVal);
    if (!d) return null;
    const isDayOnly = /^\d{8}$/.test(s) || /^\d{4}-\d{2}-\d{2}$/.test(s);
    const isMidnight = d.getHours()===0 && d.getMinutes()===0 && d.getSeconds()===0;
    if (isDayOnly || isMidnight) {
      const adj = new Date(d);
      adj.setHours(23,59,59,999);
      return adj;
    }
    return d;
  };
  const normalizeRawStatusText = (txt) => {
    if (!txt) return null;
    const s = String(txt).toLowerCase();
    if (/used|redeem|redeemed|terpakai|dipakai/.test(s)) return 'USED';
    if (/expire|expired|kadaluarsa|hangus|void|invalid|cancel/.test(s)) return 'EXPIRED';
    if (/not.*yet.*valid|belum.*berlaku/.test(s)) return 'NOT_YET_VALID';
    if (/valid|aktif|active/.test(s)) return 'ACTIVE';
    return null;
  };
  const computeStatus = (v) => {
    const useYN  = deepPick(v, ['USE_YN','use_yn','USED_YN','USE_YN_CD','USE_YN_NM']);
    const usedAt = deepPick(v, ['USE_DTTM','REDM_DTTM','REDEEM_DTTM','REDEEM_DT','USE_DT']);
    const rawTxt = deepPick(v, ['CPN_STAT_NM','STAT_NM','STATUS_NM','CPN_STAT_TXT','STAT_TXT','GFTCERT_STAT_NM','STATUS','CPN_USE_STAT','CPN_STAT_CD_NM']);
    const startRaw = deepPick(v, [
      'PUB_STR_DTTM','PUB_START_DTTM','VALID_START_DTTM','VALID_BGNG_DTTM','VLD_BGNG_DTTM','USE_STR_DTTM',
      'DSC_AVL_FR_DY','ISSUE_DY','REG_DTTM','START_DY','VALID_FR_DT','VALID_STRT_DT','VALID_FR_DY','VLD_FR_DY','BEGIN_DTTM','APPL_FR_DT','GFCERT_REG_DT',
      'SALE_DSC_APL_FR_DY','SCN_DSC_APL_FR_DY'
    ]);
    const endRaw = deepPick(v, [
      'PUB_END_DTTM','VALID_END_DTTM','VALID_TO_DTTM','VLD_END_DTTM','USE_END_DTTM',
      'DSC_AVL_TO_DY','EXP_DY','EXPR_DTTM','EXPR_DY','EXPIRE_DY','END_DY','VALID_TO_DT','VALID_TO_DY','VLD_TO_DY','END_DTTM','APPL_TO_DT',
      'SALE_DSC_APL_TO_DY','SCN_DSC_APL_TO_DY'
    ]);
    const start = parseDateAny(startRaw);
    const end   = adjustEndInclusive(endRaw);
    const useStr = useYN == null ? '' : String(useYN).trim().toUpperCase();
    const used = ['1','Y','YES','USED','T','TRUE'].includes(useStr) || (usedAt !== null && String(usedAt).trim() !== '');
    if (used) return { label: 'USED', startRaw, endRaw, rawTxt, endAdj: end };
    if (end && new Date() > end)   return { label: 'EXPIRED', startRaw, endRaw, rawTxt, endAdj: end };
    if (start && new Date() < start) return { label: 'NOT_YET_VALID', startRaw, endRaw, rawTxt, endAdj: end };
    const guessed = normalizeRawStatusText(rawTxt);
    return { label: guessed || 'ACTIVE', startRaw, endRaw, rawTxt, endAdj: end };
  };
  const normalizeVoucher = (v, kind) => {
    const name = deepPick(v, ['DSC_NM','GFTCERT_NM','CPN_NM','GFT_NM','TTL_NM','TITLE_NM','PROMO_NM']) || '-';
    const code =
      deepPick(v, [
        'CPN_NO','GFTCERT_NO','CPN_CD','BARCODE_NO','BARCD_NO','CPN_BARCD_NO','GFTCERT_BARCODE_NO',
        'COUPON_NO','COUPON_BARCODE','SERIAL_NO','SN','PIN_NO','PIN'
      ]) || deepPick(v, ['DSC_CD']);

    const st = computeStatus(v);
    const theater   = deepPick(v, ['APPL_THAT_NM','THEATER_NM','USE_THAT_NM','APLY_THAT_NM','APPLY_THEATER_NM','BRCH_NM']);
    const theaterId = deepPick(v, ['APPL_THAT_CD','THEATER_CD','USE_THAT_CD','BRCH_CD']);
    const movie     = deepPick(v, ['MOVIE_NM','FILM_NM','MOV_TTL_NM','TTL_NM','TITLE_NM']);
    const channel   = deepPick(v, ['APPL_CHNL_NM','CHNL_NM','SELL_CHNL','REG_CHNL','APPL_CHNL_CD','CHNL_CD']);
    const pct   = deepPick(v, ['DSC_RATE','DC_RATE','DISC_RATE','BENEFIT_RATE','BENEFIT_RT']);
    const amt   = deepPick(v, ['DSC_AMT','DC_AMT','DISC_AMT','BENEFIT_AMT','BENEFIT_AMOUNT']);
    const bname = deepPick(v, ['CPN_BNF_NM','BNF_NM','BENEFIT_NM']);
    const minAmt = deepPick(v, ['MIN_AMT','MIN_PUR_AMT','MIN_ORD_AMT','MIN_PURCH_AMT','MIN_ORD_AMT_VAT','MIN_AMT_VAT']);
    const note   = deepPick(v, ['ON_CUST_NOTY_CONT','CPN_DESC','DSC_DTL','DESC','REMARK','REMARKS','RMK','MEMO']);
    const orderId= deepPick(v, ['ORD_ID','ORDER_ID','REDEEM_ORD_ID','USE_ORD_ID']);
    const usedAt = deepPick(v, ['USE_DTTM','REDM_DTTM','REDEEM_DTTM','REDEEM_DT','USE_DT']);
    const useYN  = deepPick(v, ['USE_YN','use_yn','USED_YN','USE_YN_CD','USE_YN_NM']);
    const endAdj  = st.endAdj || null;
    const daysLeft = endAdj ? Math.max(0, Math.ceil((endAdj - new Date()) / 86400000)) : null;
    const isActiveUnused = st.label === 'ACTIVE';
    const isExpiredBool = st.label === 'EXPIRED';
    return {
      kind, name, code,
      status: st.label,
      status_raw: st.rawTxt || null,
      is_expired: isExpiredBool,
      start_at: toIsoLocal(st.startRaw),
      end_at:   endAdj ? toIsoLocal(endAdj) : toIsoLocal(st.endRaw),
      valid_from: toIsoLocal(st.startRaw),
      valid_to:   endAdj ? toIsoLocal(endAdj) : toIsoLocal(st.endRaw),
      theater, theater_id: theaterId, movie, channel,
      benefit_name: bname,
      discount_percent: pct == null ? null : Number(pct),
      discount_amount:  amt == null ? null : Number(amt),
      min_purchase:     minAmt == null ? null : Number(minAmt),
      use_yn: useYN == null ? null : String(useYN),
      used_at: toIsoLocal(usedAt),
      used_order_id: orderId,
      is_active_unused: !!isActiveUnused,
      days_left: daysLeft,
      note
    };
  };

  // â”€â”€ Parser ringan transaksi
  const parseTxnSimple = (t) => {
    const title   = deepPick(t, ['name','MOVIE_NM','MOV_TTL_NM','TTL_NM','TITLE_NM','GOODS_NM']) || '';
    const type    = deepPick(t, ['type','ORD_TP_NM','CATEGORY']) || '';
    const amount  = Number(deepPick(t, ['amount','PAY_AMT','TOT_PAY_AMT']) ?? 0);
    const rawStat = deepPick(t, ['ORD_STAT_NM','STAT_NM','STATUS_NM','ORDER_STATUS','PAY_STAT_NM']);
    const isComplete = deepPick(t, ['is_complete']);
    let status = 'UNKNOWN';
    if (rawStat) {
      const s=String(rawStat).toLowerCase();
      if (/cancel|void|refund|batal|gagal|fail|chargeback/.test(s)) status='CANCELLED';
      else if (/success|paid|complete|berhasil|selesai|approved|settled/.test(s)) status='SUCCESS';
      else if (/pending|menunggu|await|process|processing|unpaid/.test(s)) status='PENDING';
    }
    if (status==='UNKNOWN' && isComplete!=null) status = Number(isComplete)===1 ? 'SUCCESS' : 'PENDING';
    const created_at = toIsoLocal(deepPick(t, ['transaction_date_time','REG_DTTM','ORD_DTTM','transaction_date']));
    return { title, type, amount, status, created_at };
  };

  // â”€â”€ Status coloring (teks)
  const colorPopcornStatus = (s) => {
    if (s === 'YES') return chalk.green('YES');
    if (s === 'USED') return chalk.yellow('USED');
    if (s === 'NO') return chalk.red('NO');
    if (s === 'YES+USED') return `${chalk.green('YES')}${chalk.gray('+')}${chalk.yellow('USED')}`;
    return s || '-';
  };
  const colorComboStatus = (s) => {
    if (s === 'YES') return chalk.green('YES');
    if (s === 'USED') return chalk.yellow('USED');
    if (s === 'YES+USED') return `${chalk.green('YES')}${chalk.gray('+')}${chalk.yellow('USED')}`;
    if (s === 'NO') return chalk.red('NO');
    return s || '-';
  };
  const colorThirdStatus = (s) => colorComboStatus(s);

  // â”€â”€ Helper nama voucher (tetap)
  const is1stPopVoucherName = (nm) => {
    const s = String(nm || '').toLowerCase();
    return /(^|\b)1st\b.*visit.*popcorn/.test(s)
        || /first\b.*visit.*popcorn/.test(s)
        || /visit\s*ke[- ]?1.*popcorn/.test(s);
  };

  // â”€â”€ Detektor 1st Visit Popcorn (STATUS teks)
  const detectPopcorn1stVisitStatus = (vouchers, txnsRaw) => {
    const hasActive = (vouchers || []).some(v =>
      is1stPopVoucherName(v.name) && v.is_active_unused === true && v.is_expired === false
    );
    let usedBefore = false, lastUsedAt = null;
    for (const it of (txnsRaw || [])) {
      const p = parseTxnSimple(it);
      if (p.status !== 'SUCCESS') continue;
      if (/popcorn/i.test(p.title) && p.amount === 0) {
        usedBefore = true;
        if (p.created_at && (!lastUsedAt || new Date(p.created_at.replace(' ','T')) > new Date((lastUsedAt||'').replace(' ','T')))) {
          lastUsedAt = p.created_at;
        }
      }
    }
    const status = hasActive ? 'YES' : (usedBefore ? 'USED' : 'NO');
    return { status, has_active: hasActive, used_before: usedBefore, last_used_at: lastUsedAt };
  };

  // â”€â”€ Detektor Combo Solo (STATUS teks)
  const detectComboSoloStatus = (vouchers, txnsRaw) => {
    const re = /combo\s*solo/i;
    const hasActive = (vouchers || []).some(v => re.test(String(v.name || '')) && v.is_active_unused === true);
    let usedBefore = false, usedTimes = 0, lastUsedAt = null;
    for (const it of (txnsRaw || [])) {
      const p = parseTxnSimple(it);
      if (p.status !== 'SUCCESS') continue;
      if (re.test(p.title)) {
        usedBefore = true;
        usedTimes++;
        if (p.created_at && (!lastUsedAt || new Date(p.created_at.replace(' ','T')) > new Date((lastUsedAt||'').replace(' ','T')))) {
          lastUsedAt = p.created_at;
        }
      }
    }
    const status = hasActive && usedBefore ? 'YES+USED'
                 : hasActive               ? 'YES'
                 : usedBefore              ? 'USED'
                 : 'NO';
    return { status, has_active: hasActive, used_before: usedBefore, last_used_at: lastUsedAt, used_times: usedTimes };
  };

  // â”€â”€ Detektor Combo Duo (STATUS teks) [BARU]
  const detectComboDuoStatus = (vouchers, txnsRaw) => {
    const re = /combo\s*duo/i;
    const hasActive = (vouchers || []).some(v => re.test(String(v.name || '')) && v.is_active_unused === true);
    let usedBefore = false, usedTimes = 0, lastUsedAt = null;
    for (const it of (txnsRaw || [])) {
      const p = parseTxnSimple(it);
      if (p.status !== 'SUCCESS') continue;
      if (re.test(p.title)) {
        usedBefore = true;
        usedTimes++;
        if (p.created_at && (!lastUsedAt || new Date(p.created_at.replace(' ','T')) > new Date((lastUsedAt||'').replace(' ','T')))) {
          lastUsedAt = p.created_at;
        }
      }
    }
    const status = hasActive && usedBefore ? 'YES+USED'
                 : hasActive               ? 'YES'
                 : usedBefore              ? 'USED'
                 : 'NO';
    return { status, has_active: hasActive, used_before: usedBefore, last_used_at: lastUsedAt, used_times: usedTimes };
  };

  // â”€â”€ (UPDATED) Detektor 3rd Visit: B1G1 Ticket 2D â€” berbasis jumlah visit
  const is3rdVisitName = (s) =>
    /(3(rd)?\s*visit.*(buy\s*1\s*get\s*1|b1g1).*2d)|(^3(rd)?\s*visit\b)/i.test(String(s||''));
  const detect3rdVisitStatus = (vouchers, totalVisits) => {
    const related = (vouchers || []).filter(v => is3rdVisitName(v.name || v.note));
    const hasActive = related.some(v => v.is_active_unused === true && v.is_expired === false);
    const visits = Number(totalVisits || 0);
    let status = 'NO';
    let usedTimes = 0;
    if (visits >= 3) {
      if (hasActive) {
        status = 'YES';
      } else {
        status = 'USED';
        usedTimes = 1;
      }
    } else {
      status = hasActive ? 'YES' : 'NO';
    }
    return { status, has_active: hasActive, used_times: usedTimes, last_used_at: null };
  };

  // â”€â”€ Detektor versi ANGKA
  const detectPopcorn1stVisitUsage = (vouchers, txnsRaw) => {
    let usedTimes = 0, lastUsedAt = null;
    for (const it of (txnsRaw || [])) {
      const p = parseTxnSimple(it);
      if (p.status !== 'SUCCESS') continue;
      if (/popcorn/i.test(p.title) && Number(p.amount) === 0) {
        usedTimes++;
        if (p.created_at && (!lastUsedAt || new Date(p.created_at.replace(' ','T')) > new Date((lastUsedAt||'').replace(' ','T')))) {
          lastUsedAt = p.created_at;
        }
      }
    }
    const hasActive = (vouchers || []).some(v =>
      is1stPopVoucherName(v.name) && v.is_active_unused === true && v.is_expired === false
    );
    return { used_times: usedTimes, has_active: hasActive, last_used_at: lastUsedAt };
  };
  const detectComboSoloUsage = (vouchers, txnsRaw) => {
    const re = /combo\s*solo/i;
    let usedTimes = 0, lastUsedAt = null;
    for (const it of (txnsRaw || [])) {
      const p = parseTxnSimple(it);
      if (p.status !== 'SUCCESS') continue;
      if (re.test(p.title)) {
        usedTimes++;
        if (p.created_at && (!lastUsedAt || new Date(p.created_at.replace(' ','T')) > new Date((lastUsedAt||'').replace(' ','T')))) {
          lastUsedAt = p.created_at;
        }
      }
    }
    const hasActive = (vouchers || []).some(v => re.test(String(v.name || '')) && v.is_active_unused === true);
    return { used_times: usedTimes, has_active: hasActive, last_used_at: lastUsedAt };
  };
  // [BARU] Combo Duo usage numeric
  const detectComboDuoUsage = (vouchers, txnsRaw) => {
    const re = /combo\s*duo/i;
    let usedTimes = 0, lastUsedAt = null;
    for (const it of (txnsRaw || [])) {
      const p = parseTxnSimple(it);
      if (p.status !== 'SUCCESS') continue;
      if (re.test(p.title)) {
        usedTimes++;
        if (p.created_at && (!lastUsedAt || new Date(p.created_at.replace(' ','T')) > new Date((lastUsedAt||'').replace(' ','T')))) {
          lastUsedAt = p.created_at;
        }
      }
    }
    const hasActive = (vouchers || []).some(v => re.test(String(v.name || '')) && v.is_active_unused === true);
    return { used_times: usedTimes, has_active: hasActive, last_used_at: lastUsedAt };
  };

  // â”€â”€ (BARU) Detektor Combo Gold (2D ALL DAYS) â€” STATUS teks
  const detectComboGoldStatus = (vouchers) => {
    const re = /2D.*ALL\s*DAYS.*Complimentary\s*Member\s*Rewards/i;
    const hasActive = (vouchers || []).some(v => re.test(String(v.name || '')) && v.is_active_unused === true && v.is_expired === false);
    const status = hasActive ? 'YES' : 'NO';
    return { status, has_active: hasActive, used_times: 0, last_used_at: null };
  };

  // â”€â”€ (BARU) Detektor Combo Gold usage (numeric)
  const detectComboGoldUsage = (vouchers) => {
    const re = /2D.*ALL\s*DAYS.*Complimentary\s*Member\s*Rewards/i;
    const hasActive = (vouchers || []).some(v => re.test(String(v.name || '')) && v.is_active_unused === true && v.is_expired === false);
    return { used_times: 0, has_active: hasActive, last_used_at: null };
  };

  // â”€â”€ (BARU) Detektor Telkomsel 10K Flat usage
  const detectTelkomsel10KUsage = (txnsRaw) => {
    let usedTimes = 0, lastUsedAt = null;
    for (const it of (txnsRaw || [])) {
      const p = parseTxnSimple(it);
      if (p.status !== 'SUCCESS') continue;
      const typeLow = String(p.type || '').toLowerCase();
      if (!/movie|film|tix|ticket/.test(typeLow)) continue;
      const amt = Number(p.amount || 0);
      if (!(amt >= 9000 && amt <= 13000)) continue;
      let seatQty = Number(
        deepPick(it, [
          'SEAT_QTY','SEAT_CNT','SEAT_COUNT','TICKET_QTY','TICK_QTY','TKT_QTY','TKT_COUNT',
          'QTY','QT','CNT','COUNT','TOT_QTY','TOTAL_QTY','order_qty','qty'
        ]) ?? NaN
      );
      if (!Number.isFinite(seatQty)) {
        const title = String(p.title || '');
        if (/\b1\s*(seat|kursi|ticket|tiket|tix)\b/i.test(title)) seatQty = 1;
      }
      if (seatQty !== 1) continue;
      usedTimes++;
      if (p.created_at && (!lastUsedAt || new Date(p.created_at.replace(' ','T')) > new Date((lastUsedAt||'').replace(' ','T')))) {
        lastUsedAt = p.created_at;
      }
    }
    return { used_times: usedTimes, last_used_at: lastUsedAt };
  };

  // â”€â”€ Klasifikasi jenis voucher untuk ringkasan
  const classifyVoucherType = (v) => {
    const nm = String(v?.name || '');
    if (/1st.*visit.*popcorn/i.test(nm)) return '1ST VISIT POPCORN';
    if (/combo\s*solo/i.test(nm))        return 'COMBO SOLO';
    if (/combo\s*duo/i.test(nm))         return 'COMBO DUO';
    if (is3rdVisitName(nm))              return 'B1G1 TICKET 2D (3rd VISIT)';
    return (v?.benefit_name || v?.kind || '-').toString().toUpperCase();
  };

  // â”€â”€ Wrapper aman (member info & login)
  const getMemberInfoSafe = async (token, accHeaders) => {
    try {
      try {
        return await withTimeout(getMemberInfo(token, accHeaders), 20000, 'getMemberInfo timeout');
      } catch {
        return await withTimeout(getMemberInfo(token), 20000, 'getMemberInfo timeout');
      }
    } catch { return null; }
  };
  const getLoginAccountSafe = async (email, pwd, accHeaders) => {
    try {
      try {
        return await withTimeout(getLoginAccount(email, pwd, accHeaders), 20000, 'login timeout');
      } catch {
        return await withTimeout(getLoginAccount(email, pwd), 20000, 'login timeout');
      }
    } catch (e) {
      return { status_code: 0, message: e?.message || 'Login error' };
    }
  };

  // â”€â”€ HTTP helper: transaksi (pakai bearer) + random headers per akun
  const fetchTransactions = async (token, accHeaders) => {
    const baseHeaders = {
      'accept': 'application/json, text/plain, */*',
      'authorization': `Bearer ${token}`,
      'accept-encoding': 'gzip',
      'user-agent': (accHeaders && accHeaders['user-agent']) || 'okhttp/4.10.0',
      'connection': 'Keep-Alive',
      ...(accHeaders?.['accept-language'] ? { 'accept-language': accHeaders['accept-language'] } : {})
    };
    const headers = RANDOMIZE_HEADERS_PER_ACCOUNT ? mergeHeaders(baseHeaders, accHeaders) : baseHeaders;
    try {
      const res = await fetchWithTimeout('https://v2-api.cgv.id/api/membership/transactions', {
        method: 'GET',
        headers
      }, 15000);
      if (!res.ok) return { ok:false, data:[] };
      const j = await res.json().catch(()=>null);
      const arr = j?.data;
      return { ok:true, data: Array.isArray(arr) ? arr : [] };
    } catch {
      return { ok:false, data:[] };
    }
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // (BARU) GRADE REWARD API HELPERS (VIP ONLY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fetchGradeReward = async (token, accHeaders) => {
    const baseHeaders = {
      'accept': 'application/json, text/plain, */*',
      'authorization': `Bearer ${token}`,
      'accept-encoding': 'gzip',
      'user-agent': (accHeaders && accHeaders['user-agent']) || 'okhttp/4.10.0',
      'connection': 'Keep-Alive',
      ...(accHeaders?.['accept-language'] ? { 'accept-language': accHeaders['accept-language'] } : {})
    };
    const headers = RANDOMIZE_HEADERS_PER_ACCOUNT ? mergeHeaders(baseHeaders, accHeaders) : baseHeaders;
    try {
      const res = await fetchWithTimeout('https://v2-api.cgv.id/api/membership/grade-reward', {
        method: 'GET',
        headers
      }, 15000);
      if (!res.ok) return { ok:false, data:[] };
      const j = await res.json().catch(()=>null);
      const arr = j?.data;
      return { ok:true, data: Array.isArray(arr) ? arr : [] };
    } catch {
      return { ok:false, data:[] };
    }
  };

  let vipGradeInfoCache = null; // cache daftar grade_info VIP
  const fetchGradeInfoVIP = async (token, accHeaders) => {
    if (vipGradeInfoCache) return vipGradeInfoCache;
    const baseHeaders = {
      'accept': 'application/json, text/plain, */*',
      'authorization': `Bearer ${token}`,
      'accept-encoding': 'gzip',
      'user-agent': (accHeaders && accHeaders['user-agent']) || 'okhttp/4.10.0',
      'connection': 'Keep-Alive',
      ...(accHeaders?.['accept-language'] ? { 'accept-language': accHeaders['accept-language'] } : {})
    };
    try {
      const res = await fetchWithTimeout('https://v2-api.cgv.id/api/membership/grade-info', {
        method: 'GET',
        headers: RANDOMIZE_HEADERS_PER_ACCOUNT ? mergeHeaders(baseHeaders, accHeaders) : baseHeaders
      }, 15000);
      if (!res.ok) return null;
      const j = await res.json().catch(()=>null);
      const data = Array.isArray(j?.data) ? j.data : [];
      const vip = data.find(x => String(x?.name || '').toUpperCase() === 'VIP');
      const gi = Array.isArray(vip?.grade_info) ? vip.grade_info : [];
      vipGradeInfoCache = gi;
      return gi;
    } catch {
      return null;
    }
  };

  const postSelectReward = async (token, id, accHeaders) => {
    const baseHeaders = {
      'accept': 'application/json, text/plain, */*',
      'authorization': `Bearer ${token}`,
      'accept-encoding': 'gzip',
      'user-agent': (accHeaders && accHeaders['user-agent']) || 'okhttp/4.10.0',
      'connection': 'Keep-Alive',
      'content-type': 'application/json',
      ...(accHeaders?.['accept-language'] ? { 'accept-language': accHeaders['accept-language'] } : {})
    };
    try {
      const res = await fetchWithTimeout('https://v2-api.cgv.id/api/membership/select-reward', {
        method: 'POST',
        headers: RANDOMIZE_HEADERS_PER_ACCOUNT ? mergeHeaders(baseHeaders, accHeaders) : baseHeaders,
        body: JSON.stringify({ id: String(id) })
      }, 15000);
      const ok = res.ok;
      const j = await res.json().catch(()=>null);
      return { ok, json:j };
    } catch (e) {
      return { ok:false, json:null, error:e?.message || 'select-reward error' };
    }
  };

  // â”€â”€ last movie/txn helpers
  const getLastMovieDate = (txns) => {
    if (!Array.isArray(txns) || !txns.length) return null;
    const isMovieTxn = (t) =>
      /movie|film|ticket|tix/i.test(String(t?.type || t?.ORD_TP_NM || t?.CATEGORY || ''));
    const movies = txns.filter(isMovieTxn);
    if (!movies.length) return null;
    movies.sort((a,b)=>{
      // Gunakan created_at (CREATED_AT/ORDER_TIME) sebagai prioritas, bukan movie_date
      const ad = new Date(String(a.CREATED_AT||a.ORDER_TIME||a.transaction_date_time||a.transaction_date||a.REG_DTTM||'1970-01-01'));
      const bd = new Date(String(b.CREATED_AT||b.ORDER_TIME||b.transaction_date_time||b.transaction_date||b.REG_DTTM||'1970-01-01'));
      return bd - ad;
    });
    const top = movies[0];
    // Ambil tanggal created_at (waktu transaksi dibuat), bukan movie_date (jadwal film)
    const raw = top.CREATED_AT || top.ORDER_TIME || top.transaction_date_time || top.transaction_date || top.REG_DTTM || null;
    return raw ? String(raw).slice(0,10) : null;
  };
  const getLastTxnDate = (txns) => {
    if (!Array.isArray(txns) || !txns.length) return null;
    let best = null, bestTs = -1;
    for (const t of txns) {
      // Gunakan created_at (CREATED_AT/ORDER_TIME) sebagai prioritas, bukan movie_date
      const cand = t.CREATED_AT || t.ORDER_TIME || t.transaction_date_time || t.transaction_date || t.REG_DTTM;
      const d = new Date(String(cand || '1970-01-01'));
      const ts = d.getTime();
      if (Number.isFinite(ts) && ts > bestTs) { bestTs = ts; best = d; }
    }
    if (!best) return null;
    const pad = (n)=>String(n).padStart(2,'0');
    return `${best.getFullYear()}-${pad(best.getMonth()+1)}-${pad(best.getDate())}`;
  };

  // â”€â”€ (UPDATED) Bearer: validasi 2x sebelum relogin
  const validateBearerTwice = async (email, cached, accHeaders) => {
    try {
      const info1 = await getMemberInfoSafe(cached, accHeaders);
      if (info1?.RESULTS?.ds_mbrList) return { ok:true, info:info1, reason:null, attempt:'first' };
      const msg = String(info1?.message || '').toLowerCase();
      if (info1?.status_code === 401 || /expired|invalid|unauthoriz/.test(msg)) {
        console.log(chalk.yellow(`âš ï¸  Bearer untuk ${email} terdeteksi expired/invalid (1st test) â†’ retestâ€¦`));
        await delay(300);
        const info2 = await getMemberInfoSafe(cached, accHeaders).catch(()=>null);
        if (info2?.RESULTS?.ds_mbrList) {
          console.log(chalk.green(`âœ“ Retest OK â€” bearer lama ${email} masih valid`));
          return { ok:true, info:info2, reason:null, attempt:'second' };
        }
        return { ok:false, info:null, reason:'expired_or_invalid', attempt:'second' };
      }
      return { ok:false, info:null, reason:'transient', attempt:'first' };
    } catch {
      return { ok:false, info:null, reason:'transient', attempt:'first' };
    }
  };

  // ==== LOGIN (update: gunakan ENV DEFAULT_PASSWORDS) ====
  const parseEnvDefaultPasswords = () => {
    const raw = (process?.env?.DEFAULT_PASSWORDS || '').trim();
    if (!raw) return [];
    return raw.split(',').map(s => s.trim()).filter(Boolean);
  };

  const safeLoginPro = async (email, filePwd, accHeaders) => {
    const cached = bearerMap.get(normEmail(email));
    if (cached) {
      const v = await validateBearerTwice(email, cached, accHeaders);
      if (v.ok) {
        return { ok:true, token: cached, usedPwd: null, via: 'bearer', preInfo: v.info };
      }
      if (v.reason === 'transient') {
        console.log(chalk.yellow(`â†» Ping ulang bearer ${email} (transient)â€¦`));
        await delay(500);
        const v2 = await validateBearerTwice(email, cached, accHeaders);
        if (v2.ok) return { ok:true, token: cached, usedPwd: null, via: 'bearer', preInfo: v2.info };
        if (v2.reason !== 'expired_or_invalid') {
          console.log(chalk.yellow(`â†» Gagal ping ulang: lanjut relogin untuk ${email}`));
        } else {
          console.log(chalk.yellow(`âš ï¸  Bearer expired/invalid untuk ${email} â†’ login ulangâ€¦`));
        }
      } else {
        console.log(chalk.yellow(`âš ï¸  Bearer expired/invalid untuk ${email} â†’ login ulangâ€¦`));
      }
    }

    // Kandidat password: [password JSON] + ENV DEFAULT_PASSWORDS
    const envPwds = parseEnvDefaultPasswords();
    const mayFromJson = passMap.get(normEmail(email));
    const candidates = [];
    [filePwd, mayFromJson].forEach(p => { if (p) candidates.push(String(p).trim()); });
    candidates.push(...envPwds);
    const uniqueCandidates = [...new Set(candidates.map(p => String(p).trim()).filter(Boolean))];

    const MAX_RETRY_PER_PWD = 12;
    const MAX_TOTAL_SECONDS = 180;
    const startTime = Date.now();

    let last = null;
    for (const pwd of uniqueCandidates) {
      let attempt = 0;
      let backoff = 2000;
      while (true) {
        if ((Date.now() - startTime)/1000 > MAX_TOTAL_SECONDS) break;
        attempt++;
        try {
          const res = await getLoginAccountSafe(
            email,
            pwd,
            RANDOMIZE_HEADERS_PER_ACCOUNT ? makeAccountHeaders() : undefined
          );
          last = res;

          // FAST-EXIT: "Account not found"
          if (reasonFromLoginError(res) === 'Account not found') {
            console.log(chalk.red(`[âœ—] Login gagal (${email}) attempt ${attempt} dengan password "${pwd}": Member not found (stop)`));
            return { ok:false, reason:'Account not found', notFound:true, last: res };
          }

          if (res?.status_code === 200 && res?.token) {
            console.log(chalk.green(`âœ“ New bearer for ${email}`));
            passMap.set(normEmail(email), pwd);
            return { ok:true, token:res.token, usedPwd:pwd, via: 'login' };
          }

          const retriable = isRetryable(res);
          const msg = res?.message || res?.status_code;
          if (!retriable) {
            console.log(chalk.red(`[âœ—] Login gagal (${email}) attempt ${attempt} dengan password "${pwd}": ${msg}`));
            break;
          }
          console.log(chalk.yellow(`[â†»] Retry (${email}) attempt ${attempt} dengan password "${pwd}" karena: ${msg}`));
          if (attempt >= MAX_RETRY_PER_PWD) break;
          await delay(backoff);
          backoff = Math.min(backoff*1.5, 10000);
        } catch(e) {
          console.log(chalk.yellow(`[â†»] Retry (${email}) attempt ${attempt} dengan password "${pwd}" exception: ${e.message}`));
          if (attempt >= MAX_RETRY_PER_PWD) break;
          await delay(backoff);
          backoff = Math.min(backoff*1.5, 10000);
        }
      }
    }
    return { ok:false, reason: reasonFromLoginError(last), last };
  };

  // ====== PATCH COLLECTOR (global, single write at end) ======
  const patchMap = new Map();  // email(lower) -> { ...fieldsToPatch }
  const mergePatch = (email, obj) => {
    const k = normEmail(email);
    const prev = patchMap.get(k) || {};
    patchMap.set(k, { ...prev, ...obj });
  };

  // â”€â”€ tabel hasil (AUTO-FIT)
  const Table = await universalTable();
  const resultTable = new Table({
    head:[
      'No','Email','Name','Tier','Points','Phone','City','Join','AgeD','Bday','BLeft','V-HP',
      'Visits','LastMovie',
      '1stPop','1stPopUsed',
      'ComboSolo','ComboUsed',
      'ComboDuo','DuoUsed',
      'ComboGold','GoldUsed',
      '3rdB1G1','3rdUsed',
      'Vouchers','FavTh','Spend','NeedSpend(G)','NeedSpend(V)','NeedVisit(G)','NeedVisit(V)','Birthday?','GradeRw'
    ],
    wordWrap:true,
    style:{ head:['green'] }
  });

  // (BARU) tampung baris hasil per index agar urut meskipun paralel
  const resultRows = new Array(akunList.length);

  // â”€â”€ helper allaccounts.txt (FORMAT BARU â€” ringkas + PHONE + Combo Duo)
  const clampPad = (s, w) => {
    const x = String(s ?? '');
    if (x.length <= w) return x + ' '.repeat(w - x.length);
    if (w <= 2) return x.slice(0, w);
    return x.slice(0, w - 2) + '..';
  };

  const EMAIL_W = 38;
  const PWD_W   = 20;  // max kolom password
  const PHONE_W = 16;  // Phone stabil 16 char
  const POINTS_W = 8;  // NEW: kolom Points
  const VIS_W   = 7;

  const DATE_W     = 10;  // Birthday
  const LASTTXN_W  = 40;  // LastTxn (movie-only)
  const JOIN_W     = 26;  // JoinAt
  const BLEFT_W    = 16;

  const BLEFT_SUFFIX_LABEL = (String(BLEFT_LABEL||'Hari').toLowerCase()==='days') ? 'Days' : 'Hari';
  const BLEFT_SUFFIX = ` (Sisa ${BLEFT_SUFFIX_LABEL})`;
  const BLEFT_NUM_W = Math.max(1, BLEFT_W - BLEFT_SUFFIX.length);

  const formatBLeftCell = (val) => {
    if (val === '-' || val == null || val === '') return padR('-', BLEFT_W);
    const n = Number(val);
    if (!Number.isFinite(n)) return padR(String(val), BLEFT_W);
    if (n === 0) return padR('âœ… (Hari ini)', BLEFT_W);
    const num = String(n).padStart(BLEFT_NUM_W, ' ');
    const cell = num + BLEFT_SUFFIX;
    return cell.length === BLEFT_W ? cell : padR(cell, BLEFT_W);
  };

  // JoinAt: "YYYY-MM-DD (NN Hari)"
  const formatJoinCell = (joinD8, joinAgeDays) => {
    const j = d8(joinD8 || '');
    const a = (joinAgeDays === '-' || joinAgeDays == null) ? '-' : String(joinAgeDays);
    if (j === '-' && a === '-') return padR('-', JOIN_W);
    const pretty = j === '-' ? '-' : `${j} (${a} Hari)`;
    return padR(pretty, JOIN_W);
  };

  const HV1_W = 19;   // "1stVisitPopcorn"
  const HV2_W = 14;   // "Combo Solo"
  const HV2B_W= 14;   // "Combo Duo"
  const HV2C_W= 14;   // "Combo Gold" (NEW)
  const HV3_W = 15;   // "3rdVisitB1G1"
  const HV4_W = 16;   // "Tsel10KAvail"

  const U1_W = 24;    // "1 (Pernah pakai 1stPop)"
  const U2_W = 29;    // "1 (Pernah pakai Combo Solo)"
  const U2B_W= 29;    // "1 (Pernah pakai Combo Duo)"
  const U2C_W= 29;    // "0 (Belum ada)" Combo Gold (NEW)
  const U3_W = 26;    // "1 (Pernah pakai 3rd Visit)"
  const U4_W = 31;    // "1 (Pernah pakai Tsel10K)"

  const allAccLines = new Array(akunList.length);
  const allAccExplained = new Array(akunList.length); // keep
  const allAccRecs = new Array(akunList.length);      // for sorting

  const decorateLastTxn = (last) => {
    const lx = String(last || '-');
    if (lx === '-') return lx;
    return lx === todayYmd ? lx : `${lx} (Belum transaksi hari ini)`;
  };

  function appendAllAccountsAt(
    idx,
    email,
    pwd,
    visits,
    lastTxnDate,
    joinD8Raw,
    joinAgeDays,
    birthdayStr,
    bdayLeft,
    popUsedCount,
    comboSoloUsedCount,
    comboDuoUsedCount,
    comboGoldUsedCount,
    thirdUsedCount,
    hasPopVoucher,
    hasComboSoloVoucher,
    hasComboDuoVoucher,
    hasComboGoldVoucher,
    hasThirdVoucher,
    hasTsel10kVoucher,
    tsel10kUsedCount,
    phone,
    points,
    gradeRw
  ) {
    const nPop    = Number(popUsedCount ?? 0);
    const nComboS = Number(comboSoloUsedCount ?? 0);
    const nComboD = Number(comboDuoUsedCount ?? 0);
    const nComboG = Number(comboGoldUsedCount ?? 0);
    const nThird  = Number(thirdUsedCount ?? 0);
    const nTsel   = Number(tsel10kUsedCount ?? 0);

    const bleftText = formatBLeftCell(bdayLeft);

    const usedLbl = (count, what) =>
      (Number(count) > 0
        ? `${count} (Pernah pakai ${what})`
        : `${count} (Belum ada)`);

    const yesNoShort = (b) => b ? 'YES (Punya)' : 'NO (Tidak ada)';

    const lastTxnDecor = decorateLastTxn(lastTxnDate || '-');
    const joinCell     = formatJoinCell(joinD8Raw, joinAgeDays);

    // SUSUN KOLOM BARU (dengan Combo Duo & Combo Gold & DuoUsed & GoldUsed & GradeRw)
    // Email | Password | Phone | Points | Visits | LastTxn | JoinAt | Birthday | BdayLeft |
    // 1stVisitPopcorn | Combo Solo | Combo Duo | Combo Gold | 3rdVisitB1G1 | Tsel10KAvail |
    // 1stPopUsed | ComboUsed | DuoUsed | GoldUsed | 3rdUsed | Tsel10KUsed | GradeRw
    const line =
      padR(String(email), EMAIL_W)                         + ' | ' +
      clampPad(String(pwd || '-'), PWD_W)                  + ' | ' +
      padR(String(phone || '-'), PHONE_W)                  + ' | ' +
      padR(String(fmtID(points) || '0'), POINTS_W)         + ' | ' +
      padR(String(visits ?? 0), VIS_W)                     + ' | ' +
      padR(String(lastTxnDecor || '-'), LASTTXN_W)         + ' | ' +
      joinCell                                             + ' | ' +
      padR(String(birthdayStr || '-'), DATE_W)             + ' | ' +
      bleftText                                            + ' | ' +
      padR(yesNoShort(!!hasPopVoucher),        HV1_W)      + ' | ' +
      padR(yesNoShort(!!hasComboSoloVoucher),  HV2_W)      + ' | ' +
      padR(yesNoShort(!!hasComboDuoVoucher),   HV2B_W)     + ' | ' +
      padR(yesNoShort(!!hasComboGoldVoucher),  HV2C_W)     + ' | ' +
      padR(yesNoShort(!!hasThirdVoucher),      HV3_W)      + ' | ' +
      padR(yesNoShort(!!hasTsel10kVoucher),    HV4_W)      + ' | ' +
      padR(usedLbl(nPop,    '1stPop'),         U1_W)       + ' | ' +
      padR(usedLbl(nComboS, 'Combo Solo'),     U2_W)       + ' | ' +
      padR(usedLbl(nComboD, 'Combo Duo'),      U2B_W)      + ' | ' +
      padR(usedLbl(nComboG, 'Combo Gold'),     U2C_W)      + ' | ' +
      padR(usedLbl(nThird,  '3rd Visit'),      U3_W)       + ' | ' +
      padR(usedLbl(nTsel,   'Tsel10K'),        U4_W)       + ' | ' +
      padR(String(gradeRw || '-'), 20);

    allAccLines[idx] = line;

    // versi explained (dipertahankan, tidak dipakai user untuk file utama, tapi kita update biar konsisten)
    const bleftExpl =
      (bdayLeft === '-' || bdayLeft === null || bdayLeft === undefined)
        ? '-'
        : (Number(bdayLeft) === 0 ? 'âœ… (Hari ini)' : `${bdayLeft} (Sisa ${BLEFT_SUFFIX_LABEL})`);

    const exp =
      padR(String(email), EMAIL_W)                          + ' | ' +
      clampPad(String(pwd || '-'), PWD_W)                   + ' | ' +
      padR(String(phone || '-'), PHONE_W)                   + ' | ' +
      padR(String(fmtID(points) || '0'), POINTS_W)          + ' | ' +
      padR(String(visits ?? 0), VIS_W)                      + ' | ' +
      padR(String(lastTxnDecor || '-'), 34)                 + ' | ' +
      padR(formatJoinCell(joinD8Raw, joinAgeDays), 26)      + ' | ' +
      padR(String(birthdayStr || '-'), DATE_W)              + ' | ' +
      padR(bleftExpl, 18)                                   + ' | ' +
      padR(`${String(nPop)} ${nPop>0?'(Pernah pakai 1stPop)':'(Belum ada riwayat Voucher 1st digunakan)'}`, 52) + ' | ' +
      padR(`${String(nComboS)} ${nComboS>0?'(Pernah pakai Combo Solo)':'(Belum ada riwayat Voucher Combo Solo digunakan)'}`, 58) + ' | ' +
      padR(`${String(nComboD)} ${nComboD>0?'(Pernah pakai Combo Duo)':'(Belum ada riwayat Voucher Combo Duo digunakan)'}`, 58) + ' | ' +
      padR(`${String(nThird)} ${nThird>0?'(Pernah pakai 3rd Visit B1G1)':'(Belum ada riwayat 3rd Visit digunakan)'}`, 58) + ' | ' +
      padR((hasPopVoucher ? 'YES (Punya 1st Visit Popcorn)' : 'NO (Tidak punya 1st Visit Popcorn)'), 40) + ' | ' +
      padR((hasComboSoloVoucher ? 'YES (Punya Combo Solo)' : 'NO (Tidak punya voucher Combo Solo)'), 36) + ' | ' +
      padR((hasComboDuoVoucher ? 'YES (Punya Combo Duo)' : 'NO (Tidak punya voucher Combo Duo)'), 36) + ' | ' +
      padR((hasThirdVoucher ? 'YES (Punya 3rd Visit B1G1 2D)' : 'NO (Tidak punya 3rd Visit B1G1 2D)'), 40);
    allAccExplained[idx] = exp;

    // NOTE: allAccRecs[idx] will be filled later after lastMovieDate is defined
  }

  // ==== Telkomsel 10K availability detector ====
  const textAllVoucher = (v) => [v?.name, v?.note, v?.benefit_name].filter(Boolean).join(' ').toLowerCase();
  const isTelkomselFlatprice10k = (v) => {
    const t = textAllVoucher(v);
    return /\btelkomsel\b/.test(t) && /(10k|10\.?000|rp\s*10.?000|flat\s*price|flatprice)/.test(t);
  };

  // (BARU) buffer voucher non-expired (tetap)
  const V_EMAIL_W = 35, V_PWD_W = 10, V_TYPE_W = 27, V_NAME_W = 47, V_D_W = 10;
  const voucherLines = [];

 // >>> [BARU] Buffer segmen untuk disisipkan ke allaccounts.txt
 // Kriteria: Join age 15â€“30 hari, belum ada transaksi sama sekali, visits = 0
 const segmentJoin15_30_NoTxn = []; // {email,password,phone,join_date,age_days,visits,last_txn}
 
 // [TAMBAHAN] Segmen "mendekati" level visits tertentu
 const segmentNear3  = []; // visits 1â€“2
 const segmentNear8  = []; // visits 6â€“7
 const segmentNear15 = []; // visits 13â€“14

// [BARU] Segmen akun dengan voucher Combo aktif
// - combo solo aktif: masih punya voucher combo solo aktif & belum terpakai
// - combo duo aktif: masih punya voucher combo duo aktif & belum terpakai
// struktur item:
// { email, password, phone, visits, last_txn, comboType } 
// comboType: 'SOLO' atau 'DUO'
const segmentComboSoloActive = [];
const segmentComboDuoActive  = [];

  // [BARU] Segmen akun SUDAH >30 hari, belum transaksi sama sekali, visits = 0
  const segmentOver30_NoTxn = []; // {email,password,phone,join_date,age_days,visits,last_txn}

  // [BARU] Buffer akun dengan voucher Combo Solo aktif & belum pernah dipakai
  const comboSoloActiveList = []; // { email, phone, visits, voucherName, voucherType, usedTimes, tier, expiredDate, daysLeft }
  // [BARU] Buffer akun dengan voucher Combo Duo aktif & belum pernah dipakai
  const comboDuoActiveList = [];  // { email, phone, visits, voucherName, voucherType, usedTimes, tier, expiredDate, daysLeft }
  // [BARU] Buffer akun dengan voucher 2D ALL DAYS aktif & belum pernah dipakai
  const voucher2DAllDaysActiveList = []; // { email, phone, visits, voucherName, voucherType, usedTimes, tier, expiredDate, daysLeft }

  const appendVoucherLine = (email, pwd, type, name, vf, vt) => {
    voucherLines.push(
      padR(email, V_EMAIL_W) + ' | ' +
      padR(pwd || '-', V_PWD_W) + '  | ' +
      padR(type || '-', V_TYPE_W) + ' | ' +
      padR(name || '-', V_NAME_W) + ' â”‚ ' +
      padR((vf||'-').slice(0,10), V_D_W) + ' â”‚ ' +
      padR((vt||'-').slice(0,10), V_D_W)
    );
  };

  // â”€â”€ summary counters
  const t0 = Date.now();
  let okCnt = 0, failCnt = 0;
  const failMap = new Map();

  // â”€â”€ (BARU) buffer untuk ekspor akunLogin.txt
  const AKUNLOGIN_EMAIL_W = 35;
  const AKUNLOGIN_PASS_W  = 14;  // 14 char
  const AKUNLOGIN_PHONE_W = 16;
  const akunLoginExport = new Map(); // email -> line

  const pushAkunLoginExport = (email, password, phone) => {
    const line =
      padR(String(email || '-'), AKUNLOGIN_EMAIL_W) + ' | ' +
      padR(String(password || '-'), AKUNLOGIN_PASS_W) + ' | ' +
      padR(String(phone || '-'), AKUNLOGIN_PHONE_W) + ' | ' +
      PIN_DEFAULT;
    akunLoginExport.set(normEmail(email), line);
  };

  // (BARU) ======== VIP REWARD BUFFERS =========
  const vipCandidates = []; // { email, token, accHeaders, tierName, options:[{id, names[]}] }
  const vipGradeRwByEmail = new Map(); // email -> { count, options }

  // â”€â”€ proses per akun (paralel)
  const processOne = async (idx, {email, password}) => {
    const accHeaders = RANDOMIZE_HEADERS_PER_ACCOUNT ? makeAccountHeaders() : undefined;

    // heartbeat agar tidak diam (stuck)
    const HEARTBEAT_MS = 20000;
    const hb = setInterval(() => {
      console.log(chalk.gray(`â³ Still processing ${email} â€¦`));
    }, HEARTBEAT_MS);

    try {
      process.stdout.write(chalk.gray(`[${idx+1}/${akunList.length}] Checking ${email} â€¦ `));

      const login = await safeLoginPro(email, password, accHeaders);
      if (!login.ok) {
        const reason = login.reason || 'Login failed';
        failMap.set(reason, (failMap.get(reason) || 0) + 1);
        failCnt++;

        // KHUSUS: Account not found â†’ flag + buffer notfound
        if (reason === 'Account not found') {
          console.log(chalk.red('FAIL'), chalk.white(email), chalk.gray('â€”'), chalk.yellow('Account not found'), chalk.gray(`â€¢ Done ${idx+1}/${akunList.length}`));
          resultRows[idx] = [
            idx+1, email, '-', chalk.red('NOTFOUND'), '-', '-', '-', '-', '-', '-', '-', 'âœ–',
            '-', '-',
            '-', '0',
            '-', '0',
            '-', '0',
            '-', '0',
            '-', '0',
            '-', '-', '-', '-', '-', '-', '-', chalk.red('NO'), chalk.gray('-')
          ];
          const phoneFallback = phoneMap.get(normEmail(email)) || '-';

          appendAllAccountsAt(
            idx,
            email,
            password || '-',
            0,
            '-',      // lastMovie
            '-',      // joinD8
            '-',      // joinAgeDays
            '-',      // birthday
            '-',      // bdayLeft
            '0',      // popUsed
            '0',      // comboSoloUsed
            '0',      // comboDuoUsed
            '0',      // comboGoldUsed
            '0',      // thirdUsed
            false,    // hasPop
            false,    // hasComboSolo
            false,    // hasComboDuo
            false,    // hasComboGold
            false,    // hasThird
            false,    // hasTsel10k
            '0',      // tsel used
            phoneFallback,
            0,        // points
            '-'       // gradeRw
          );

          pushAkunLoginExport(email, password || passMap.get(normEmail(email)) || '-', phoneFallback);
          mergePatch(email, {
            not_found: true,
            account_status: 'not_found',
            not_found_at: new Date().toISOString()
          });
          pushNotFound({
            email,
            name: nameMap.get(normEmail(email)) || '-',
            phone: phoneMap.get(normEmail(email)) || '-',
            password: password || passMap.get(normEmail(email)) || '-',
            pin: PIN_DEFAULT
          });
          return;
        }

        // default gagal (selain not found)
        console.log(chalk.red('FAIL'), chalk.white(email), chalk.gray('â€”'), chalk.yellow(reason), chalk.gray(`â€¢ Done ${idx+1}/${akunList.length}`));
        resultRows[idx] = [
          idx+1, email, '-', 'FAIL', '-', '-', '-', '-', '-', '-', '-', 'âœ–',
          '-', '-',
          '-', '0',
          '-', '0',
          '-', '0',
          '-', '0',
          '-', '0',
          '-', '-', '-', '-', '-', '-', '-', chalk.red('NO'), chalk.gray('-')
        ];
        const phoneFallback = phoneMap.get(normEmail(email)) || '-';

        appendAllAccountsAt(
          idx,
          email,
          password || '-',
          0,
          '-',      // lastMovie
          '-',      // joinD8
          '-',      // joinAgeDays
          '-',      // birthday
          '-',      // bdayLeft
          '0',
          '0',
          '0',
          '0',
          '0',
          false,false,false,false,false,
          false,
          '0',
          phoneFallback,
          0,
          '-'       // gradeRw
        );

        pushAkunLoginExport(email, password || passMap.get(normEmail(email)) || '-', phoneFallback);
        return;
      }
      const token   = login.token;
      const usedPwd = login.usedPwd;

      // gunakan preInfo (hasil validasi bearer) kalau tersedia
      let info = login.preInfo;
      if (!info) {
        try {
          info = await getMemberInfoSafe(token, accHeaders);
        } catch {
          await delay(RETRY_INFO_BACKOFF_MS);
          try { info = await getMemberInfoSafe(token, accHeaders); } catch {}
        }
      }
      if (!info?.RESULTS?.ds_mbrList) {
        failCnt++;
        console.log(chalk.red('FAIL'), chalk.white(email), chalk.gray('â€”'), chalk.yellow('Cannot fetch member info'), chalk.gray(`â€¢ Done ${idx+1}/${akunList.length}`));
        resultRows[idx] = [
          idx+1, email, '-', 'FAIL', '-', '-', '-', '-', '-', '-', '-', 'âœ–',
          '-', '-',
          '-', '0',
          '-', '0',
          '-', '0',
          '-', '0',
          '-', '0',
          '-', '-', '-', '-', '-', '-', '-', chalk.red('NO'), chalk.gray('-')
        ];
        const phoneFallback = phoneMap.get(normEmail(email)) || '-';

        appendAllAccountsAt(
          idx,
          email,
          usedPwd || (password || '-'),
          0,
          '-',  // lastMovie placeholder
          '-', '-', // join
          '-', '-', // birthday, bLeft
          '0','0','0','0','0',
          false,false,false,false,false,
          false,
          '0',
          phoneFallback,
          0,
          '-'       // gradeRw
        );

        pushAkunLoginExport(email, usedPwd || password || passMap.get(normEmail(email)) || '-', phoneFallback);
        const bearerPatch = (login.via === 'login') ? {
          bearer: token,
          bearer_wrapped: wrapBearer3(token),
          bearer_updated_at: new Date().toISOString()
        } : {};
        if (usedPwd && usedPwd !== password) {
          mergePatch(email, { password: usedPwd, password_updated_at: new Date().toISOString(), ...bearerPatch });
        } else {
          mergePatch(email, { ...bearerPatch });
        }
        return;
      }

      const m = info.RESULTS.ds_mbrList || {};
      const cityName   = m.ADDR_REGION_NM || '-';
      const joinStr    = d8(m.SITE_JOIN_DY);
      const ageDays    = ageDaysFromD8(m.SITE_JOIN_DY);

      // voucher normalize
      const coupons = info.RESULTS?.ds_CPN_LIST || [];
      const gifts   = info.RESULTS?.ds_GFT_LIST || [];
      const vouchersAll = [
        ...coupons.map(v => normalizeVoucher(v, 'coupon')),
        ...gifts.map(v => normalizeVoucher(v, 'gift')),
      ];
      const vouchersActive = vouchersAll.filter(v => v.is_active_unused === true);
      const voucherCountTotal  = vouchersAll.length;
      const voucherCountActive = vouchersActive.length;
      const hasTselActive = vouchersAll.some(v => isTelkomselFlatprice10k(v) && v.is_active_unused === true && v.is_expired === false);

      const hasBD = vouchersAll.some(v =>
        /birthday/i.test(String(v.name || '')) ||
        /birthday/i.test(String(v.note || ''))
      );

      const points      = Number(m.ACCU_POINT ?? m.MILEAGE_AMT ?? 0);
      const totalSpend  = Number(m.TOT_PAY_AMT_FOR_UI ?? m.TOT_PAY_AMT ?? 0);
      const visits      = Number(m.TOT_VISIT_FOR_UI ?? 0);
      const tierName    = m.MBR_GRD_NM || m.MBR_TIER_NM || 'NEW';
      const favTh       = m.JOIN_THAT_NM || '-';

      const gradeList = Array.isArray(info.RESULTS?.ds_MemberGradeStandard_LIST)
        ? info.RESULTS.ds_MemberGradeStandard_LIST : [];
      const findGrade = (disp, code) =>
        gradeList.find(g => new RegExp(disp, 'i').test(g.MBR_GRD_DISP_NM || '') || g.MBR_GRD_CD === code);
      const gold = findGrade('Gold','02');
      const vip  = findGrade('VIP','03');
      const goldSpendMin = Number(gold?.MBR_GRD_CALC_MIN_VAL  ?? 0);
      const goldVisitMin = Number(gold?.MBR_GRD_CALC_MIN_VAL2 ?? 0);
      const vipSpendMin  = Number(vip ?.MBR_GRD_CALC_MIN_VAL  ?? 0);
      const vipVisitMin  = Number(vip ?.MBR_GRD_CALC_MIN_VAL2 ?? 0);

      const needGoldSpend = gold ? Math.max(0, goldSpendMin - totalSpend) : '-';
      const needVipSpend  = vip  ? Math.max(0,  vipSpendMin - totalSpend) : '-';
      const needGoldVisit = gold ? Math.max(0, goldVisitMin - visits)     : '-';
      const needVipVisit  = vip  ? Math.max(0,  vipVisitMin - visits)     : '-';

      // transaksi
      let lastMovieDate = null;
      let lastTxnDate   = null;
      const txR = await fetchTransactions(token, accHeaders);
      const txnsRaw = txR.ok ? txR.data : [];
      if (txR.ok) {
        lastMovieDate = getLastMovieDate(txnsRaw); // movie-only
        lastTxnDate   = getLastTxnDate(txnsRaw);   // all (tetap untuk info patch)
      }

      // â”€â”€ STATUS & USAGE
      const stPop     = detectPopcorn1stVisitStatus(vouchersAll, txnsRaw);
      const stComboS  = detectComboSoloStatus(vouchersAll, txnsRaw);
      const stComboD  = detectComboDuoStatus(vouchersAll, txnsRaw);
      const stComboG  = detectComboGoldStatus(vouchersAll);
      const st3rd     = detect3rdVisitStatus(vouchersAll, visits); // berbasis visits

      const popUse    = detectPopcorn1stVisitUsage(vouchersAll, txnsRaw);
      const cbUseSolo = detectComboSoloUsage(vouchersAll, txnsRaw);
      const cbUseDuo  = detectComboDuoUsage(vouchersAll, txnsRaw);
      const cbUseGold = detectComboGoldUsage(vouchersAll);
      const tselUse   = detectTelkomsel10KUsage(txnsRaw);
      const thirdUsedCount = st3rd.used_times;

      // â”€â”€ BdayLeft
      const birthdayIso = d8(m.BIRTHDAY);
      const bLeft = daysUntilNextBirthday(birthdayIso);

      // >>> [BARU] Kumpulkan akun yang: Age 15â€“30 hari, belum ada transaksi, visits = 0
      (() => {
        const ageNum = Number(ageDays);
        const joinIso = d8(m.SITE_JOIN_DY || '-'); // "YYYY-MM-DD" atau '-'
        const noTxn = !lastTxnDate || lastTxnDate === '-';

        if (Number.isFinite(ageNum) && ageNum >= 15 && ageNum <= 30 && noTxn && Number(visits) === 0) {
          segmentJoin15_30_NoTxn.push({
            email,
            password: usedPwd || password || passMap.get(normEmail(email)) || '-',
            phone: m.MOBILE_NO || phoneMap.get(normEmail(email)) || '-',
            join_date: joinIso,
            age_days: ageNum,
            visits: 0,
            last_txn: '-'
          });
        }

        // akun SUDAH >30 hari, belum transaksi, visits=0
        if (Number.isFinite(ageNum) && ageNum >= 30 && noTxn && Number(visits) === 0) {
          segmentOver30_NoTxn.push({
            email,
            password: usedPwd || password || passMap.get(normEmail(email)) || '-',
            phone: m.MOBILE_NO || phoneMap.get(normEmail(email)) || '-',
            join_date: joinIso,
            age_days: ageNum,
            visits: 0,
            last_txn: '-'
          });
        }
      })();

      // [TAMBAHAN] Segmen "mendekati" berdasarkan visits
      const v = Number(visits || 0);
      const segPush = (bucket) => bucket.push({
        email,
        phone: m.MOBILE_NO || phoneMap.get(normEmail(email)) || '-',
        visits: v,
        lastMovie: lastMovieDate || '-'
      });

      if (v === 1 || v === 2)   segPush(segmentNear3);   // mendekati 3rd visit
      if (v >= 4 && v <= 7)     segPush(segmentNear8);   // mendekati Gold (8)
      if (v >= 9 && v <= 14)    segPush(segmentNear15);  // mendekati VIP (15)

      // [BARU] Segmen Combo Solo aktif & Combo Duo aktif
      // kita cek voucherAll untuk voucher combo yg masih aktif & belum expired
      // NOTE:
      // - Combo Solo -> regex /combo\s*solo/i (udah dipakai di detectComboSoloStatus)
      // - Combo Duo  -> regex /combo\s*duo/i
      // Masuk list kalau ada voucher aktif_unused === true dan !is_expired
      const phoneNow = m.MOBILE_NO || phoneMap.get(normEmail(email)) || '-';
      const pwdNow   = usedPwd || password || passMap.get(normEmail(email)) || '-';
      const lastTxnDecor = lastTxnDate || '-';

      let hasComboSoloActive = false;
      let hasComboDuoActive  = false;
      for (const vv of vouchersAll) {
        if (!vv || vv.is_expired) continue;
        const nmLow = String(vv.name || vv.note || vv.benefit_name || '').toLowerCase();
        if (vv.is_active_unused === true) {
          if (/combo\s*solo/i.test(nmLow)) hasComboSoloActive = true;
          if (/combo\s*duo/i.test(nmLow))  hasComboDuoActive  = true;
        }
      }

      if (hasComboSoloActive) {
        segmentComboSoloActive.push({
          email,
          password: pwdNow,
          phone: phoneNow,
          visits: v,
          last_txn: lastTxnDecor,
          comboType: 'SOLO'
        });
      }

      if (hasComboDuoActive) {
        segmentComboDuoActive.push({
          email,
          password: pwdNow,
          phone: phoneNow,
          visits: v,
          last_txn: lastTxnDecor,
          comboType: 'DUO'
        });
      }

      // >>> [BARU] Kumpulkan akun yg masih punya voucher Combo Solo aktif
      // definisi:
      // - stComboS.has_active === true
      // - Untuk Birthday: belum pernah dipakai (used_times === 0)
      // - Untuk Gold/VIP tier: tetap masuk meskipun sudah pernah dipakai
      if (stComboS.has_active) {
        // cari voucher Combo Solo aktifnya, ambil nama voucher & tipe
        const soloVouchers = vouchersAll.filter(v =>
          /combo\s*solo/i.test(String(v.name||'')) &&
          v.is_active_unused === true &&
          v.is_expired === false
        );
        soloVouchers.forEach(v => {
          // tipe campaign = prefix sebelum ":" jika ada
          let voucherType = '-';
          let voucherName = v.name || '-';
          const voucherNameLower = voucherName.toLowerCase();

          // Klasifikasi berdasarkan nama voucher
          if (/birthday/i.test(voucherName)) {
            voucherType = 'Birthday Treat';
          } else if (/^gold\s*:/i.test(voucherName) || voucherNameLower.includes('gold')) {
            voucherType = 'Gold Rewards';
          } else if (voucherName.includes(':')) {
            voucherType = voucherName.split(':')[0].trim();
          } else {
            voucherType = classifyVoucherType(v); // fallback
          }

          // Ambil tanggal expired dari voucher yang sudah dinormalisasi
          const expiredDateFull = v.end_at || v.valid_to || '-';
          const expiredDate = expiredDateFull && expiredDateFull !== '-'
            ? expiredDateFull.split(' ')[0]  // Ambil hanya bagian tanggal (YYYY-MM-DD)
            : '-';
          const daysLeft = v.days_left != null ? v.days_left : null;

          comboSoloActiveList.push({
            email,
            phone: m.MOBILE_NO || phoneMap.get(normEmail(email)) || '-',
            visits,
            voucherName,
            voucherType,
            usedTimes: cbUseSolo.used_times || 0,
            tier: tierName || '-',
            expiredDate,
            daysLeft,
            lastMovieDate: lastMovieDate || '-'
          });
        });
      }

      // >>> [BARU] Kumpulkan akun yg masih punya voucher Combo Duo aktif
      // definisi:
      // - stComboD.has_active === true
      // - Untuk Birthday: belum pernah dipakai (used_times === 0)
      // - Untuk VIP tier: tetap masuk meskipun sudah pernah dipakai
      if (stComboD.has_active) {
        const duoVouchers = vouchersAll.filter(v =>
          /combo\s*duo/i.test(String(v.name||'')) &&
          v.is_active_unused === true &&
          v.is_expired === false
        );
        duoVouchers.forEach(v => {
          let voucherType = '-';
          let voucherName = v.name || '-';
          const voucherNameLower = voucherName.toLowerCase();
          const tierLower = (tierName || '').toLowerCase();

          // Klasifikasi berdasarkan nama voucher dan tier
          if (/birthday/i.test(voucherName)) {
            voucherType = 'Birthday Treat';
          } else if (tierLower.includes('vip') || /^vip\s*:/i.test(voucherName) || voucherNameLower.includes('vip')) {
            voucherType = 'VIP Rewards';
          } else if (voucherName.includes(':')) {
            voucherType = voucherName.split(':')[0].trim();
          } else {
            voucherType = classifyVoucherType(v);
          }

          // Ambil tanggal expired dari voucher yang sudah dinormalisasi
          const expiredDateFull = v.end_at || v.valid_to || '-';
          const expiredDate = expiredDateFull && expiredDateFull !== '-'
            ? expiredDateFull.split(' ')[0]  // Ambil hanya bagian tanggal (YYYY-MM-DD)
            : '-';
          const daysLeft = v.days_left != null ? v.days_left : null;

          comboDuoActiveList.push({
            email,
            phone: m.MOBILE_NO || phoneMap.get(normEmail(email)) || '-',
            visits,
            voucherName,
            voucherType,
            usedTimes: cbUseDuo.used_times || 0,
            tier: tierName || '-',
            expiredDate,
            daysLeft
          });
        });
      }

      // >>> [BARU] Kumpulkan akun yg masih punya voucher 2D ALL DAYS aktif
      const voucher2DAllDays = vouchersAll.filter(v =>
        /2D.*ALL\s*DAYS.*Complimentary\s*Member\s*Rewards/i.test(String(v.name||'')) &&
        v.is_active_unused === true &&
        v.is_expired === false
      );
      voucher2DAllDays.forEach(v => {
        let voucherType = 'Gold Rewards'; // Default untuk voucher ini
        let voucherName = v.name || '-';
        if (voucherName.includes(':')) {
          voucherType = voucherName.split(':')[0].trim();
        } else if (!/gold/i.test(voucherName)) {
          voucherType = classifyVoucherType(v);
        }

        // Ambil tanggal expired dari voucher yang sudah dinormalisasi
        const expiredDateFull = v.end_at || v.valid_to || '-';
        const expiredDate = expiredDateFull && expiredDateFull !== '-'
          ? expiredDateFull.split(' ')[0]  // Ambil hanya bagian tanggal (YYYY-MM-DD)
          : '-';
        const daysLeft = v.days_left != null ? v.days_left : null;

        voucher2DAllDaysActiveList.push({
          email,
          phone: m.MOBILE_NO || phoneMap.get(normEmail(email)) || '-',
          visits,
          voucherName,
          voucherType,
          usedTimes: 0,
          tier: tierName || '-',
          expiredDate,
          daysLeft,
          lastMovieDate: lastMovieDate || '-'
        });
      });

      const tierColored    = colorTier(tierName);
      const visitsColored  = colorVisits(visits, goldVisitMin, vipVisitMin);
      const needGoldSpendC = colorNeedMoney(needGoldSpend);
      const needVipSpendC  = colorNeedMoney(needVipSpend);
      const needGoldVisitC = colorNeedVisit(needGoldVisit);
      const needVipVisitC  = colorNeedVisit(needVipVisit);

      // (BARU) VIP ONLY â€” cek grade reward
      let gradeRwText = chalk.gray('-'); // default non-VIP
      let gradeRwPlain = '-'; // plain text untuk file
      if (/^vip$/i.test(String(tierName || '').trim())) {
        let options = [];
        try {
          const gr = await fetchGradeReward(token, accHeaders);
          if (gr.ok) {
            const data = Array.isArray(gr.data) ? gr.data : [];
            options = data.map(g => ({
              id: g?.id,
              names: Array.isArray(g?.reward) ? g.reward.map(r => r?.name).filter(Boolean) : []
            })).filter(o => o.id && o.names.length);
          }
        } catch {}
        if (options.length > 0) {
          gradeRwText = chalk.green(`Tersedia (${options.length} opsi)`);
          gradeRwPlain = `Tersedia (${options.length} opsi)`;
          vipCandidates.push({ email, token, accHeaders, tierName, options });
          vipGradeRwByEmail.set(normEmail(email), { count: options.length, options });
        } else {
          gradeRwText = chalk.yellow('Tidak ada');
          gradeRwPlain = 'Tidak ada';
          vipGradeRwByEmail.set(normEmail(email), { count: 0, options: [] });
        }
      }

      console.log(
        chalk.green('OK'),
        chalk.white(email),
        chalk.gray('â†’'),
        chalk.cyan(m.MBR_NM || '-'),
        chalk.gray('|'), tierColored,
        chalk.gray('â€¢'), `${fmtID(points)} pts`,
        chalk.gray('â€¢'), `${fmtID(totalSpend)} spend`,
        chalk.gray('â€¢'), (m.MOBILE_NO || '-'),
        chalk.gray('â€¢'), (cityName),
        chalk.gray('â€¢'), `V-HP:${m.VERF_MOB_YN === '1' ? 'âœ”' : 'âœ–'}`,
        chalk.gray('â€¢'), `Vouchers:${voucherCountActive}/${voucherCountTotal}`,
        chalk.gray('â€¢'), `LastMovie:${lastMovieDate || '-'}`,
        chalk.gray('â€¢'), `1stPopUsed:${popUse.used_times}`,
        chalk.gray('â€¢'), `ComboSoloUsed:${cbUseSolo.used_times}`,
        chalk.gray('â€¢'), `ComboDuoUsed:${cbUseDuo.used_times}`,
        chalk.gray('â€¢'), `ComboGoldUsed:${cbUseGold.used_times}`,
        chalk.gray('â€¢'), `3rdUsed:${thirdUsedCount}`,
        chalk.gray('â€¢'), `Tsel10KUsed:${tselUse.used_times}`,
        chalk.gray('â€¢'), `BLeft:${bLeft === '-' ? '-' : renderBLeftPlain(bLeft)}`,
        chalk.gray('â€¢'), `GradeRw:${(gradeRwText)}`,
        chalk.gray('â€¢'), `Done ${idx+1}/${akunList.length}`)
      ;

      const ageColored = (() => {
        if (ageDays === '-') return '-';
        const n = Number(ageDays);
        if (Number.isNaN(n)) return ageDays;
        return n >= 30 ? chalk.green(ageDays) : chalk.red(ageDays);
      })();

      // simpan row (tabel konsol)
      resultRows[idx] = [
        idx + 1,
        email,
        m.MBR_NM || '-',
        tierColored,
        fmtID(points),
        m.MOBILE_NO || '-',
        cityName,
        joinStr,
        ageColored,
        birthdayIso,
        colorBLeft(bLeft),
        m.VERF_MOB_YN === '1' ? 'âœ”' : 'âœ–',
        visitsColored,
        lastMovieDate || '-',
        colorPopcornStatus(stPop.status),
        colorUsagePresence(popUse.used_times, !!stPop.has_active),
        colorComboStatus(stComboS.status),
        colorUsagePresence(cbUseSolo.used_times, !!stComboS.has_active),
        colorComboStatus(stComboD.status),
        colorUsagePresence(cbUseDuo.used_times, !!stComboD.has_active),
        colorComboStatus(stComboG.status),
        colorUsagePresence(cbUseGold.used_times, !!stComboG.has_active),
        colorThirdStatus(st3rd.status),
        colorUsagePresence(thirdUsedCount, !!st3rd.has_active),
        `${voucherCountActive}/${voucherCountTotal}`,
        favTh,
        fmtID(totalSpend),
        needGoldSpendC,
        needVipSpendC,
        needGoldVisitC,
        needVipVisitC,
        hasBD ? chalk.green('YES') : chalk.red('NO'),
        gradeRwText
      ];

      // Ringkasan voucher non-expired (atas tabel)
      for (const v of vouchersAll) {
        if (v?.is_expired) continue;
        const tName = classifyVoucherType(v);
        appendVoucherLine(
          email,
          usedPwd || (password || '-'),
          tName,
          v?.name || '-',
          v?.valid_from || v?.start_at || '-',
          v?.valid_to   || v?.end_at   || '-'
        );
      }

      appendAllAccountsAt(
        idx,
        email,
        usedPwd || (password || '-'),
        visits,
        lastMovieDate,                 // khusus movie untuk file
        m.SITE_JOIN_DY || '-',         // joinD8 (raw yyyymmdd)
        ageDays,                       // umur (hari)
        birthdayIso,
        bLeft,
        Number(popUse.used_times),
        Number(cbUseSolo.used_times),
        Number(cbUseDuo.used_times),
        Number(cbUseGold.used_times),
        Number(thirdUsedCount),
        !!stPop.has_active,
        !!stComboS.has_active,
        !!stComboD.has_active,
        !!stComboG.has_active,
        !!st3rd.has_active,
        !!hasTselActive,
        Number(tselUse.used_times),
        (m.MOBILE_NO || phoneMap.get(normEmail(email)) || '-'), // PHONE
        points,
        gradeRwPlain
      );

      // ====== FILL allAccRecs[idx] NOW (after lastMovieDate is available) ======
      allAccRecs[idx] = {
        idx,
        email,
        line: allAccLines[idx],
        visits: Number(visits || 0),
        bdayLeftNum: (bLeft === '-' || bLeft == null || isNaN(Number(bLeft)))
          ? Number.POSITIVE_INFINITY
          : Number(bLeft),
        phoneRaw: m.MOBILE_NO || phoneMap.get(normEmail(email)) || '-',
        points: Number(points || 0),
        lastTxnDate: lastTxnDate || null,
        lastMovieDate: lastMovieDate || null
      };

      // ====== KUMPULKAN PATCH UNTUK account.json (tidak menulis sekarang) ======
      const bearerPatch =
        (login.via === 'login')
          ? { bearer: token, bearer_wrapped: wrapBearer3(token), bearer_updated_at: new Date().toISOString() }
          : {};

      const passPatch =
        (usedPwd && usedPwd !== password)
          ? { password: usedPwd, password_updated_at: new Date().toISOString() }
          : {};

      const infoPatch = {
        login_ok: true,
        name: m.MBR_NM || '-',
        gender: (m.SEC_CD === '01') ? 'Male' : (m.SEC_CD === '02') ? 'Female' : '-',
        gender_code: m.SEC_CD || null,
        email_id: m.EMAIL_ID || null,
        member_no: m.MBR_NO || null,
        address: m.ADDR_STREET || null,
        city_id: m.ADDR_REGION_CD || null,
        city_name: m.ADDR_REGION_NM || cityName || null,
        fav_theater_code: m.FAV_THAT_CD || null,
        sale_channel_code: m.SALE_CHNL_CD || null,
        verified_email: m.VERF_EMAIL_YN === '1',

        tier: m.MBR_GRD_NM || m.MBR_TIER_NM || 'NEW',
        points,
        phone: m.MOBILE_NO || (phoneMap.get(normEmail(email)) || '-'),
        city: cityName,
        join_date: joinStr,
        age_days: ageDays === '-' ? null : Number(ageDays),
        birthday: birthdayIso,
        birthday_days_left: (bLeft === '-' ? null : bLeft),
        next_birthday_date: (birthdayIso && birthdayIso !== '-') ? (() => {
          const [Y,M,D] = birthdayIso.split('-').map(n=>Number(n));
          const now = new Date();
          let yr = now.getFullYear();
          let dt = new Date(yr, M-1, D);
          if (dt < new Date(now.getFullYear(), now.getMonth(), now.getDate())) dt = new Date(++yr, M-1, D);
          const pad=(n)=>String(n).padStart(2,'0');
          return `${dt.getFullYear()}-${pad(dt.getMonth()+1)}-${pad(dt.getDate())}`;
        })() : null,

        verified_phone: m.VERF_MOB_YN === '1',
        visits,
        fav_theater: m.JOIN_THAT_NM || '-',
        total_spend: totalSpend,
        has_birthday_voucher: hasBD,
        last_movie_date: lastMovieDate || null,
        last_txn_date: lastTxnDate || null,
        voucher_count: voucherCountTotal,
        voucher_count_active: voucherCountActive,
        voucher_details: vouchersAll,
        voucher_details_active: vouchersActive,

        popcorn_1st_visit_status: stPop.status,
        popcorn_1st_visit_has_active: stPop.has_active,
        popcorn_1st_visit_used_before: stPop.used_before,
        popcorn_1st_visit_last_used_at: stPop.last_used_at || null,

        combo_solo_status: stComboS.status,
        combo_solo_has_active: stComboS.has_active,
        combo_solo_used_before: stComboS.used_before,
        combo_solo_last_used_at: stComboS.last_used_at || null,
        combo_solo_used_times: cbUseSolo.used_times || 0,

        combo_duo_status: stComboD.status,
        combo_duo_has_active: stComboD.has_active,
        combo_duo_used_before: stComboD.used_before,
        combo_duo_last_used_at: stComboD.last_used_at || null,
        combo_duo_used_times: cbUseDuo.used_times || 0,

        combo_gold_status: stComboG.status,
        combo_gold_has_active: stComboG.has_active,
        combo_gold_used_before: stComboG.used_before,
        combo_gold_last_used_at: stComboG.last_used_at || null,
        combo_gold_used_times: cbUseGold.used_times || 0,

        third_visit_b1g1_status: st3rd.status,
        third_visit_b1g1_has_active: st3rd.has_active,
        third_visit_b1g1_used_times: thirdUsedCount || 0,
        third_visit_b1g1_last_used_at: st3rd.last_used_at || null,

        popcorn_1st_visit_used_times: popUse.used_times,
        tsel10k_used_times: tselUse.used_times || 0,

        // reset flag not_found kalau ternyata sukses
        not_found: false,
        account_status: 'active'
      };

      mergePatch(email, { ...bearerPatch, ...passPatch, ...infoPatch });

      // Ekspor akunLogin.txt
      pushAkunLoginExport(email, usedPwd || password || passMap.get(normEmail(email)) || '-', infoPatch.phone);

      okCnt++;
      await delay(PER_ACCOUNT_DELAY_MS);
    } catch (e) {
      // fallback error
      failCnt++;
      failMap.set('Unhandled error', (failMap.get('Unhandled error') || 0) + 1);
      console.log(chalk.red('FAIL'), chalk.white(email), chalk.gray('â€”'), chalk.yellow(e?.message || 'Error'), chalk.gray(`â€¢ Done ${idx+1}/${akunList.length}`));
      resultRows[idx] = [
        idx+1, email, '-', 'FAIL', '-', '-', '-', '-', '-', '-', '-', 'âœ–',
        '-', '-',
        '-', '0',
        '-', '0',
        '-', '0',
        '-', '0',
        '-', '0',
        '-', '-', '-', '-', '-', '-', '-', chalk.red('NO'), chalk.gray('-')
      ];
      const phoneFallback = phoneMap.get(normEmail(email)) || '-';

      appendAllAccountsAt(
        idx,
        email,
        '-',
        0,
        '-',      // lastMovie
        '-',      // joinD8
        '-',      // joinAgeDays
        '-',      // birthday
        '-',      // bdayLeft
        '0','0','0','0','0',
        false,false,false,false,false,
        false,
        '0',
        phoneFallback,
        0,
        '-'       // gradeRw
      );

      pushAkunLoginExport(email, passMap.get(normEmail(email)) || '-', phoneFallback);
    } finally {
      clearInterval(hb);
    }
  };

  // â”€â”€ jalankan paralel per sesi (CONCURRENCY)
  const totalSessions = Math.ceil(akunList.length / CONCURRENCY);
  for (let start = 0, batchNo = 1; start < akunList.length; start += CONCURRENCY, batchNo++) {
    const batch = akunList.slice(start, start + CONCURRENCY);
    const i1 = start + 1;
    const i2 = Math.min(start + CONCURRENCY, akunList.length);
    console.log(chalk.gray(`\n[Session ${batchNo}/${totalSessions}] Accounts ${i1}-${i2} â€¢ Per-account header randomization: ON (safe headers)`));
    await Promise.allSettled(
      batch.map((acc, i) => processOne(start + i, acc))
    );
  }

  // tampilkan daftar voucher non-expired per baris (konsol)
  if (voucherLines.length) {
    console.log(chalk.cyan('\nDaftar Voucher (Non-Expired):'));
    const header =
      padR('Email', V_EMAIL_W) + ' | ' +
      padR('Password', V_PWD_W) + '  | ' +
      padR('Type', V_TYPE_W) + ' | ' +
      padR('Voucher Name', V_NAME_W) + ' â”‚ ' +
      padR('Valid From', V_D_W) + ' â”‚ ' +
      padR('Valid To', V_D_W);
    console.log(chalk.gray(header));
    console.log(chalk.gray('-'.repeat(header.length)));
    for (const line of voucherLines) console.log(line);
    console.log();
  }

  // tampilkan tabel hasil (urut no akun)
  for (let i = 0; i < resultRows.length; i++) {
    if (resultRows[i]) resultTable.push(resultRows[i]);
  }
  console.log('\n' + resultTable.toString());

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // (BARU) ALUR REDEEM â€” HANYA VIP DENGAN REWARD
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const vipWithReward = vipCandidates.filter(c => Array.isArray(c.options) && c.options.length > 0);
  if (vipWithReward.length === 0) {
    console.log(chalk.yellow('\n[Grade Reward] Tidak ada grade reward yang tersedia pada akun VIP.'));
  } else {
    console.log(chalk.cyan(`\n[Grade Reward] Ditemukan ${vipWithReward.length} akun VIP dengan reward tersedia.`));
    // Konfirmasi mau redeem?
    let doRedeem = true;
    try {
      const ans = await inquirer.prompt([{
        type: 'confirm',
        name: 'go',
        message: 'Ingin redeem grade reward sekarang?',
        default: true
      }]);
      doRedeem = !!ans.go;
    } catch { doRedeem = false; }

    const redeemedOK = [];
    const redeemedFail = [];

    // Ambil grade info VIP (sekali)
    let vipGradeInfoList = null;
    if (doRedeem) {
      const any = vipWithReward[0];
      vipGradeInfoList = await fetchGradeInfoVIP(any.token, any.accHeaders);
    }

    // loop pilih akun â†’ pilih reward â†’ redeem
    while (doRedeem && vipWithReward.length > 0) {
      const choices = vipWithReward.map((c, idx) => {
        const label = `${c.email} â€” VIP (${c.options.length} opsi)`;
        return { name: label, value: idx };
      });
      choices.push(new inquirer.Separator());
      choices.push({ name: 'Selesai / Tutup', value: 'done' });

      let pickIdx;
      try {
        const pick = await inquirer.prompt([{
          type: 'list',
          name: 'which',
          message: 'Pilih akun untuk redeem:',
          choices
        }]);
        pickIdx = pick.which;
      } catch {
        pickIdx = 'done';
      }
      if (pickIdx === 'done') break;

      const target = vipWithReward[pickIdx];
      if (!target) break;

      // tampilkan Grade Info VIP (ringkas)
      if (Array.isArray(vipGradeInfoList) && vipGradeInfoList.length) {
        console.log(chalk.gray('\nGrade Info (VIP):'));
        vipGradeInfoList.forEach((gi) => {
          const cat = gi?.category ? String(gi.category) : '-';
          const desc = gi?.description ? String(gi.description) : '';
          console.log('  â€¢', cat, desc ? `â€” ${desc}` : '');
        });
      }

      // susun opsi reward (join semua nama dalam satu ID)
      const rewardChoices = target.options.map(o => {
        const title = `[ID ${o.id}] ${o.names.join(' + ')}`;
        return { name: title, value: String(o.id) };
      });

      let chosenId;
      try {
        const p2 = await inquirer.prompt([{
          type: 'list',
          name: 'rid',
          message: `Pilih reward untuk ${target.email}:`,
          choices: rewardChoices
        }]);
        chosenId = p2.rid;
      } catch { chosenId = null; }

      if (!chosenId) {
        let cont = true;
        try {
          const cfm = await inquirer.prompt([{
            type:'confirm', name:'cont', message:'Batal memilih reward. Lanjut pilih akun lain?', default:true
          }]);
          cont = !!cfm.cont;
        } catch {}
        if (!cont) break;
        continue;
      }

      // konfirmasi terakhir
      const picked = target.options.find(o => String(o.id) === String(chosenId));
      const pickedTitle = picked ? picked.names.join(' + ') : `ID ${chosenId}`;
      let okGo = true;
      try {
        const c3 = await inquirer.prompt([{
          type:'confirm',
          name:'cfm',
          message:`Yakin redeem: ${pickedTitle} ?`,
          default:true
        }]);
        okGo = !!c3.cfm;
      } catch { okGo = false; }
      if (!okGo) continue;

      // DO REDEEM
      console.log(chalk.cyan(`â†’ Redeeming ${target.email}: ${pickedTitle} â€¦`));
      const res = await postSelectReward(target.token, chosenId, target.accHeaders);
      if (res.ok && String(res?.json?.status_code) === '200' && (res?.json?.status === true || /success/i.test(String(res?.json?.message||'')))) {
        // verifikasi ulang â€” cek masih ada reward?
        const after = await fetchGradeReward(target.token, target.accHeaders);
        const left = (after.ok && Array.isArray(after.data)) ? after.data.length : 0;
        redeemedOK.push({ email: target.email, id: chosenId, title: pickedTitle, left });
        console.log(chalk.green(`âœ“ Berhasil redeem untuk ${target.email}: ${pickedTitle}`));
        // perbarui list vipWithReward
        if (left <= 0) {
          vipWithReward.splice(pickIdx, 1); // hilangkan dari daftar
        } else {
          const newOpts = (after.data || []).map(g => ({
            id: g?.id,
            names: Array.isArray(g?.reward) ? g.reward.map(r => r?.name).filter(Boolean) : []
          })).filter(o => o.id && o.names.length);
          target.options = newOpts;
          vipWithReward[pickIdx] = target;
        }
      } else {
        const msg = res?.json?.message || res?.error || 'Redeem gagal';
        redeemedFail.push({ email: target.email, id: chosenId, title: pickedTitle, message: msg });
        console.log(chalk.red(`âœ— Gagal redeem untuk ${target.email}: ${msg}`));
      }

      if (vipWithReward.length > 0) {
        let again = true;
        try {
          const more = await inquirer.prompt([{
            type:'confirm', name:'again', message:'Redeem akun VIP lain?', default:true
          }]);
          again = !!more.again;
        } catch {}
        if (!again) break;
      }
    }

    // RINGKASAN REDEEM
    console.log(chalk.cyan('\n[Grade Reward] Ringkasan Redeem (VIP):'));
    if (!vipCandidates.length) {
      console.log(chalk.gray('Tidak ada akun VIP di sesi ini.'));
    } else {
      const avail = vipCandidates.filter(x => x.options.length>0).length;
      console.log(`- VIP ditemukan: ${vipCandidates.length} akun`);
      console.log(`- VIP dengan reward tersedia: ${avail} akun`);
      console.log(`- Redeem sukses: ${redeemedOK.length}`);
      console.log(`- Redeem gagal: ${redeemedFail.length}`);
      if (redeemedOK.length) {
        redeemedOK.forEach((r,i)=>{
          console.log(chalk.green(`  [OK#${i+1}] ${r.email} â†’ ${r.title} (sisa opsi: ${r.left})`));
        });
      }
      if (redeemedFail.length) {
        redeemedFail.forEach((r,i)=>{
          console.log(chalk.red(`  [NG#${i+1}] ${r.email} â†’ ${r.title} â€” ${r.message}`));
        });
      }
      if (avail === 0) {
        console.log(chalk.yellow('Tidak ada grade reward yang bisa diredeem pada akun VIP.'));
      }
    }
  }

  // â”€â”€ TULIS allaccounts.txt (FORMAT BARU + SEGMENT TAMBAHAN + COMBO DUO LISTS)
  try {
    const headerLine =
      padR('Email', EMAIL_W)               + ' | ' +
      padR('Password', PWD_W)              + ' | ' +
      padR('Phone', PHONE_W)               + ' | ' +
      padR('Points', POINTS_W)             + ' | ' +
      padR('Visits', VIS_W)                + ' | ' +
      padR('LastTxn Movie', LASTTXN_W)     + ' | ' +
      padR('JoinAt', JOIN_W)               + ' | ' +
      padR('Birthday', DATE_W)             + ' | ' +
      padR('BdayLeft', BLEFT_W)            + ' | ' +
      padR('1stVisitPopcorn', HV1_W)       + ' | ' +
      padR('Combo Solo', HV2_W)            + ' | ' +
      padR('Combo Duo', HV2B_W)            + ' | ' +
      padR('Combo Gold', HV2C_W)           + ' | ' +
      padR('3rdVisitB1G1', HV3_W)          + ' | ' +
      padR('Tsel10KAvail', HV4_W)          + ' | ' +
      padR('1stPopUsed', U1_W)             + ' | ' +
      padR('ComboUsed', U2_W)              + ' | ' +
      padR('DuoUsed', U2B_W)               + ' | ' +
      padR('GoldUsed', U2C_W)              + ' | ' +
      padR('3rdUsed', U3_W)                + ' | ' +
      padR('Tsel10KUsed', U4_W)            + ' | ' +
      padR('GradeRw', 20);

    const sep = '-'.repeat(headerLine.length);

    // Visits desc â†’ BdayLeft asc
    const recs = allAccRecs.filter(Boolean).sort((a,b) => {
      if (b.visits !== a.visits) return b.visits - a.visits;
      if (a.bdayLeftNum !== b.bdayLeftNum) return a.bdayLeftNum - b.bdayLeftNum;
      return String(a.email).localeCompare(String(b.email));
    });

    const totalLines = recs.length;
    const outLines = [];
    outLines.push(`Jumlah Accounts: ${totalLines}`);
    outLines.push(sep);
    outLines.push(headerLine);
    outLines.push(sep);
    for (const r of recs) {
      outLines.push(r.line);
    }
    outLines.push(sep);

    // [ADDED] CSV nomor-only: Semua Akun (urut Visits tertinggi â†’ terendah)
    const phonesAllCsv = recs
      .map(r => phoneNomorOnly(r.phoneRaw))
      .filter(Boolean)
      .join(',');
    outLines.push('');
    outLines.push('Nomor HP (Semua Akun, urut Visits tertinggi â†’ terendah):');
    outLines.push(phonesAllCsv);
    outLines.push(sep);

    // >>> [TETAP] blok segmen mendekati 30 hari (15â€“30 hari)
    outLines.push('');
    outLines.push('===========================================================================');
    outLines.push(`AKUN YANG MAU MENDEKATI 30 DAYS TERUS TRANSAKSI BELUM ADA DAN VISIT MASIH 0 (${segmentJoin15_30_NoTxn.length} akun)`);
    outLines.push('===========================================================================');

    // header mini untuk segmen (ringkas & rapi)
    const WSEG = { email:35, pwd:20, phone:16, join:10, age:6, visits:6, last:10 };
    const segHeader =
      padR('Email', WSEG.email) + ' | ' +
      padR('Password', WSEG.pwd) + ' | ' +
      padR('Phone', WSEG.phone) + ' | ' +
      padR('JoinAt', WSEG.join) + ' | ' +
      padR('AgeD', WSEG.age)    + ' | ' +
      padR('Visits', WSEG.visits)+ ' | ' +
      padR('LastTxn', WSEG.last);

    outLines.push(segHeader);
    outLines.push('-'.repeat(segHeader.length));

    // urutkan segmen 15â€“30 hari: Age desc â†’ Email ASC
    const segSorted = segmentJoin15_30_NoTxn.slice().sort((a,b)=>{
      if (a.age_days !== b.age_days) return b.age_days - a.age_days;
      return String(a.email).localeCompare(String(b.email));
    });

    for (const s of segSorted) {
      outLines.push(
        padR(s.email, WSEG.email) + ' | ' +
        clampPad(s.password, WSEG.pwd) + ' | ' +
        padR(s.phone, WSEG.phone) + ' | ' +
        padR(s.join_date || '-', WSEG.join) + ' | ' +
        padR(String(s.age_days), WSEG.age) + ' | ' +
        padR(String(s.visits), WSEG.visits) + ' | ' +
        padR(s.last_txn, WSEG.last)
      );
    }

    // CSV nomor-only segmen 15â€“30 hari
    const segPhonesCsv = segSorted
      .slice()
      .sort((a,b) => {
        const va = Number(a.visits || 0);
        const vb = Number(b.visits || 0);
        if (va !== vb) return vb - va;                  // visits desc
        if (a.age_days !== b.age_days) return b.age_days - a.age_days; // usia join desc
        return String(a.email).localeCompare(String(b.email));
      })
      .map(s => phoneNomorOnly(s.phone))
      .filter(Boolean)
      .join(',');

    outLines.push('');
    outLines.push('Nomor HP (Segment mendekati 30 days, belum trx & visits 0 â€” urut Visits tertinggi â†’ terendah):');
    outLines.push(segPhonesCsv);

    // >>> [BARU] blok segmen SUDAH >30 hari, belum trx & visits 0
    outLines.push('');
    outLines.push('===========================================================================');
    outLines.push(`AKUN YANG SUDAH LEWAT 30 DAYS, BELUM PERNAH TRANSAKSI, DAN VISIT MASIH 0 (${segmentOver30_NoTxn.length} akun)`);
    outLines.push('===========================================================================');

    outLines.push(segHeader);
    outLines.push('-'.repeat(segHeader.length));

    const segOverSorted = segmentOver30_NoTxn.slice().sort((a,b)=>{
      if (a.age_days !== b.age_days) return b.age_days - a.age_days;
      return String(a.email).localeCompare(String(b.email));
    });

    for (const s of segOverSorted) {
      outLines.push(
        padR(s.email, WSEG.email) + ' | ' +
        clampPad(s.password, WSEG.pwd) + ' | ' +
        padR(s.phone, WSEG.phone) + ' | ' +
        padR(s.join_date || '-', WSEG.join) + ' | ' +
        padR(String(s.age_days), WSEG.age) + ' | ' +
        padR(String(s.visits), WSEG.visits) + ' | ' +
        padR(s.last_txn, WSEG.last)
      );
    }

    const segOverPhonesCsv = segOverSorted
      .slice()
      .sort((a,b) => {
        const va = Number(a.visits || 0);
        const vb = Number(b.visits || 0);
        if (va !== vb) return vb - va;
        if (a.age_days !== b.age_days) return b.age_days - a.age_days;
        return String(a.email).localeCompare(String(b.email));
      })
      .map(s => phoneNomorOnly(s.phone))
      .filter(Boolean)
      .join(',');

    outLines.push('');
    outLines.push('Nomor HP (Segment >30 days, belum trx & visits 0 â€” urut Visits tertinggi â†’ terendah):');
    outLines.push(segOverPhonesCsv);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// [BARU] SEGMENT TABLE: 0 VISITS BUT HAS TRANSACTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Collect accounts with 0 visits BUT already has transaction history
const segment0VisitsWithTxn = allAccRecs.filter(r => {
  if (!r) return false;
  const v = Number(r.visits || 0);
  // Check if account has 0 visits BUT has transaction history
  const hasTransaction = r.lastTxnDate && r.lastTxnDate !== '-';
  return v === 0 && hasTransaction;
});

if (segment0VisitsWithTxn.length > 0) {
  outLines.push('');
  outLines.push('===========================================================================');
  outLines.push(`AKUN DENGAN 0 VISIT TAPI SUDAH PERNAH TRANSAKSI (${segment0VisitsWithTxn.length} akun)`);
  outLines.push('===========================================================================');

  const WZEROV = { email:35, phone:16, join:10, age:6, lastMovie:40 };
  const zeroVHeader =
    padR('Email',   WZEROV.email) + ' | ' +
    padR('Phone',   WZEROV.phone) + ' | ' +
    padR('JoinAt',  WZEROV.join)  + ' | ' +
    padR('AgeD',    WZEROV.age)   + ' | ' +
    padR('LastTxn Movie', WZEROV.lastMovie);

  outLines.push(zeroVHeader);
  outLines.push('-'.repeat(zeroVHeader.length));

  // Sort by join date (newest first)
  const sortedZeroV = segment0VisitsWithTxn.slice().sort((a,b)=>{
    return String(b.email).localeCompare(String(a.email));
  });

  for (const r of sortedZeroV) {
    const acc = akunList.find(a => normEmail(a.email) === normEmail(r.email));
    const joinD8 = allAccRecs.find(x => x && normEmail(x.email) === normEmail(r.email));

    // Get join date and age from account.json
    let joinDate = '-';
    let ageD = '-';
    const cached = (accountCache.items || []).find(it => normEmail(it.email) === normEmail(r.email));
    if (cached && cached.join_date) {
      joinDate = cached.join_date;
      ageD = String(cached.age_days || '-');
    }

    outLines.push(
      padR(r.email, WZEROV.email) + ' | ' +
      padR(r.phoneRaw || '-', WZEROV.phone) + ' | ' +
      padR(joinDate, WZEROV.join) + ' | ' +
      padR(ageD, WZEROV.age) + ' | ' +
      padR(r.lastMovieDate || '-', WZEROV.lastMovie)
    );
  }

  const phonesZeroVCsv = sortedZeroV.map(r => phoneNomorOnly(r.phoneRaw)).filter(Boolean).join(',');
  outLines.push('');
  outLines.push(`Nomor HP (0 Visit Tapi Sudah Pernah Transaksi, ${segment0VisitsWithTxn.length} akun):`);
  outLines.push(phonesZeroVCsv);
}

    // CSV sudah dipindahkan ke dalam tabel segment masing-masing

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// [BARU] SEGMENT TABLE: MENDEKATI 3RD VISIT (visits 1-2)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (segmentNear3.length > 0) {
  outLines.push('');
  outLines.push('===========================================================================');
  outLines.push(`MENDEKATI 3RD VISIT (Visits 1-2) â€” ${segmentNear3.length} akun`);
  outLines.push('===========================================================================');

  const WNEAR = { email:35, phone:16, visits:8, lastMovie:40 };
  const nearHeader =
    padR('Email',   WNEAR.email) + ' | ' +
    padR('Phone',   WNEAR.phone) + ' | ' +
    padR('Visits',  WNEAR.visits) + ' | ' +
    padR('LastTxn Movie',  WNEAR.lastMovie);

  outLines.push(nearHeader);
  outLines.push('-'.repeat(nearHeader.length));

  // Sort by visits desc (highest first)
  const sortedNear3 = segmentNear3.slice().sort((a,b)=>{
    if (b.visits !== a.visits) return b.visits - a.visits;
    return String(a.email).localeCompare(String(b.email));
  });

  for (const s of sortedNear3) {
    outLines.push(
      padR(s.email, WNEAR.email) + ' | ' +
      padR(s.phone, WNEAR.phone) + ' | ' +
      padR(String(s.visits), WNEAR.visits) + ' | ' +
      padR(s.lastMovie || '-', WNEAR.lastMovie)
    );
  }

  outLines.push('');
  outLines.push(`Total: ${segmentNear3.length} akun mendekati 3rd visit (visits 1-2)`);

  // CSV Nomor HP untuk segment ini
  const phonesNear3Csv = sortedNear3.map(s => phoneNomorOnly(s.phone)).filter(Boolean).join(',');
  outLines.push('');
  outLines.push(`Nomor HP (Mendekati 3rd visit â€” visits 1â€“2, ${segmentNear3.length} akun):`);
  outLines.push(phonesNear3Csv);
}

    // CSV sudah dipindahkan ke dalam tabel segment masing-masing

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// [BARU] SEGMENT TABLE: MENDEKATI GOLD (visits 4-7)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (segmentNear8.length > 0) {
  outLines.push('');
  outLines.push('===========================================================================');
  outLines.push(`MENDEKATI GOLD (Visits 4-7) â€” ${segmentNear8.length} akun`);
  outLines.push('===========================================================================');

  const WNEAR = { email:35, phone:16, visits:8, lastMovie:40 };
  const nearHeader =
    padR('Email',   WNEAR.email) + ' | ' +
    padR('Phone',   WNEAR.phone) + ' | ' +
    padR('Visits',  WNEAR.visits) + ' | ' +
    padR('LastTxn Movie',  WNEAR.lastMovie);

  outLines.push(nearHeader);
  outLines.push('-'.repeat(nearHeader.length));

  // Sort by visits desc (highest first)
  const sortedNear8 = segmentNear8.slice().sort((a,b)=>{
    if (b.visits !== a.visits) return b.visits - a.visits;
    return String(a.email).localeCompare(String(b.email));
  });

  for (const s of sortedNear8) {
    outLines.push(
      padR(s.email, WNEAR.email) + ' | ' +
      padR(s.phone, WNEAR.phone) + ' | ' +
      padR(String(s.visits), WNEAR.visits) + ' | ' +
      padR(s.lastMovie || '-', WNEAR.lastMovie)
    );
  }

  outLines.push('');
  outLines.push(`Total: ${segmentNear8.length} akun mendekati Gold (visits 4-7)`);

  // CSV Nomor HP untuk segment ini
  const phonesNear8Csv = sortedNear8.map(s => phoneNomorOnly(s.phone)).filter(Boolean).join(',');
  outLines.push('');
  outLines.push(`Nomor HP (Mendekati Gold â€” visits 4â€“7, ${segmentNear8.length} akun):`);
  outLines.push(phonesNear8Csv);
}

    // CSV sudah dipindahkan ke dalam tabel segment masing-masing

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// [BARU] SEGMENT TABLE: MENDEKATI VIP (visits 9-14)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (segmentNear15.length > 0) {
  outLines.push('');
  outLines.push('===========================================================================');
  outLines.push(`MENDEKATI VIP (Visits 9-14) â€” ${segmentNear15.length} akun`);
  outLines.push('===========================================================================');

  const WNEAR = { email:35, phone:16, visits:8, lastMovie:40 };
  const nearHeader =
    padR('Email',   WNEAR.email) + ' | ' +
    padR('Phone',   WNEAR.phone) + ' | ' +
    padR('Visits',  WNEAR.visits) + ' | ' +
    padR('LastTxn Movie',  WNEAR.lastMovie);

  outLines.push(nearHeader);
  outLines.push('-'.repeat(nearHeader.length));

  // Sort by visits desc (highest first)
  const sortedNear15 = segmentNear15.slice().sort((a,b)=>{
    if (b.visits !== a.visits) return b.visits - a.visits;
    return String(a.email).localeCompare(String(b.email));
  });

  for (const s of sortedNear15) {
    outLines.push(
      padR(s.email, WNEAR.email) + ' | ' +
      padR(s.phone, WNEAR.phone) + ' | ' +
      padR(String(s.visits), WNEAR.visits) + ' | ' +
      padR(s.lastMovie || '-', WNEAR.lastMovie)
    );
  }

  outLines.push('');
  outLines.push(`Total: ${segmentNear15.length} akun mendekati VIP (visits 9-14)`);

  // CSV Nomor HP untuk segment ini
  const phonesNear15Csv = sortedNear15.map(s => phoneNomorOnly(s.phone)).filter(Boolean).join(',');
  outLines.push('');
  outLines.push(`Nomor HP (Mendekati VIP â€” visits 9â€“14, ${segmentNear15.length} akun):`);
  outLines.push(phonesNear15Csv);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// [BARU] SEGMENT: AKUN DENGAN VOUCHER COMBO SOLO BIRTHDAY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const comboSoloBirthday = comboSoloActiveList.filter(v => {
  const isBirthday = /birthday/i.test(v.voucherType) || /birthday/i.test(v.voucherName);
  const notUsed = Number(v.usedTimes || 0) === 0;
  return isBirthday && notUsed;
});

if (comboSoloBirthday.length > 0) {
  outLines.push('');
  outLines.push('===========================================================================');
  outLines.push(`VOUCHER COMBO SOLO (dari Birthday, ${comboSoloBirthday.length} akun)`);
  outLines.push('===========================================================================');

  const WCOMBO = { email:35, pwd:20, phone:16, visits:6, lastMovie:40, expired:28 };
  const comboHeader =
    padR('Email',   WCOMBO.email) + ' | ' +
    padR('Password',WCOMBO.pwd)   + ' | ' +
    padR('Phone',   WCOMBO.phone) + ' | ' +
    padR('Visits',  WCOMBO.visits)+ ' | ' +
    padR('LastTxn Movie', WCOMBO.lastMovie) + ' | ' +
    padR('Expired', WCOMBO.expired);

  outLines.push(comboHeader);
  outLines.push('-'.repeat(comboHeader.length));

  const sorted = comboSoloBirthday.slice().sort((a,b)=>{
    if (b.visits !== a.visits) return b.visits - a.visits;
    return String(a.email).localeCompare(String(b.email));
  });

  for (const s of sorted) {
    const acc = akunList.find(a => normEmail(a.email) === normEmail(s.email));
    const pwd = passMap.get(normEmail(s.email)) || acc?.password || '-';
    const expiredCell = formatExpCell(s.expiredDate, s.daysLeft);
    outLines.push(
      padR(s.email, WCOMBO.email) + ' | ' +
      clampPad(pwd, WCOMBO.pwd) + ' | ' +
      padR(s.phone, WCOMBO.phone) + ' | ' +
      padR(String(s.visits), WCOMBO.visits) + ' | ' +
      padR(s.lastMovieDate || '-', WCOMBO.lastMovie) + ' | ' +
      padR(expiredCell, WCOMBO.expired)
    );
  }

  const phonesCsv = sorted.map(s => phoneNomorOnly(s.phone)).filter(Boolean).join(',');
  outLines.push('');
  outLines.push('Nomor HP (Combo Solo Birthday):');
  outLines.push(phonesCsv);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// [BARU] SEGMENT: AKUN DENGAN VOUCHER COMBO SOLO TIER (GOLD/VIP)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const comboSoloGold = comboSoloActiveList.filter(v => {
  const isBirthday = /birthday/i.test(v.voucherType) || /birthday/i.test(v.voucherName);
  if (isBirthday) return false; // Skip birthday vouchers

  // Include vouchers from Gold tier or higher (VIP)
  const tier = String(v.tier || '').toUpperCase();
  return tier === 'GOLD' || tier === 'VIP';
});

if (comboSoloGold.length > 0) {
  outLines.push('');
  outLines.push('===========================================================================');
  outLines.push(`VOUCHER COMBO SOLO (dari Tier > Gold, ${comboSoloGold.length} akun)`);
  outLines.push('===========================================================================');

  const WCOMBO = { email:35, pwd:20, phone:16, visits:6, lastMovie:40, expired:28 };
  const comboHeader =
    padR('Email',   WCOMBO.email) + ' | ' +
    padR('Password',WCOMBO.pwd)   + ' | ' +
    padR('Phone',   WCOMBO.phone) + ' | ' +
    padR('Visits',  WCOMBO.visits)+ ' | ' +
    padR('LastTxn Movie', WCOMBO.lastMovie) + ' | ' +
    padR('Expired', WCOMBO.expired);

  outLines.push(comboHeader);
  outLines.push('-'.repeat(comboHeader.length));

  const sorted = comboSoloGold.slice().sort((a,b)=>{
    if (b.visits !== a.visits) return b.visits - a.visits;
    return String(a.email).localeCompare(String(b.email));
  });

  for (const s of sorted) {
    const acc = akunList.find(a => normEmail(a.email) === normEmail(s.email));
    const pwd = passMap.get(normEmail(s.email)) || acc?.password || '-';
    const expiredCell = formatExpCell(s.expiredDate, s.daysLeft);
    outLines.push(
      padR(s.email, WCOMBO.email) + ' | ' +
      clampPad(pwd, WCOMBO.pwd) + ' | ' +
      padR(s.phone, WCOMBO.phone) + ' | ' +
      padR(String(s.visits), WCOMBO.visits) + ' | ' +
      padR(s.lastMovieDate || '-', WCOMBO.lastMovie) + ' | ' +
      padR(expiredCell, WCOMBO.expired)
    );
  }

  const phonesCsv = sorted.map(s => phoneNomorOnly(s.phone)).filter(Boolean).join(',');
  outLines.push('');
  outLines.push('Nomor HP (Combo Solo Tier > Gold):');
  outLines.push(phonesCsv);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// [BARU] SEGMENT: AKUN DENGAN VOUCHER COMBO DUO BIRTHDAY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const comboDuoBirthday = comboDuoActiveList.filter(v => {
  const isBirthday = /birthday/i.test(v.voucherType) || /birthday/i.test(v.voucherName);
  const notUsed = Number(v.usedTimes || 0) === 0;
  return isBirthday && notUsed;
});

if (comboDuoBirthday.length > 0) {
  outLines.push('');
  outLines.push('===========================================================================');
  outLines.push(`VOUCHER COMBO DUO (dari Birthday, ${comboDuoBirthday.length} akun)`);
  outLines.push('===========================================================================');

  const WCOMBO = { email:35, pwd:20, phone:16, visits:6, expired:28 };
  const comboHeader =
    padR('Email',   WCOMBO.email) + ' | ' +
    padR('Password',WCOMBO.pwd)   + ' | ' +
    padR('Phone',   WCOMBO.phone) + ' | ' +
    padR('Visits',  WCOMBO.visits)+ ' | ' +
    padR('Expired', WCOMBO.expired);

  outLines.push(comboHeader);
  outLines.push('-'.repeat(comboHeader.length));

  const sorted = comboDuoBirthday.slice().sort((a,b)=>{
    if (b.visits !== a.visits) return b.visits - a.visits;
    return String(a.email).localeCompare(String(b.email));
  });

  for (const s of sorted) {
    const acc = akunList.find(a => normEmail(a.email) === normEmail(s.email));
    const pwd = passMap.get(normEmail(s.email)) || acc?.password || '-';
    const expiredCell = formatExpCell(s.expiredDate, s.daysLeft);
    outLines.push(
      padR(s.email, WCOMBO.email) + ' | ' +
      clampPad(pwd, WCOMBO.pwd) + ' | ' +
      padR(s.phone, WCOMBO.phone) + ' | ' +
      padR(String(s.visits), WCOMBO.visits) + ' | ' +
      padR(expiredCell, WCOMBO.expired)
    );
  }

  const phonesCsv = sorted.map(s => phoneNomorOnly(s.phone)).filter(Boolean).join(',');
  outLines.push('');
  outLines.push('Nomor HP (Combo Duo Birthday):');
  outLines.push(phonesCsv);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// [BARU] SEGMENT: AKUN DENGAN VOUCHER COMBO DUO (dari Tier VIP)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const comboDuoVIP = comboDuoActiveList.filter(v => {
  const isBirthday = /birthday/i.test(v.voucherType) || /birthday/i.test(v.voucherName);
  if (isBirthday) return false; // Skip birthday vouchers

  // Include vouchers from VIP tier
  const tier = String(v.tier || '').toUpperCase();
  return tier === 'VIP';
});

if (comboDuoVIP.length > 0) {
  outLines.push('');
  outLines.push('===========================================================================');
  outLines.push(`VOUCHER COMBO DUO (dari Tier VIP, ${comboDuoVIP.length} akun)`);
  outLines.push('===========================================================================');

  const WCOMBO = { email:35, pwd:20, phone:16, visits:6, expired:28 };
  const comboHeader =
    padR('Email',   WCOMBO.email) + ' | ' +
    padR('Password',WCOMBO.pwd)   + ' | ' +
    padR('Phone',   WCOMBO.phone) + ' | ' +
    padR('Visits',  WCOMBO.visits)+ ' | ' +
    padR('Expired', WCOMBO.expired);

  outLines.push(comboHeader);
  outLines.push('-'.repeat(comboHeader.length));

  const sorted = comboDuoVIP.slice().sort((a,b)=>{
    if (b.visits !== a.visits) return b.visits - a.visits;
    return String(a.email).localeCompare(String(b.email));
  });

  for (const s of sorted) {
    const acc = akunList.find(a => normEmail(a.email) === normEmail(s.email));
    const pwd = passMap.get(normEmail(s.email)) || acc?.password || '-';
    const expiredCell = formatExpCell(s.expiredDate, s.daysLeft);
    outLines.push(
      padR(s.email, WCOMBO.email) + ' | ' +
      clampPad(pwd, WCOMBO.pwd) + ' | ' +
      padR(s.phone, WCOMBO.phone) + ' | ' +
      padR(String(s.visits), WCOMBO.visits) + ' | ' +
      padR(expiredCell, WCOMBO.expired)
    );
  }

  const phonesCsv = sorted.map(s => phoneNomorOnly(s.phone)).filter(Boolean).join(',');
  outLines.push('');
  outLines.push('Nomor HP (Combo Duo VIP):');
  outLines.push(phonesCsv);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// [BARU] SEGMENT: AKUN DENGAN VOUCHER 2D ALL DAYS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (voucher2DAllDaysActiveList.length > 0) {
  outLines.push('');
  outLines.push('===========================================================================');
  outLines.push(`VOUCHER [E-Voucher] 2D ALL DAYS Complimentary Member Rewards (${voucher2DAllDaysActiveList.length} akun)`);
  outLines.push('===========================================================================');

  const WCOMBO = { email:35, pwd:20, phone:16, visits:6, lastMovie:40, expired:28 };
  const comboHeader =
    padR('Email',   WCOMBO.email) + ' | ' +
    padR('Password',WCOMBO.pwd)   + ' | ' +
    padR('Phone',   WCOMBO.phone) + ' | ' +
    padR('Visits',  WCOMBO.visits)+ ' | ' +
    padR('LastTxn Movie', WCOMBO.lastMovie) + ' | ' +
    padR('Expired', WCOMBO.expired);

  outLines.push(comboHeader);
  outLines.push('-'.repeat(comboHeader.length));

  const sorted = voucher2DAllDaysActiveList.slice().sort((a,b)=>{
    if (b.visits !== a.visits) return b.visits - a.visits;
    return String(a.email).localeCompare(String(b.email));
  });

  for (const s of sorted) {
    const acc = akunList.find(a => normEmail(a.email) === normEmail(s.email));
    const pwd = passMap.get(normEmail(s.email)) || acc?.password || '-';
    const expiredCell = formatExpCell(s.expiredDate, s.daysLeft);
    outLines.push(
      padR(s.email, WCOMBO.email) + ' | ' +
      clampPad(pwd, WCOMBO.pwd) + ' | ' +
      padR(s.phone, WCOMBO.phone) + ' | ' +
      padR(String(s.visits), WCOMBO.visits) + ' | ' +
      padR(s.lastMovieDate || '-', WCOMBO.lastMovie) + ' | ' +
      padR(expiredCell, WCOMBO.expired)
    );
  }

  const phonesCsv = sorted.map(s => phoneNomorOnly(s.phone)).filter(Boolean).join(',');
  outLines.push('');
  outLines.push('Nomor HP (2D ALL DAYS):');
  outLines.push(phonesCsv);
}

outLines.push('-'.repeat(segHeader.length));
outLines.push('-'.repeat(segHeader.length));

    await fs.writeFile('allaccounts.txt', outLines.join('\n') + '\n', 'utf-8');
    console.log(chalk.cyan(`\nallaccounts.txt disimpan (${totalLines} baris + segmen & voucher Combo Solo/Duo).`));

  } catch (e) {
    console.log(chalk.red(`â†’ Gagal update allaccounts.txt: ${e.message}`));
  }

  // ====== APPLY PATCH SEKALI DI AKHIR (NON-DESTRUCTIVE, ATOMIC) ======
  try {
    if (patchMap.size) {
      console.log(chalk.gray(`\n[account.json] Applying ${patchMap.size} patch(es) (single atomic write)â€¦`));
      const raw = await fs.readFile('account.json', 'utf-8');
      const json = JSON.parse(raw);
      if (!Array.isArray(json.items)) json.items = [];

      // index email -> item
      const byEmail = new Map();
      for (const it of json.items) {
        if (it?.email) byEmail.set(normEmail(it.email), it);
      }

      for (const [kEmail, patch] of patchMap.entries()) {
        const target = byEmail.get(kEmail);
        if (!target) continue;

        // Password trio
        if (patch.password && patch.password !== target.password) {
          target.password = patch.password;
          target.password_updated_at = patch.password_updated_at || new Date().toISOString();
        }

        // Bearer trio
        if (patch.bearer) {
          target.bearer = patch.bearer;
          target.bearer_wrapped = patch.bearer_wrapped || wrapBearer3(patch.bearer);
          target.bearer_updated_at = patch.bearer_updated_at || new Date().toISOString();
        }

        // Profil/telemetri lain (merge shallow)
        const safeKeys = [
          'login_ok','name','gender','gender_code','email_id','member_no','address','city_id','city_name',
          'fav_theater_code','sale_channel_code','verified_email','tier','points','phone','city','join_date',
          'age_days','birthday','birthday_days_left','next_birthday_date','verified_phone','visits','fav_theater',
          'total_spend','has_birthday_voucher','last_movie_date','last_txn_date','voucher_count','voucher_count_active',
          'voucher_details','voucher_details_active','popcorn_1st_visit_status','popcorn_1st_visit_has_active',
          'popcorn_1st_visit_used_before','popcorn_1st_visit_last_used_at','combo_solo_status','combo_solo_has_active',
          'combo_solo_used_before','combo_solo_last_used_at','combo_solo_used_times',
          'combo_duo_status','combo_duo_has_active','combo_duo_used_before','combo_duo_last_used_at','combo_duo_used_times',
          'third_visit_b1g1_status','third_visit_b1g1_has_active','third_visit_b1g1_used_times','third_visit_b1g1_last_used_at',
          'popcorn_1st_visit_used_times','tsel10k_used_times',
          // NOT FOUND flags
          'not_found','account_status','not_found_at'
        ];
        for (const k of safeKeys) {
          if (Object.prototype.hasOwnProperty.call(patch, k)) {
            target[k] = patch[k];
          }
        }
      }

      // atomic write
      const tmpPath = 'account.tmp.json';
      await fs.writeFile(tmpPath, JSON.stringify(json, null, 2), 'utf-8');
      await fs.rename(tmpPath, 'account.json');
      console.log(chalk.green(`[account.json] Patch applied (OK)`));
    } else {
      console.log(chalk.gray('\n[account.json] Tidak ada patch yang perlu diterapkan.'));
    }
  } catch (e) {
    console.log(chalk.red(`â†’ Gagal apply patch account.json (non-destructive): ${e.message}`));
  }

  // â”€â”€ TULIS akunLogin.txt (EXPORT dari data yang dipakai saat ini)
  try {
    // urutkan by email asc agar stabil
    const lines = Array.from(akunLoginExport.values());
    lines.sort((a,b) => {
      const ea = a.slice(0, AKUNLOGIN_EMAIL_W).trim().toLowerCase();
      const eb = b.slice(0, AKUNLOGIN_EMAIL_W).trim().toLowerCase();
      return ea.localeCompare(eb);
    });
    await fs.writeFile('akunLogin.txt', lines.join('\n') + '\n', 'utf-8');
    console.log(chalk.cyan(`akunLogin.txt diexport (${lines.length} baris) â€” format: email | password | phone | ${PIN_DEFAULT}`));
  } catch (e) {
    console.log(chalk.red(`â†’ Gagal menulis akunLogin.txt: ${e.message}`));
  }

  // ====== APPEND notfound.json (tanpa overwrite, no duplicate by email) ======
  try {
    if (notFoundBuffer.length) {
      let existing = [];
      try {
        const rawN = await fs.readFile(NOTFOUND_FILE, 'utf-8');
        const parsed = JSON.parse(rawN);
        if (Array.isArray(parsed)) existing = parsed;
      } catch {}
      const seen = new Set(existing.map(x => normEmail(x.email)));
      for (const r of notFoundBuffer) {
        const key = normEmail(r.email);
        if (!seen.has(key)) { existing.push(r); seen.add(key); }
      }
      await fs.writeFile(NOTFOUND_FILE, JSON.stringify(existing, null, 2), 'utf-8');
      console.log(chalk.cyan(`${NOTFOUND_FILE} diupdate (append ${notFoundBuffer.length} baru, total ${existing.length}).`));
    } else {
      console.log(chalk.gray('Tidak ada akun not_found pada sesi ini.'));
    }
  } catch (e) {
    console.log(chalk.red(`â†’ Gagal update ${NOTFOUND_FILE}: ${e.message}`));
  }

  // summary (tetap) + konfirmasi NOT FOUND
  const dt = ((Date.now() - t0) / 1000).toFixed(1);
  const avg = (akunList.length ? (dt / akunList.length).toFixed(2) : '0.00');
  console.log(chalk.cyan('\n' + 'â•'.repeat(70)));
  console.log(
    chalk.cyan('[INFO]'),
    chalk.green(`Login OK: ${okCnt}`),
    chalk.cyan('|'),
    chalk.red(`Login FAIL: ${failCnt}`),
    chalk.cyan('|'),
    chalk.white(`Total checked: ${akunList.length}`),
    chalk.cyan('|'),
    chalk.white(`Sessions: ${totalSessions} (batch size ${CONCURRENCY})`),
    chalk.cyan('|'),
    chalk.white(`Time: ${dt}s (avg ${avg}s/account)`)
  );

  if (failCnt) {
    console.log(chalk.cyan('\nFailure breakdown:'));
    const sorted = [...failMap.entries()].sort((a,b)=>b[1]-a[1]);
    for (const [rsn, cnt] of sorted) {
      console.log(' -', chalk.yellow(rsn), chalk.gray(`x${cnt}`));
    }
  }

  // Ringkasan khusus NOT FOUND (konfirmasi akhir)
  if (notFoundBuffer.length) {
    const TableNF = await universalTable();
    const tn = new TableNF({ head:['#','Email','Phone','Password','PIN','Name','Timestamp'], style:{head:['red']} });
    notFoundBuffer.forEach((r,i)=>{
      tn.push([String(i+1), r.email, r.phone||'-', r.password||'-', r.pin||PIN_DEFAULT, r.name||'-', r.ts]);
    });
    console.log(chalk.red('\nAkun NOT FOUND (sesi ini):'));
    console.log(tn.toString());
  }

  // PAUSE â†’ ENTER â†’ countdown 5 detik â†’ kembali ke menu (tetap)
  try {
    let rlMod;
    try { rlMod = require('readline'); } catch { rlMod = (await import('node:readline')).default || (await import('node:readline')).readline; }
    const rl = rlMod.createInterface({ input: process.stdin, output: process.stdout });
    await new Promise(resolve => rl.question(chalk.yellow('\nTekan ENTER untuk kembali ke menuâ€¦ '), () => { rl.close(); resolve(); }));
  } catch {
    console.log(chalk.yellow('\n(Lewati PAUSE: readline tidak tersedia)'));
  }
  for (let i = 5; i >= 1; i--) {
    process.stdout.write(chalk.gray(`Kembali ke menu dalam ${i}s   \r`));
    await delay(1000);
  }
  process.stdout.write(' '.repeat(40) + '\r');

  return;
}





























/* ================================================================
   DELETE ACCOUNTS â€” bulk remove (polished)
   - Sumber list & password hanya dari account.json
   - Kandidat password: account.json.password â†’ ENV DEFAULT_PASSWORDS
   - Prioritas pakai bearer (account.json), auto re-login jika expired
   - AUTO-SKIP "not_found" (flag di account.json / notfound.json)
     â†’ langsung purge lokal + tandai removal dari account.json
   - Patch account.json DI AKHIR SAJA:
       * refresh bearer (jika ada)
       * hapus items terpilih (tanpa mengubah generated_at & no)
   - Purge lokal (akunLogin.txt, data.txt, data_format.txt)
     jika: (1) delete sukses, atau (2) not_found (flag/file), atau (3) login fail: "member not found"

   [UPDATED]
   - Setelah purge lokal, juga hapus email tsb dari sukses_email.json
   ================================================================= */
async function deleteAccounts() {
  console.clear();

  // fallback modules
  const chalk = (globalThis.chalk && globalThis.chalk.green) ? globalThis.chalk : (await import('chalk')).default;
  const fs = (globalThis.fs && globalThis.fs.readFile) ? globalThis.fs : (await import('fs/promises'));
  const inquirer = (globalThis.inquirer && globalThis.inquirer.prompt) ? globalThis.inquirer : (await import('inquirer')).default;

  console.log(chalk.red('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.red('â•‘                     PERMANENTLY DELETE ACCOUNTS              â•‘'));
  console.log(chalk.red('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
  console.log(chalk.yellow('âš   This action cannot be undone!\n'));

  const delayMs = (ms)=>new Promise(r=>setTimeout(r,ms));
  const norm = (s)=>String(s||'').trim().toLowerCase();
  const nowIso = ()=>new Date().toISOString();

  // Random headers per akun (aman)
  const choice = (arr)=>arr[Math.floor(Math.random()*arr.length)];
  const randomOkHttpUA = () => `okhttp/${choice(['4.9.3','4.10.0','4.11.0','4.12.0'])}`;
  const randomLang = () => choice([
    'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
    'id,en-US;q=0.9,en;q=0.8',
    'en-US,en;q=0.9,id;q=0.8',
    'id-ID,en;q=0.9'
  ]);
  const makeAccountHeaders = () => ({
    'accept': 'application/json, text/plain, */*',
    'accept-encoding': 'gzip',
    'accept-language': randomLang(),
    'user-agent': randomOkHttpUA(),
    'connection': 'Keep-Alive'
  });

  // withTimeout
  const withTimeout = (promise, ms, label = 'Timeout') =>
    Promise.race([
      promise,
      new Promise((_, rej) => setTimeout(() => rej(new Error(label)), ms))
    ]);

  // Safe wrappers (dukung headers bila tersedia di env lokal-mu)
  const getMemberInfoSafe = async (token, accHeaders) => {
    try {
      try { return await withTimeout(getMemberInfo(token, accHeaders), 20000, 'getMemberInfo timeout'); }
      catch { return await withTimeout(getMemberInfo(token), 20000, 'getMemberInfo timeout'); }
    } catch { return null; }
  };
  const getLoginAccountSafe = async (email, pwd, accHeaders) => {
    try {
      try { return await withTimeout(getLoginAccount(email, pwd, accHeaders), 20000, 'login timeout'); }
      catch { return await withTimeout(getLoginAccount(email, pwd), 20000, 'login timeout'); }
    } catch (e) {
      return { status_code: 0, message: e?.message || 'Login error' };
    }
  };
  const deleteMembershipSafe = async (token, pwd, accHeaders) => {
    try {
      try { return await withTimeout(deleteMembership(token, pwd, accHeaders), 20000, 'delete timeout'); }
      catch { return await withTimeout(deleteMembership(token, pwd), 20000, 'delete timeout'); }
    } catch (e) {
      return { status_code: 0, message: e?.message || 'Delete error' };
    }
  };

  // [NEW] helper: removeSuccessEmail
  // - buka sukses_email.json
  // - hapus email tsb dari list
  // - simpan balik
  async function removeSuccessEmail(email) {
    const target = norm(email);
    if (!target) return;
    let out = { generated_at: nowIso(), total: 0, emails: [] };

    try {
      const raw = await fs.readFile('sukses_email.json', 'utf-8');
      const parsed = JSON.parse(raw);

      if (Array.isArray(parsed)) {
        // format lama: array of {email} / string
        out.emails = parsed
          .map(x => String(x.email || x || '').toLowerCase().trim())
          .filter(Boolean);
      } else if (parsed && Array.isArray(parsed.emails)) {
        out = parsed;
        out.emails = out.emails
          .map(e => String(e || '').toLowerCase().trim())
          .filter(Boolean);
      }
    } catch {
      // file gak ada atau corrupt â†’ anggap kosong (ga error hard)
    }

    const beforeLen = out.emails.length;
    out.emails = out.emails.filter(e => e !== target);
    if (out.emails.length !== beforeLen) {
      out.total = out.emails.length;
      out.generated_at = nowIso();
      try {
        await fs.writeFile('sukses_email.json', JSON.stringify(out, null, 2), 'utf-8');
        console.log(chalk.gray(`(Removed from sukses_email.json)`));
      } catch (err) {
        console.log(chalk.red(`(Failed to update sukses_email.json: ${err.message})`));
      }
    }
  }

  // Load account.json
  let accDoc;
  try {
    const raw = await fs.readFile('account.json','utf-8');
    accDoc = JSON.parse(raw);
  } catch {
    console.log(chalk.red('âŒ Gagal membaca account.json â€” pastikan file tersedia!'));
    await delayMs(2000);
    return;
  }
  const akunList = Array.isArray(accDoc?.items) ? accDoc.items : [];
  if (!akunList.length) {
    console.log(chalk.red('âŒ account.json kosong!'));
    await delayMs(1500);
    return;
  }

  // Baca notfound.json (opsional) untuk auto-skip
  const notFoundSet = new Set();
  try {
    const raw = await fs.readFile('notfound.json','utf-8');
    const arr = JSON.parse(raw);
    if (Array.isArray(arr)) {
      for (const it of arr) if (it?.email) notFoundSet.add(norm(it.email));
    }
  } catch {}

  const isNotFoundFlag = (it) => {
    const st = String(it?.status || it?.account_status || '').toLowerCase();
    return it?.not_found === true || st === 'not_found' || notFoundSet.has(norm(it?.email));
  };

  // ENV default passwords
  function readDefaultPasswordsFromEnv() {
    let raw = '';
    try { raw = process?.env?.DEFAULT_PASSWORDS || ''; } catch {}
    if (!raw) {
      try {
        const v = getEnvironmentData?.('DEFAULT_PASSWORDS');
        if (typeof v === 'string') raw = v;
      } catch {}
    }
    return String(raw || '').split(',').map(s=>s.trim()).filter(Boolean);
  }
  const ENV_PWDS = (() => {
    const v = readDefaultPasswordsFromEnv();
    return v.length ? v : ['Cgv123456','Iqra0704','Cegeve123456','Cgv123456789']; // fallback kalau ENV kosong
  })();

  // bearer/password map
  const bearerMap = new Map();
  const passMap   = new Map();
  for (const it of akunList) {
    if (it?.email && it?.bearer)   bearerMap.set(norm(it.email), String(it.bearer));
    if (it?.email && it?.password) passMap.set(norm(it.email), String(it.password));
  }

  // tampilkan daftar ringkas
  {
    const Table = await universalTable();
    const t = new Table({ head:['No','Email','Phone','Verified','not_found?'], colWidths:[10,38,15,10,12], style:{head:['yellow']} });
    akunList.forEach(a=>t.push([a.no,a.email,a.phone,a.verified_phone?'âœ”':'âœ–', isNotFoundFlag(a)?'YES':'-']));
    console.log(t.toString());
  }

  // pilih mode hapus
  const { mode } = await inquirer.prompt([{
    type : 'list',
    name : 'mode',
    message : 'Delete mode?',
    choices : [
      'Delete all unverified accounts',
      'Delete all not_found accounts (auto-skip remote)',
      'Delete by selecting account numbers'
    ]
  }]);

  let targets = [];
  if (mode.startsWith('Delete all unverified')) {
    targets = akunList.filter(a => !a.verified_phone);
    if (!targets.length) {
      console.log(chalk.green('\n[âœ“] Tidak ada akun unverified.'));
      await delayMs(1500);
      return;
    }
  } else if (mode.startsWith('Delete all not_found')) {
    targets = akunList.filter(a => isNotFoundFlag(a));
    if (!targets.length) {
      console.log(chalk.green('\n[âœ“] Tidak ada akun bertanda not_found.'));
      await delayMs(1500);
      return;
    }
  } else {
    const { picks } = await inquirer.prompt([{
      type:'input',
      name:'picks',
      message:'Masukkan nomor akun yang ingin dihapus (pisahkan dengan koma, contoh: 4,13,19):',
      validate: v => v.trim() ? true : 'Isi minimal satu nomor'
    }]);
    const nums = picks.split(',').map(s=>parseInt(s.trim(),10)).filter(n=>!isNaN(n));
    targets = akunList.filter(a => nums.includes(a.no));
  }

  // Konfirmasi (info akurasi: berapa yang akan di-skip karena not_found)
  const willSkipNotFound = targets.filter(isNotFoundFlag).length;
  console.log(chalk.redBright(`\nAbout to DELETE ${targets.length} account(s).`));
  if (willSkipNotFound) {
    console.log(chalk.yellow(`(Auto-skip & purge lokal ${willSkipNotFound} akun bertanda not_found â€” tanpa request delete ke server)`));
  }
  targets.forEach(a => console.log(chalk.gray(` - ${a.email} (${a.phone}) [${a.verified_phone?'âœ”':'âœ–'}] ${isNotFoundFlag(a)?'â€” not_found':''}`)));
  const { ok } = await inquirer.prompt([{ type:'confirm', name:'ok', message:'Really continue?', default:false }]);
  if (!ok) { console.log(chalk.gray('Cancelled.')); await delayMs(800); return; }

  // Helpers klasifikasi error
  const shorten = (s, n=120) => {
    const x = String(s||'').replace(/\s+/g,' ').trim();
    return x.length > n ? x.slice(0,n-1)+'â€¦' : x;
  };
  const isMemberNotFound = (res) => {
    const sc  = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    return sc === 404 || /member not found|not found/.test(msg);
  };
  const looksTokenInvalid = (res) => {
    const sc  = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    return sc === 401 || /unauth|invalid token|expired/.test(msg);
  };
  const looksWrongPassword = (res) => {
    const sc = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    return (sc === 400 || sc === 401) && /password|invalid credential|wrong/i.test(msg);
  };

  // Purge lokal (3 file non-json) â€” aman
  // [UPDATED] setelah purge text files, juga purge dari sukses_email.json
  async function purgeTextFilesForEmail(email) {
    const emKey = norm(email);

    // akunLogin.txt
    try {
      const raw = await fs.readFile('akunLogin.txt','utf-8');
      const lines = raw.split('\n').map(l=>l.trim()).filter(Boolean);
      const kept  = lines.filter(l => (l.split('|')[0]?.trim().toLowerCase() || '') !== emKey);
      if (kept.length !== lines.length) {
        await fs.writeFile('akunLogin.txt', kept.join('\n') + '\n', 'utf-8');
        console.log(chalk.gray(`(Removed from akunLogin.txt)`));
      }
    } catch (e) { if (e.code !== 'ENOENT') console.log(chalk.red(`(Failed to update akunLogin.txt: ${e.message})`)); }

    // data.txt
    try {
      const raw = await fs.readFile('data.txt','utf-8');
      const lines = raw.split('\n').map(s=>s.trim()).filter(Boolean);
      const kept  = lines.filter(l => norm(l) !== emKey);
      if (kept.length !== lines.length) {
        await fs.writeFile('data.txt', kept.join('\n') + '\n', 'utf-8');
        console.log(chalk.gray(`(Removed from data.txt)`));
      }
    } catch (e) { if (e.code !== 'ENOENT') console.log(chalk.red(`(Failed to update data.txt: ${e.message})`)); }

    // data_format.txt
    try {
      const raw = await fs.readFile('data_format.txt','utf-8');
      const lines = raw.split('\n').map(s=>s.trim()).filter(Boolean);
      const kept  = lines.filter(l => (l.split('|')[0]?.trim().toLowerCase() || '') !== emKey);
      if (kept.length !== lines.length) {
        await fs.writeFile('data_format.txt', kept.join('\n') + '\n', 'utf-8');
        console.log(chalk.gray(`(Removed from data_format.txt)`));
      }
    } catch (e) { if (e.code !== 'ENOENT') console.log(chalk.red(`(Failed to update data_format.txt: ${e.message})`)); }

    // NEW: juga hapus dari sukses_email.json
    try {
      await removeSuccessEmail(email);
    } catch (err) {
      console.log(chalk.red(`(Failed to update sukses_email.json: ${err.message})`));
    }
  }

  // PATCH QUEUE account.json (apply di akhir)
  const pendingBearer = Object.create(null);
  const queueBearerUpdate = (email, token) => {
    if (!email || !token) return;
    const s = String(token), part = Math.ceil(s.length/3);
    pendingBearer[email] = {
      token,
      wrapped: [s.slice(0,part), s.slice(part,part*2), s.slice(part*2)],
      updated_at: nowIso()
    };
  };
  const emailsToRemove = new Set();

  // Try bearer (validasi)
  const tryBearer = async (email, accHeaders) => {
    const key = norm(email);
    const tok = bearerMap.get(key);
    if (!tok) return { ok:false };
    try {
      const info = await getMemberInfoSafe(tok, accHeaders);
      if (info?.status_code === 200 && info?.RESULTS?.ds_mbrList) {
        return { ok:true, token: tok };
      }
    } catch {}
    return { ok:false };
  };

  // Login helper
  const safeLogin = async (email, accHeaders) => {
    const emKey = norm(email);
    const fromJsonPwd = (passMap.get(emKey) || '').trim();
    const unique = [...new Set([fromJsonPwd, ...ENV_PWDS].map(s=>String(s||'').trim()).filter(Boolean))];

    let last = null;
    for (const pwd of unique) {
      let attempt = 0, backoff = 1200;
      while (attempt < 6) {
        attempt++;
        const res = await getLoginAccountSafe(email, pwd, accHeaders);
        last = res;
        if (res?.status_code === 200 && res?.token) {
          bearerMap.set(emKey, res.token);
          queueBearerUpdate(email, res.token);
          console.log(chalk.gray('   â†³ bearer akan diperbarui di account.json (batch akhir)'));
          return { ok:true, token:res.token, usedPwd:pwd };
        }
        if (isMemberNotFound(res)) return { ok:false, notFound:true, last:res };
        const retriable = (res?.status_code===429) || (res?.status_code>=500) ||
          /timeout|network|fetch|non-json/i.test(String(res?.message||'')) || res===null;
        if (!retriable) break;
        await delayMs(backoff + Math.floor(Math.random()*300));
        backoff = Math.min(8000, Math.floor(backoff*1.5));
      }
    }
    return { ok:false, last, notFound: isMemberNotFound(last) };
  };

  // Try delete with candidates
  const tryDeleteWith = async (token, pwdCandidates, accHeaders) => {
    let last = null;
    for (const pwd of pwdCandidates) {
      let attempt = 0, backoff = 1000;
      while (attempt < 4) {
        attempt++;
        const res = await deleteMembershipSafe(token, pwd, accHeaders);
        last = res;
        if (res?.status_code === 200) return { ok:true, res };
        if (looksWrongPassword(res)) break;        // pindah kandidat berikutnya
        if (looksTokenInvalid(res)) return { ok:false, tokenBad:true, res };
        const retriable = (res?.status_code===429) || (res?.status_code>=500) ||
          /timeout|network|fetch|non-json/i.test(String(res?.message||'')) || res===null;
        if (!retriable) break;
        await delayMs(backoff + Math.floor(Math.random()*300));
        backoff = Math.min(7000, Math.floor(backoff*1.6));
      }
    }
    return { ok:false, res:last };
  };

  // Eksekusi
  let remoteDeleted = 0;
  let localPurgedNotFound = 0;
  let keptDueToOtherFail  = 0;
  const totalTargets = targets.length;

  for (let i=0; i<targets.length; i++) {
    const a = targets[i];
    const lbl = `[ ${String(i+1).padStart(String(totalTargets).length,'0')}/${totalTargets} ]`;
    const accHeaders = makeAccountHeaders();

    // AUTO-SKIP not_found â†’ purge lokal + tandai removal
    if (isNotFoundFlag(a)) {
      process.stdout.write(chalk.gray(`${lbl} ${a.email} â€” not_found â†’ purge local & remove from account.json\n`));
      await purgeTextFilesForEmail(a.email); // <-- updated: also remove from sukses_email.json
      emailsToRemove.add(a.email);
      localPurgedNotFound++;
      continue;
    }

    process.stdout.write(chalk.gray(`${lbl} Deleting ${a.email} â€¦ `));

    // 1) token
    let token = null, usedPwd = null;

    const b = await tryBearer(a.email, accHeaders);
    if (b.ok) {
      token = b.token;
    } else {
      const lg = await safeLogin(a.email, accHeaders);
      if (!lg.ok) {
        if (lg.notFound) {
          console.log(chalk.red(`login fail: ACCOUNT NOT FOUND â€” purging local`));
          await purgeTextFilesForEmail(a.email); // <-- updated
          emailsToRemove.add(a.email);
          localPurgedNotFound++;
        } else {
          const sc = lg?.last?.status_code;
          const msg = shorten(lg?.last?.message);
          console.log(chalk.red(`login fail: ${sc||''} ${msg||''} â€” keeping local (no purge)`));
          keptDueToOtherFail++;
        }
        await delayMs(200);
        continue;
      }
      token = lg.token;
      usedPwd = lg.usedPwd;
    }

    // 2) delete
    const emKey = norm(a.email);
    const pwdFromJson = (passMap.get(emKey) || '').trim();
    const candidates = usedPwd
      ? [usedPwd]
      : [...new Set([pwdFromJson, ...ENV_PWDS].map(s=>String(s||'').trim()).filter(Boolean))];

    let del = await tryDeleteWith(token, candidates, accHeaders);

    // token invalid â†’ relogin & retry sekali
    if (!del.ok && del.tokenBad) {
      const lg2 = await safeLogin(a.email, accHeaders);
      if (!lg2.ok) {
        if (lg2.notFound) {
          console.log(chalk.red(`login fail (refresh): ACCOUNT NOT FOUND â€” purging local`));
          await purgeTextFilesForEmail(a.email); // <-- updated
          emailsToRemove.add(a.email);
          localPurgedNotFound++;
        } else {
          const sc = lg2?.last?.status_code;
          const msg = shorten(lg2?.last?.message);
          console.log(chalk.red(`login refresh fail: ${sc||''} ${msg||''} â€” keeping local`));
          keptDueToOtherFail++;
        }
        await delayMs(200);
        continue;
      }
      token = lg2.token;
      del = await tryDeleteWith(token, [lg2.usedPwd], accHeaders);
    }

    if (del.ok) {
      console.log(chalk.green('deleted'));
      await purgeTextFilesForEmail(a.email); // <-- updated
      emailsToRemove.add(a.email);
      remoteDeleted++;
    } else {
      const sc = del?.res?.status_code;
      const msg = shorten(del?.res?.message);
      console.log(chalk.red(`fail (${sc||''} ${msg||''}) â€” keeping local`));
      keptDueToOtherFail++;
    }

    await delayMs(200);
  }

  // APPLY PATCHES KE account.json (AKHIR SAJA) â€” TANPA regenerate/renumber/ubah generated_at
  try {
    const raw = await fs.readFile('account.json','utf-8');
    const j = JSON.parse(raw || '{}');
    if (Array.isArray(j.items)) {
      // 1) patch bearer
      for (let i = 0; i < j.items.length; i++) {
        const it = j.items[i];
        if (!it || !it.email) continue;
        const pb = pendingBearer[it.email];
        if (pb) {
          it.bearer = pb.token;
          it.bearer_wrapped = pb.wrapped;
          it.bearer_updated_at = pb.updated_at;
          j.items[i] = it;
        }
      }
      // 2) hapus items
      if (emailsToRemove.size) {
        j.items = j.items.filter(x => !emailsToRemove.has(x.email));
      }
      await fs.writeFile('account.json', JSON.stringify(j, null, 2), 'utf-8');
    }
  } catch (e) {
    console.log(chalk.red(`â†’ Gagal apply patch account.json (batch akhir): ${e.message}`));
  }

  // Ringkasan
  console.log(chalk.cyan(
    `\n[SUMMARY] Remote deleted: ${remoteDeleted} | Local purged (not_found): ${localPurgedNotFound} | Kept due to other login fails: ${keptDueToOtherFail} | Total targets: ${targets.length}`
  ));

  console.log(chalk.green('\nFinished. Press Enter to returnâ€¦'));
  await inquirer.prompt([{ type:'input', name:'pause', message:'Press Enter to returnâ€¦' }]);
}







// ====== UPDATE RANDOM PROFILE (name, address, gender only) ======
async function updateRandomProfile() {
  console.clear();
  const RUN_TS   = Date.now();
  const RUN_ID   = new Date(RUN_TS).toISOString().replace(/[-:.TZ]/g, '').slice(0,14);
  const termCols = Math.max(60, process.stdout?.columns || 120);

  const hr = (w = termCols) => 'â”€'.repeat(Math.min(w, termCols));

  const headerBox = () => {
    const title = 'UPDATE RANDOM PROFILE ACCOUNTS';
    const top    = `â•”${hr()}â•—`;
    const middle = `â•‘ ${title.padEnd(Math.min(termCols-2, title.length + 2), ' ')}â•‘`;
    const bottom = `â•š${hr()}â•`;
    console.log(chalk.cyan(top));
    console.log(chalk.cyan(middle));
    console.log(chalk.cyan(bottom + '\n'));
  };

  headerBox();

  /* ==== TUNABLES (tetap, hanya ditampilkan di header) ==== */
  const ACCOUNT_CONCURRENCY = 5;     // worker paralel (disesuaikan: 5 per sesi)
  const EDIT_MAX_RETRY      = 6;     // retry profile/edit
  const EDIT_TIMEOUT_MS     = 15000; // timeout tiap request
  const BASE_BACKOFF_MS     = 700;   // backoff awal retry
  const LOG_DETAIL          = true;  // log proses yang lebih informatif

  // tampilkan konfigurasi ringkas
  console.log(
    chalk.gray(
      `Config  : concurrency=${ACCOUNT_CONCURRENCY}, edit_retry=${EDIT_MAX_RETRY}, ` +
      `timeout=${EDIT_TIMEOUT_MS}ms, backoff=${BASE_BACKOFF_MS}ms, run_id=${RUN_ID}\n`
    )
  );

  // --- util: name splitter
  const splitName = (full) => {
    const parts = String(full).trim().split(/\s+/).filter(Boolean);
    if (parts.length === 1) return { first: parts[0], last: ' ' };
    const last  = parts.pop();
    const first = parts.join(' ');
    return { first, last };
  };

  // â”€â”€ util random (selaras listAccounts)
  const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const randomOkHttpUA = () => {
    const vers = choice(['4.9.3','4.10.0','4.11.0','4.12.0']);
    return `okhttp/${vers}`;
  };
  const randomLang = () => choice([
    'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
    'id,en-US;q=0.9,en;q=0.8',
    'en-US,en;q=0.9,id;q=0.8',
    'id-ID,en;q=0.9'
  ]);
  const makeAccountHeaders = () => ({
    'accept': 'application/json, text/plain, */*',
    'accept-encoding': 'gzip',
    'accept-language': randomLang(),
    'user-agent': randomOkHttpUA(),
    'connection': 'Keep-Alive'
  });

  // ========== Helpers UI & waktu ==========
  const stripAnsi = (s) => String(s || '').replace(
    // eslint-disable-next-line no-control-regex
    /[\u001B\u009B][[\]()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, ''
  );
  const strLen = (s) => stripAnsi(s).length;

  const fmtMs = (ms) => {
    ms = Math.max(0, ms|0);
    const s  = Math.floor(ms / 1000);
    const mm = Math.floor(s / 60);
    const hh = Math.floor(mm / 60);
    const ss = s % 60;
    const m  = mm % 60;
    if (hh) return `${hh}h ${m}m ${ss}s`;
    if (mm) return `${mm}m ${ss}s`;
    if (s)  return `${s}s ${ms%1000}ms`;
    return `${ms}ms`;
  };

  // Auto-fit colWidths berdasarkan lebar terminal (tidak hardcode)
  const calcAutoColWidths = (head, rows) => {
    const padding = 3 * head.length + 1; // approx border & padding
    const maxW = Math.max(50, termCols - 2); // jaga margin
    const avail = Math.max(30, maxW - padding);

    // panjang konten per kolom
    const rawWidths = head.map((h, ci) => {
      const all = [String(h), ...rows.map(r => String(r?.[ci] ?? ''))];
      return Math.max(...all.map(strLen), 6);
    });

    const sumRaw = rawWidths.reduce((a,b)=>a+b,0);
    if (sumRaw <= avail) {
      return rawWidths; // cukup, tidak perlu kompresi
    }

    // Bobot per kolom (biar "Email" & "Address" dapat porsi lebih)
    const weights = head.map(h => {
      const H = h.toLowerCase();
      if (H.startsWith('#')) return 0.5;
      if (H.includes('email')) return 1.6;
      if (H.includes('name')) return 1.2;
      if (H.includes('address')) return 1.8;
      if (H.includes('city')) return 1.0;
      if (H.includes('gender')) return 0.8;
      if (H.includes('note')) return 1.0;
      return 1.0;
    });

    const sumW = weights.reduce((a,b)=>a+b,0);
    const base = weights.map(w => Math.max(6, Math.floor((w / sumW) * avail)));

    // Pastikan header tidak terpotong terlalu kecil
    return base.map((w, i) => Math.max(w, Math.min(rawWidths[i], Math.max(6, strLen(head[i])+2))));
  };

  // builder tabel universal (auto-fit)
  const buildAutoTable = async (head, rows, styleHeadColor='cyan') => {
    const Table = await universalTable();
    const colWidths = calcAutoColWidths(head, rows);
    return new Table({
      head,
      colWidths,
      wordWrap: true,
      style: { head: [styleHeadColor] }
    });
  };

  // ========== Anti-stuck helpers ==========
  const withTimeout = (promise, ms, label = 'Timeout') =>
    Promise.race([
      promise,
      new Promise((_, rej) => setTimeout(() => rej(new Error(label)), ms))
    ]);

  // --- bearer & password map loader (dari account.json)
  const loadAuthMapsFromAccountJson = async () => {
    const bearerMap = new Map();
    const passMap   = new Map();
    try {
      const raw = await fs.readFile('account.json','utf-8');
      const j = JSON.parse(raw);
      const items = Array.isArray(j?.items) ? j.items : [];
      for (const it of items) {
        if (it?.email && it?.bearer)   bearerMap.set(String(it.email).toLowerCase(), String(it.bearer));
        if (it?.email && it?.password) passMap.set(String(it.email).toLowerCase(), String(it.password));
      }
    } catch {}
    return { bearerMap, passMap };
  };

  // --- bungkus bearer untuk readability
  const wrapBearer3 = (token) => {
    const s = String(token || '');
    if (!s) return [];
    const partLen = Math.ceil(s.length / 3);
    return [ s.slice(0, partLen), s.slice(partLen, partLen*2), s.slice(partLen*2) ];
  };

  // --- HTTP: POST form â†’ JSON (deteksi Non-JSON)
  const httpPostFormJson = async (url, form, headers, agent, timeoutMs) => {
    const ctrl = new AbortController();
    const timer = setTimeout(() => ctrl.abort(), timeoutMs);
    const t0 = Date.now();
    try {
      const res = await fetch(url, { method:'POST', headers, body: form, agent, signal: ctrl.signal });
      const status = res.status;
      const hdrs   = Object.fromEntries([...res.headers.entries()]);
      const ctype  = (hdrs['content-type'] || hdrs['Content-Type'] || '').toLowerCase();
      let json = null, raw = null, nonJson = false;
      if (ctype.includes('application/json')) {
        try { json = await res.json(); } catch { nonJson = true; }
      } else {
        nonJson = true;
        try { raw = await res.text(); } catch {}
      }
      clearTimeout(timer);
      return { status, headers: hdrs, json, raw, nonJson, elapsed: Date.now()-t0 };
    } catch (e) {
      clearTimeout(timer);
      return { status: 0, headers: {}, json: null, raw: null, nonJson: false, error: e.message, elapsed: Date.now()-t0 };
    }
  };

  // --- wrapper aman panggilan API dengan headers per akun
  const getMemberInfoSafe = async (token, accHeaders) => {
    try {
      try {
        return await withTimeout(getMemberInfo(token, accHeaders), 20000, 'getMemberInfo timeout');
      } catch {
        return await withTimeout(getMemberInfo(token), 20000, 'getMemberInfo timeout');
      }
    } catch {
      return null;
    }
  };
  const getLoginAccountSafe = async (email, pwd, accHeaders) => {
    try {
      try {
        return await withTimeout(getLoginAccount(email, pwd, accHeaders), 20000, 'login timeout');
      } catch {
        return await withTimeout(getLoginAccount(email, pwd), 20000, 'login timeout');
      }
    } catch (e) {
      return { status_code: 0, message: e?.message || 'Login error' };
    }
  };

  // --- helper: panggil /membership/profile/edit dengan retry tangguh (headers per akun)
  const updateProfileEditWithRetry = async (token, payload, accHeaders) => {
    let backoff = BASE_BACKOFF_MS;
    let attempts = 0;
    let totalElapsed = 0;
    for (let attempt = 1; attempt <= EDIT_MAX_RETRY; attempt++) {
      attempts = attempt;
      const form = new FormData();
      form.set('first_name', payload.first_name);
      form.set('last_name',  payload.last_name);
      form.set('address',    payload.address);
      form.set('city_id',    payload.city_id);
      form.set('gender',     payload.gender);

      // header konsisten per akun (aman)
      const headers = {
        Authorization     : `Bearer ${token}`,
        'User-Agent'      : accHeaders?.['user-agent'] || randomOkHttpUA(),
        'Accept-Language' : accHeaders?.['accept-language'] || randomLang(),
        Accept            : 'application/json, text/plain, */*',
        'X-Requested-With': 'XMLHttpRequest'
      };

      const res = await httpPostFormJson(
        'https://v2-api.cgv.id/api/membership/profile/edit',
        form,
        headers,
        getRandomProxy?.(),
        EDIT_TIMEOUT_MS
      );
      totalElapsed += res.elapsed || 0;

      // normalize
      const j = res.json || {};
      if (!j.status_code) j.status_code = res.status || 0;

      // sukses JSON 200
      if (!res.nonJson && j.status_code === 200) return { ...j, _attempts: attempts, _elapsed: totalElapsed };

      const msg = String(j?.message || res?.raw || '').toLowerCase();

      // 401/unauth â†’ kembalikan ke caller biar relogin & retry sekali
      if (j.status_code === 401 || /unauth|expired|invalid token/.test(msg)) {
        return { ...j, _attempts: attempts, _elapsed: totalElapsed };
      }

      // Non-JSON / 429 / 5xx / timeout / network â†’ retry dengan backoff
      const retriable =
        res.nonJson ||
        res.status === 0 ||
        j.status_code === 429 ||
        j.status_code >= 500 ||
        /timeout|network|fetch|gateway|cloudflare|waf|nginx/i.test(msg);

      if (!retriable || attempt === EDIT_MAX_RETRY) {
        const fallback = res.nonJson
          ? { status_code: res.status || 520, message: 'Non-JSON response (WAF/gateway)', raw: (res.raw||'').slice(0,160) }
          : j;
        return { ...fallback, _attempts: attempts, _elapsed: totalElapsed };
      }

      if (LOG_DETAIL) {
        console.log(chalk.gray(`      â†³ retry edit (attempt ${attempt}/${EDIT_MAX_RETRY}) â€” reason: ${j.status_code || res.status} ${j.message || res.error || 'retriable'}`));
      }

      await delay(backoff + Math.floor(Math.random()*400));
      backoff = Math.min(10000, Math.floor(backoff*1.7));
    }
  };

  // ====== MUAT DATA dari account.json (saja, tanpa akunLogin.txt) ======
  let accJsonRaw = null;
  let accJson = null;
  try {
    accJsonRaw = await fs.readFile('account.json','utf-8');
    accJson = JSON.parse(accJsonRaw);
  } catch {
    console.log(chalk.red('âŒ  account.json tidak ditemukan / rusak.'));
    await delay(1500);
    return;
  }
  const allItems = Array.isArray(accJson?.items) ? accJson.items : [];
  if (!allItems.length) {
    console.log(chalk.red('âŒ  account.json kosong. Tidak ada akun yang bisa diproses.'));
    await delay(1500);
    return;
  }

  // ====== (BARU) LOAD notfound.json & AUTO-SKIP ======
  const NOTFOUND_FILE = 'notfound.json';
  const notFoundSet = new Set();
  try {
    const nfRaw = await fs.readFile(NOTFOUND_FILE, 'utf-8');
    const nf = JSON.parse(nfRaw);
    if (Array.isArray(nf)) {
      nf.forEach(r => {
        if (r && r.email) notFoundSet.add(String(r.email).trim().toLowerCase());
      });
    }
  } catch { /* silent if missing */ }

  const shouldSkip = (it) => {
    if (!it || !it.email) return true;
    const k = String(it.email).trim().toLowerCase();
    const flaggedInAccount =
      it.not_found === true ||
      String(it.account_status || '').toLowerCase() === 'not_found' ||
      String(it.status || '').toLowerCase() === 'not_found';
    const flaggedInFile = notFoundSet.has(k);
    return flaggedInAccount || flaggedInFile;
  };

  // Peta referensi item by email (modifikasi in-memory langsung ke objek aslinya)
  const itemByEmail = new Map(allItems.map(it => [String(it.email||'').toLowerCase(), it]));

  // auth maps (bearer/password) untuk akses cepat
  const { bearerMap, passMap } = await loadAuthMapsFromAccountJson();

  // daftar akun untuk UI (email + password dari account.json; password boleh kosong) â€” AUTO-SKIP not_found
  let akunList = allItems
    .filter(it => it && it.email && !shouldSkip(it))
    .map(it => ({ email: it.email, password: it.password || '' }));

  const skippedCount = allItems.length - akunList.length;

  // tampilkan daftar akun (ringkas, auto-fit)
  {
    const head = ['No','Email'];
    const rows = akunList.map((a,i)=>[String(i+1).padStart(2,'0'), a.email]);
    const t = await buildAutoTable(head, rows, 'yellow');
    rows.forEach(r => t.push(r));
    console.log(t.toString());
    console.log(chalk.gray(`Total accounts found: ${allItems.length} | skipped (not_found): ${skippedCount} | to process: ${akunList.length}\n`));
  }

  if (!akunList.length) {
    console.log(chalk.yellow('Semua akun tersaring (not_found). Tidak ada yang diproses.\n'));
    return;
  }

  // pilih semua / sebagian
  const { mode } = await inquirer.prompt([{
    type:'list', name:'mode', message:'Select mode:',
    choices:[`All accounts (${akunList.length})`,'Select some']
  }]);

  let selected = [];
  if (mode.startsWith('All')) {
    selected = akunList;
  } else {
    const { picks } = await inquirer.prompt([{
      type:'checkbox', name:'picks', message:'Select account(s) to update:',
      choices: akunList.map((a,i)=>({ name:`${String(i+1).padStart(2,'0')}. ${a.email}`, value:i })),
      validate: arr => arr.length ? true : 'Choose at least one account'
    }]);
    selected = picks.map(i=>akunList[i]);
  }

  // ENV default passwords
  const envPasswords = (process?.env?.DEFAULT_PASSWORDS || '')
    .split(',')
    .map(s => s.trim())
    .filter(Boolean);

  // fungsi login: kandidat = item.password + ENV DEFAULT_PASSWORDS (tanpa duplikat)
  const tryLoginWithCandidates = async (email, itemPwd, accHeaders) => {
    const candidates = [...new Set([itemPwd, ...envPasswords].filter(Boolean))];
    let last = null;
    for (const p of candidates) {
      const res = await getLoginAccountSafe(email, p, accHeaders);
      last = res;
      if (res?.status_code === 200 && res?.token) {
        return { ok:true, token:res.token, usedPwd:p, source: (p === itemPwd ? 'item' : 'env') };
      }
      const msg = String(res?.message || '').toLowerCase();
      if (/invalid|wrong password|credential|unauth|401/.test(msg)) continue;
    }
    return { ok:false, reason: last?.message || 'Login fail' };
  };

  // tabel hasil (akhir) â€” akan di-build setelah results lengkap
  const resultRows = [];

  // statistik run
  const total = selected.length;
  let cursor  = 0;
  const results = new Array(total);
  let okCount=0, failCount=0;
  let reuseBearer=0, relogItem=0, relogEnv=0;
  let totalEditAttempts=0;

  const formatGender = (name, code) =>
    `${name} (${code || (name?.toLowerCase().startsWith('m') ? '01' : '02')})`;

  const worker = async () => {
    while (true) {
      const i = cursor++;
      if (i >= total) break;

      const acc = selected[i];
      const label = `[ ${String(i+1).padStart(String(total).length,'0')}/${total} ]`;
      console.log(chalk.gray(`${label} Updating ${acc.email}â€¦`));

      const accHeaders = makeAccountHeaders();
      const meta = { auth:'', attempts:0, editMs:0, city:'-', cityId:'-', relog:false };

      try {
        // referensi item in-memory
        const itemRef = itemByEmail.get(String(acc.email).toLowerCase());
        if (!itemRef) {
          console.log(chalk.red(`${label} âœ— ${acc.email} tidak ditemukan di account.json`));
          results[i] = { ok:false, email:acc.email, note:'Not found in account.json' };
          failCount++;
          continue;
        }

        // === 0) pakai bearer dari account.json kalau ada, lalu ping
        let token     = bearerMap.get(String(acc.email).toLowerCase()) || null;
        let needLogin = !token;
        let city_id_existing = itemRef.city_id || '024';

        if (token) {
          try {
            const ping = await getMemberInfoSafe(token, accHeaders);
            const unauthorized = ping?.status_code === 401 || /unauth|expired|invalid/i.test(String(ping?.message||''));
            if (!ping?.RESULTS?.ds_mbrList || unauthorized) {
              needLogin = true;
              if (LOG_DETAIL) console.log(chalk.yellow(`${label} Auth: cached bearer invalid â†’ relogin`));
            } else {
              meta.auth = 'bearer';
              reuseBearer++;
              city_id_existing = ping.RESULTS?.ds_mbrList?.ADDR_REGION_CD || city_id_existing;
              if (LOG_DETAIL) console.log(chalk.gray(`${label} Auth: using cached bearer`));
            }
          } catch {
            needLogin = true;
            if (LOG_DETAIL) console.log(chalk.yellow(`${label} Auth: bearer ping error â†’ relogin`));
          }
        }

        // === 1) login jika perlu (kandidat: item.password â†’ ENV DEFAULT_PASSWORDS)
        if (needLogin) {
          const loginTry = await tryLoginWithCandidates(acc.email, acc.password, accHeaders);
          if (!loginTry.ok) {
            console.log(chalk.red(`${label} âœ— Login gagal (item.password + ENV): password invalid/akun salah`));
            results[i] = { ok:false, email:acc.email, note:'Login fail' };
            failCount++;
            continue;
          }
          token = loginTry.token;
          meta.auth = `login:${loginTry.source}`;
          meta.relog = true;
          relogItem += (loginTry.source === 'item') ? 1 : 0;
          relogEnv  += (loginTry.source === 'env') ? 1 : 0;

          // In-memory update bearer trio (saja)
          itemRef.bearer = token;
          itemRef.bearer_wrapped = wrapBearer3(token);
          itemRef.bearer_updated_at = new Date().toISOString();

          // In-memory update password jika berubah (saja)
          if (loginTry.usedPwd && String(loginTry.usedPwd) !== String(itemRef.password || '')) {
            itemRef.password = String(loginTry.usedPwd);
            itemRef.password_updated_at = new Date().toISOString();
          }

          if (LOG_DETAIL) console.log(chalk.gray(`${label} Auth: relogin success (source: ${loginTry.source})`));

          try {
            const pre = await getMemberInfoSafe(token, accHeaders);
            city_id_existing = pre?.RESULTS?.ds_mbrList?.ADDR_REGION_CD || city_id_existing;
          } catch {}
        }

        // === 2) generate data random
        const fullName = faker.person.fullName();
        const { first, last } = splitName(fullName);
        const address  = faker.location.streetAddress(true);
        const gender   = Math.random() < 0.5 ? '01' : '02';

        // === 3) update profile (retry-tangguh, headers konsisten)
        const tEdit0 = Date.now();
        let upRes = await updateProfileEditWithRetry(token, {
          first_name: first, last_name: last, address, city_id: city_id_existing, gender
        }, accHeaders);
        meta.editMs = Date.now() - tEdit0;
        meta.attempts = upRes?._attempts || 1;

        // 401 â†’ relogin sekali lalu retry 1x (pakai kandidat lagi)
        if (upRes?.status_code === 401) {
          const relog = await tryLoginWithCandidates(acc.email, acc.password, accHeaders);
          if (relog.ok) {
            token = relog.token;
            meta.auth = `login:${relog.source}`;
            meta.relog = true;
            relogItem += (relog.source === 'item') ? 1 : 0;
            relogEnv  += (relog.source === 'env') ? 1 : 0;

            // bearer trio in-memory (saja)
            itemRef.bearer = token;
            itemRef.bearer_wrapped = wrapBearer3(token);
            itemRef.bearer_updated_at = new Date().toISOString();

            // password in-memory bila berubah (saja)
            if (relog.usedPwd && String(relog.usedPwd) !== String(itemRef.password || '')) {
              itemRef.password = String(relog.usedPwd);
              itemRef.password_updated_at = new Date().toISOString();
            }

            const tEdit1 = Date.now();
            upRes = await updateProfileEditWithRetry(token, {
              first_name: first, last_name: last, address, city_id: city_id_existing, gender
            }, accHeaders);
            meta.editMs += Date.now() - tEdit1;
            meta.attempts += (upRes?._attempts || 1);
          }
        }

        totalEditAttempts += meta.attempts;

        if (upRes?.status_code !== 200) {
          const why = upRes?.message || upRes?.status_code || 'unknown';
          console.log(chalk.red(`${label} âœ— Update gagal: ${why}`));
          results[i] = { ok:false, email:acc.email, note:String(why).slice(0,120) };
          failCount++;
          continue;
        }

        // === 4) ambil info terbaru untuk table + sinkron profil (IN-MEMORY; tulis di akhir)
        let m = {}, okInfo=false;
        try {
          const infoRes = await getMemberInfoSafe(token, accHeaders);
          okInfo = infoRes?.status_code === 200;
          m = okInfo ? (infoRes.RESULTS?.ds_mbrList || {}) : {};
        } catch {}

        const nameAfter   = okInfo ? (m.MBR_NM || `${m.FIRST_NM || first} ${m.LAST_NM || last}`) : `${first} ${last}`;
        const addrAfter   = okInfo ? (m.ADDR_STREET || address) : address;
        const cityIdAfter = okInfo ? (m.ADDR_REGION_CD || city_id_existing) : city_id_existing;
        const cityNmAfter = okInfo ? (m.ADDR_REGION_NM || itemRef.city_name || '-') : (itemRef.city_name || '-');
        const genCode     = okInfo ? (m.SEC_CD || gender) : gender;
        const genName     = genCode === '01' ? 'Male' : genCode === '02' ? 'Female' : genCode;

        meta.city = cityNmAfter; meta.cityId = cityIdAfter;

        // sinkron field profil ke in-memory item
        itemRef.name        = nameAfter;
        itemRef.gender_code = genCode;
        itemRef.gender      = genName;
        itemRef.address     = addrAfter;
        itemRef.city_id     = cityIdAfter;
        itemRef.city_name   = cityNmAfter;

        // push ke table (hasil)
        results[i] = {
          ok:true, email:acc.email,
          nameAfter, genName, genCode,
          addrAfter, cityNmAfter, cityIdAfter,
          meta
        };
        okCount++;

        const summary = chalk.gray(
          `auth=${meta.auth || 'bearer'} â€¢ edit=${meta.attempts} try â€¢ city=${meta.city} (${meta.cityId}) â€¢ t=${fmtMs(meta.editMs)}`
        );
        console.log(chalk.green(`${label} âœ“ Updated ${acc.email}  ${summary}`));
      } catch (e) {
        console.log(chalk.red(`${label} âœ— Exception: ${e.message}`));
        results[i] = { ok:false, email:acc.email, note:'Exception' };
        failCount++;
      }

      await delay(120 + Math.floor(Math.random()*150)); // jitter kecil antar akun
    }
  };

  // jalankan worker pool (paralel 5 akun)
  await Promise.all(Array.from({ length: Math.min(ACCOUNT_CONCURRENCY, selected.length) }, worker));

  // tampilkan tabel hasil (urut by input) â€” AUTOFIT
  results.forEach((r, i) => {
    if (!r) return;
    if (r.ok) {
      resultRows.push([
        i+1,
        r.email,
        r.nameAfter,
        formatGender(r.genName, r.genCode),
        `${r.cityNmAfter} (${r.cityIdAfter})`,
        r.addrAfter,
        (r.meta?.auth ? `OK â€” ${r.meta.auth}, edit=${r.meta.attempts} try, t=${fmtMs(r.meta.editMs)}` : 'OK')
      ]);
    } else {
      resultRows.push([ i+1, r.email, '-', '-', '-', '-', r.note || 'FAIL' ]);
    }
  });

  const resultHead = ['#','Email','Name (after)','Gender','City (code)','Address','Note'];
  const resultTable = await buildAutoTable(resultHead, resultRows, 'cyan');
  resultRows.forEach(row => resultTable.push(row));
  console.log('\n' + resultTable.toString());

  // ====== TULIS SEKALI DI AKHIR ======
  // - Tidak mengubah `generated_at`
  // - Tidak menomori ulang field `no`
  // - Menyimpan perubahan pada item (bearer trio, password jika berubah, & profil)
  try {
    await fs.writeFile('account.json', JSON.stringify(accJson, null, 2), 'utf-8');
    console.log(chalk.gray('\naccount.json diperbarui (sekali di akhir): bearer-trio, password bila berubah, dan field profil.'));
    console.log(chalk.gray('`generated_at` & nomor `no` DIPERTAHANKAN (tidak diubah).'));
  } catch (e) {
    console.log(chalk.red(`\nGagal menyimpan account.json: ${e.message}`));
  }

  // Ringkasan akhir run
  const RUN_ELAPSED = Date.now() - RUN_TS;
  const avgAttempt  = (okCount + failCount) ? (totalEditAttempts / (okCount + failCount)) : 0;

  console.log(
    chalk.gray(
      `\nSummary  : OK=${okCount}, FAIL=${failCount}, reused_bearer=${reuseBearer}, ` +
      `relogin(item)=${relogItem}, relogin(env)=${relogEnv}, avg_edit_attempt=${avgAttempt.toFixed(2)}`
    )
  );
  console.log(chalk.gray(`Duration : ${fmtMs(RUN_ELAPSED)}\n`));

  await inquirer.prompt([{ type:'input', name:'pause', message:'Press Enter to returnâ€¦' }]);
}







/* ================================================================
   AUTO LOGIN (FROM data.txt / MANUAL) â€” updated:
   - Support data.txt: email | password | phone | pin
   - If password ada di data.txt â†’ pakai itu per akun
   - Simpan password ke account.json (field: password)
   ============================================================== */
async function autoLoginFromDataFile() {
  console.clear();
  console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.cyan('â•‘                    AUTO LOGIN (MULTI MODE)                   â•‘'));
  console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));

  const t0 = Date.now();

  // â”€â”€ const & helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const PRIMARY_PWD  = 'Iqra0704';
  const FALLBACK_PWD = 'Cgv123456';
  const CONCURRENCY  = 1;

  const EMAIL_W = 35, PWD_W = 18, PHONE_W = 14, PIN_W = 8;
  const DEFAULT_PIN = '121212';

  const norm = (s) => String(s || '').trim().toLowerCase();
  const padN = (n, w) => String(n).padStart(w, '0');
  const looksWrongPassword = (res) => {
    const sc = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    return sc === 401 || /invalid credential|invalid password|wrong password/.test(msg);
  };
  const reasonFromLoginError = (res) => {
    const sc = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    if (looksWrongPassword(res))                                return 'Wrong password';
    if (sc === 429 || /too many|rate limit/.test(msg))          return 'Rate limited (429)';
    if (sc === 404 || /member not found|not found/.test(msg))   return 'Account not found';
    if (/non-json response/.test(msg))                          return 'Anti-bot/gateway (non-JSON)';
    if (/timeout|network|fetch fail|networkerror/.test(msg))    return 'Network error/timeout';
    if (sc >= 500)                                              return `Server error (${sc})`;
    if (sc && sc !== 200)                                       return `HTTP ${sc}`;
    return 'Unknown login error';
  };
  const formatLoginLine = (email, pwd, phone = '-', pin = DEFAULT_PIN) =>
    `${String(email).padEnd(EMAIL_W)} | ${String(pwd).padEnd(PWD_W)} | ${String(phone || '-').padEnd(PHONE_W)} | ${String(pin).padEnd(PIN_W)}`;

  // Random headers (aman)
  const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const randomOkHttpUA = () => `okhttp/${choice(['4.9.3','4.10.0','4.11.0','4.12.0'])}`;
  const randomLang = () => choice([
    'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
    'id,en-US;q=0.9,en;q=0.8',
    'en-US,en;q=0.9,id;q=0.8',
    'id-ID,en;q=0.9'
  ]);
  const makeAccountHeaders = () => ({
    'accept': 'application/json, text/plain, */*',
    'accept-encoding': 'gzip',
    'accept-language': randomLang(),
    'user-agent': randomOkHttpUA(),
    'connection': 'Keep-Alive'
  });

  const withTimeout = (promise, ms, label = 'Timeout') =>
    Promise.race([ promise, new Promise((_, rej) => setTimeout(() => rej(new Error(label)), ms)) ]);

  const getLoginAccountSafe = async (email, pwd, accHeaders) => {
    try {
      try {
        return await withTimeout(getLoginAccount(email, pwd, accHeaders), 20000, 'login timeout');
      } catch {
        return await withTimeout(getLoginAccount(email, pwd), 20000, 'login timeout');
      }
    } catch (e) {
      return { status_code: 0, message: e?.message || 'Login error' };
    }
  };

  const isMemberNotFound = (res) => {
    const sc  = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    return sc === 404 || /member not found|account not found|not found/.test(msg);
  };

  async function purgeLocalForEmailLocal(email) {
    const emKey = (email || '').toLowerCase();
    try {
      const raw = await fs.readFile('akunLogin.txt','utf-8');
      const kept = raw.split('\n').map(l=>l.trim()).filter(Boolean)
        .filter(l => (l.split('|')[0]?.trim().toLowerCase() || '') !== emKey);
      await fs.writeFile('akunLogin.txt', kept.join('\n') + (kept.length?'\n':''), 'utf-8');
    } catch(e) { if (e.code !== 'ENOENT') console.log(chalk.red(`(akunLogin.txt: ${e.message})`)); }
    try {
      const raw = await fs.readFile('data.txt','utf-8');
      const kept = raw.split('\n').map(s=>s.trim()).filter(Boolean)
        .filter(l => (l.split('|')[0]?.trim().toLowerCase() || l.toLowerCase()) !== emKey);
      await fs.writeFile('data.txt', kept.join('\n') + (kept.length?'\n':''), 'utf-8');
    } catch(e) { if (e.code !== 'ENOENT') console.log(chalk.red(`(data.txt: ${e.message})`)); }
    try {
      const raw = await fs.readFile('data_format.txt','utf-8');
      const kept = raw.split('\n').map(s=>s.trim()).filter(Boolean)
        .filter(l => (l.split('|')[0]?.trim().toLowerCase() || '') !== emKey);
      await fs.writeFile('data_format.txt', kept.join('\n') + (kept.length?'\n':''), 'utf-8');
    } catch(e) { if (e.code !== 'ENOENT') console.log(chalk.red(`(data_format.txt: ${e.message})`)); }
    try {
      const accRaw = await fs.readFile('account.json','utf-8');
      const acc = JSON.parse(accRaw);
      const items = (acc.items || []).filter(x => (x.email || '').toLowerCase() !== emKey).map((x,i)=>({ ...x, no:i+1 }));
      await fs.writeFile('account.json', JSON.stringify({
        ...acc,
        items,
        total_accounts: items.length,
        checked: items.length,
        generated_at: new Date().toISOString()
      }, null, 2), 'utf-8');
    } catch(e) { console.log(chalk.red(`(account.json: ${e.message})`)); }
  }
  const doPurgeLocal = (typeof purgeLocalForEmail === 'function') ? purgeLocalForEmail : purgeLocalForEmailLocal;

  // variabel password global (untuk manual/default)
  let customPassword = null;

  // â”€â”€ 1) pilih mode login (manual / file) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const { loginMode } = await inquirer.prompt([
    {
      type: 'list',
      name: 'loginMode',
      message: 'Pilih mode login:',
      choices: [
        { name: 'ğŸ“ Login MANUAL (input email di sini)', value: 'manual' },
        { name: 'ğŸ“‚ Auto login dari data.txt',          value: 'file' }
      ]
    }
  ]);

  // â”€â”€ 2) baca sumber akun & deteksi password dari file â”€â”€â”€â”€â”€â”€â”€â”€
  /**
   * sourceAccounts: Array<{
   *   email: string,
   *   pwdFromFile?: string|null,
   *   phoneFromFile?: string|null,
   *   pinFromFile?: string|null,
   *   raw: string
   * }>
   */
  let sourceAccounts = [];
  let dataSourceLabel = '';
  let fileHasPassword = false;

  if (loginMode === 'file') {
    let raw;
    try {
      raw = await fs.readFile('data.txt', 'utf-8');
    } catch {
      console.log(chalk.red('âŒ data.txt tidak ditemukan â€” isi dengan email atau "email | password | phone | pin".'));
      await delay(1500);
      return;
    }

    const lines = raw.split('\n').map(s=>s.trim()).filter(s=>s && !s.startsWith('#'));
    if (!lines.length) {
      console.log(chalk.red('âŒ data.txt kosong (atau semua baris adalah komentar).'));
      await delay(1500);
      return;
    }

    for (const line of lines) {
      const parts = line.split('|').map(p => p.trim());
      const email = parts[0] || '';
      if (!email) continue;

      const pwd   = parts[1] || '';
      const phone = parts[2] || '';
      const pin   = parts[3] || DEFAULT_PIN;

      if (pwd) fileHasPassword = true;

      sourceAccounts.push({
        email,
        pwdFromFile: pwd || null,
        phoneFromFile: phone || null,
        pinFromFile: pin || DEFAULT_PIN,
        raw: line
      });
    }

    if (!sourceAccounts.length) {
      console.log(chalk.red('âŒ Tidak ada email valid di data.txt.'));
      await delay(1500);
      return;
    }

    dataSourceLabel = 'data.txt';
  } else {
    // MODE MANUAL
    const { manualInput } = await inquirer.prompt([
      {
        type: 'input',
        name: 'manualInput',
        message: 'Masukkan email (bisa banyak, pisah dengan koma / spasi / enter):'
      }
    ]);

    const emails = String(manualInput || '')
      .split(/[,\s]+/)
      .map(s => s.trim())
      .filter(Boolean);

    if (!emails.length) {
      console.log(chalk.red('âŒ Tidak ada email yang diinput.'));
      await inquirer.prompt([{ type:'input', name:'pause', message:'Tekan Enter untuk kembaliâ€¦' }]);
      return;
    }

    sourceAccounts = emails.map(email => ({
      email,
      pwdFromFile: null,
      phoneFromFile: null,
      pinFromFile: DEFAULT_PIN,
      raw: email
    }));

    dataSourceLabel = 'manual input';
  }

  // â”€â”€ 3) dedupe by email â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const seenEmails = new Set();
  const uniques = [];
  const dups = [];

  for (const acc of sourceAccounts) {
    const key = norm(acc.email);
    if (!key) continue;
    if (seenEmails.has(key)) dups.push(acc);
    else {
      seenEmails.add(key);
      uniques.push(acc);
    }
  }

  // rewrite data.txt HANYA di mode file
  if (loginMode === 'file') {
    try {
      await fs.writeFile('data.txt', uniques.map(a => a.raw).join('\n') + '\n', 'utf-8');
    } catch (e) {
      console.log(chalk.red(`âš  gagal rewrite data.txt: ${e.message}`));
    }
  }

  // â”€â”€ 4) preview akun â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const width = String(uniques.length).length;
  console.log(chalk.gray('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Preview (unique emails) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”'));
  uniques.forEach((acc, i) => {
    const lineStr = formatLoginLine(
      acc.email,
      acc.pwdFromFile || '(pwd?)',
      acc.phoneFromFile || '-',
      acc.pinFromFile || DEFAULT_PIN
    );
    console.log(
      chalk.gray('â”‚'),
      chalk.white(`${padN(i+1, width)}.`),
      lineStr
    );
  });
  console.log(chalk.gray('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n'));

  console.log(
    chalk.yellow(
      `[INFO] Source: ${dataSourceLabel} | Rows: ${sourceAccounts.length} â€¢ Unique: ${uniques.length}`
    ) + (dups.length ? chalk.gray(` â€¢ Duplicates removed (by email): ${dups.length}`) : '')
  );

  if (loginMode === 'file' && fileHasPassword) {
    console.log(chalk.green('\n[INFO] data.txt berisi password per akun â†’ password akan diambil dari file (bukan default/global).'));
  }

  // â”€â”€ 5) auto-skip yg sudah ada di account.json â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let existingSet = new Set();
  try {
    const accRaw = await fs.readFile('account.json','utf-8');
    const acc = JSON.parse(accRaw);
    (acc.items || []).forEach(it => {
      if (it?.email) existingSet.add(norm(it.email));
    });
  } catch {}

  const toSkip = uniques.filter(a => existingSet.has(norm(a.email)));
  let toProcess = uniques.filter(a => !existingSet.has(norm(a.email)));

  if (toSkip.length) {
    console.log(chalk.blue(`\nSudah ada di account.json (AUTO-SKIP): ${toSkip.length}`));
    toSkip.forEach((a,i)=>console.log(chalk.blue(`  - [skip ${i+1}] ${a.email}`)));
  }
  console.log(chalk.green(`\nAkan diproses sekarang (benar-benar baru): ${toProcess.length}\n`));

  if (toProcess.length === 0) {
    const { retry } = await inquirer.prompt([{
      type: 'confirm',
      name: 'retry',
      message: 'Semua email sudah ada di account.json. Ulangi proses login untuk rebuild akunLogin.txt?',
      default: true
    }]);
    if (!retry) {
      console.log(chalk.gray('Dibatalkan.'));
      await inquirer.prompt([{ type:'input', name:'pause', message:'Press Enter to returnâ€¦' }]);
      return;
    }
    toProcess = [...uniques]; // proses ulang semuanya untuk rebuild akunLogin.txt
  }

  // â”€â”€ 6) pilih mode password (kecuali sudah ada di file) â”€â”€â”€â”€â”€â”€
  if (!(loginMode === 'file' && fileHasPassword)) {
    const { pwdMode } = await inquirer.prompt([
      {
        type: 'list',
        name: 'pwdMode',
        message: 'Pilih mode password:',
        choices: [
          { name: 'ğŸ” Pakai password default (Iqra0704 / Cgv123456)', value: 'default' },
          { name: 'âœï¸ Input 1 password manual untuk semua akun',       value: 'custom1' }
        ]
      }
    ]);

    if (pwdMode === 'custom1') {
      const { customPwd } = await inquirer.prompt([
        {
          type: 'password',
          name: 'customPwd',
          message: 'Masukkan password untuk semua akun:',
          mask: '*'
        }
      ]);
      customPassword = String(customPwd || '').trim();
      if (!customPassword) {
        console.log(chalk.red('âš  Password kosong, kembali menggunakan password default (Iqra0704 / Cgv123456).'));
        customPassword = null;
      }
    } else {
      customPassword = null; // pakai default (PRIMARY_PWD/FALLBACK_PWD)
    }
  } else {
    customPassword = null; // full pakai pwd dari file
  }

  // â”€â”€ 7) state summary + helper account.json â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const failMap = new Map();
  const alreadyDataFmt = new Set();
  try {
    (await fs.readFile('data_format.txt','utf-8')).split('\n').forEach(l=>{
      const em=l.split('|')[0]?.trim();
      if (em) alreadyDataFmt.add(norm(em));
    });
  } catch {}

  async function upsertAccountJson(item) {
    let data = { generated_at: new Date().toISOString(), total_accounts: 0, checked: 0, items: [] };
    try {
      const raw = await fs.readFile('account.json','utf-8');
      const j = JSON.parse(raw);
      if (j && Array.isArray(j.items)) data = j;
    } catch {}
    const idx = data.items.findIndex(x => x.email === item.email);
    if (idx >= 0) data.items[idx] = { ...data.items[idx], ...item, no: data.items[idx].no };
    else data.items.push({ no: data.items.length + 1, ...item });
    data.items = data.items.map((x,i)=>({ ...x, no: i+1 }));
    data.total_accounts = data.items.length;
    data.checked = data.items.length;
    data.generated_at = new Date().toISOString();
    await fs.writeFile('account.json', JSON.stringify(data, null, 2), 'utf-8');
  }

  const d8 = s => /^\d{8}$/.test(s) ? `${s.slice(0,4)}-${s.slice(4,6)}-${s.slice(6)}` : '-';
  const ageDaysFromD8 = (s) => {
    if (!/^\d{8}$/.test(s)) return 0;
    const y=+s.slice(0,4),m=+s.slice(4,6)-1,d=+s.slice(6,8);
    const start=new Date(y,m,d), now=new Date();
    const today=new Date(now.getFullYear(),now.getMonth(),now.getDate());
    const diff=Math.floor((today-start)/86400000);
    return diff>=0?diff:0;
  };

  // â¬‡ï¸ tambahkan password ke item (field: password)
  function buildItemFromInfo(email, info, password) {
    const m = info.RESULTS?.ds_mbrList || {};
    const coupons = info.RESULTS?.ds_CPN_LIST || [];
    const gifts   = info.RESULTS?.ds_GFT_LIST || [];
    return {
      login_ok: true,
      email,
      password, // <- disimpan di account.json
      name: m.MBR_NM || '-',
      gender: m.SEC_CD === '01' ? 'Male' : m.SEC_CD === '02' ? 'Female' : '-',
      tier: m.MBR_TIER_NM || 'NEW',
      points: m.MILEAGE_AMT ?? 0,
      phone: m.MOBILE_NO || '-',
      city: m.ADDR_REGION_NM || '-',
      join_date: d8(m.SITE_JOIN_DY),
      age_days: ageDaysFromD8(m.SITE_JOIN_DY),
      birthday: d8(m.BIRTHDAY),
      verified_phone: m.VERF_MOB_YN === '1',
      visits: m.TOT_VISIT_FOR_UI ?? 0,
      fav_theater: m.JOIN_THAT_NM || '-',
      has_birthday_voucher: [...coupons, ...gifts].some(v => /birthday/i.test(
        v.DSC_NM || v.GFTCERT_NM || v.ON_CUST_NOTY_CONT || ''
      ))
    };
  }

  // â”€â”€ 8) login policy: bisa pakai pwdFromFile / custom / default â”€
  async function loginWithSmartRetry(email, pwdFromFile) {
    const headers = makeAccountHeaders();

    const PWD_ORDER = pwdFromFile
      ? [pwdFromFile]                          // password dari data.txt (per akun)
      : (customPassword
          ? [customPassword]                   // 1 password global dari input
          : [PRIMARY_PWD, FALLBACK_PWD]);      // default lama

    let last = null;

    for (const pwd of PWD_ORDER) {
      let backoff = 1500;
      const start = Date.now();
      while (true) {
        const res = await getLoginAccountSafe(email, pwd, headers);
        last = res;
        if (res?.status_code === 200 && res?.token) return { ok: true, usedPwd: pwd, res };

        if (looksWrongPassword(res)) break; // ganti ke password berikutnya

        // selain invalid creds â†’ tetap retry dengan password yang sama
        await delay(backoff);
        backoff = Math.min(backoff * 1.6, 10000);

        // safety time cap per password
        if ((Date.now() - start) > 240000) break; // 4 menit per password
      }
    }
    return { ok: false, res: last };
  }

  // â”€â”€ 9) writer: flush batch hasil OK ke akunLogin.txt â”€â”€â”€â”€â”€â”€â”€â”€
  async function flushAkunLoginBatch(batchLines) {
    // batchLines: Array<{email, pwd, phone}>
    const byEmail = new Map(batchLines.map(x => [norm(x.email), x]));
    let existing = [];
    try { existing = (await fs.readFile('akunLogin.txt','utf-8')).split('\n'); } catch {}
    const sanitized = existing.map(s => s.replace(/\r/g,'').trim()).filter(Boolean);

    const existMap = new Map();
    const order = [];
    for (const line of sanitized) {
      const parts = line.split('|').map(t=>String(t).trim());
      const e = parts[0] || ''; if (!e) continue;
      const p = parts[1] || ''; const ph = parts[2] || ''; const pin = parts[3] || DEFAULT_PIN;
      const key = norm(e);
      if (!existMap.has(key)) order.push(key);
      existMap.set(key, { email: e, pwd: p, phone: ph, pin });
    }

    for (const [k, v] of byEmail.entries()) {
      if (!existMap.has(k)) order.push(k);
      existMap.set(k, {
        email: v.email,
        pwd: v.pwd,
        phone: v.phone || '-',
        pin: DEFAULT_PIN
      });
    }

    const out = order.map(k => {
      const { email, pwd, phone, pin } = existMap.get(k);
      return formatLoginLine(email, pwd, phone, pin);
    });

    await fs.writeFile('akunLogin.txt', out.join('\n') + (out.length?'\n':''), 'utf-8');
  }

  // â”€â”€ 10) process with batching (5 akun per sesi) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let ok = 0, fail = 0;
  const total = toProcess.length;
  const w = String(total).length;

  for (let start = 0, sess = 1; start < total; start += CONCURRENCY, sess++) {
    const batch = toProcess.slice(start, start + CONCURRENCY);
    const i1 = start + 1, i2 = Math.min(start + CONCURRENCY, total);
    console.log(chalk.gray(`\n[Session ${sess}/${Math.ceil(total/CONCURRENCY)}] Accounts ${i1}-${i2}`));

    const batchLines = []; // for akunLogin.txt flush per sesi

    await Promise.allSettled(batch.map(async (acc, idx) => {
      const email = acc.email;
      const idxStr = `${padN(start + idx + 1, w)}/${padN(total, w)}`;
      const attempt = await loginWithSmartRetry(email, acc.pwdFromFile);

      if (attempt.ok) {
        const usedPwd = attempt.usedPwd;
        const res = attempt.res;

        const info = await getMemberInfo(res.token);
        let m = {};
        if (info?.status_code === 200) {
          // â¬‡ï¸ simpan password ke account.json
          await upsertAccountJson(buildItemFromInfo(email, info, usedPwd));
          m = info.RESULTS?.ds_mbrList || {};
        } else {
          await upsertAccountJson({
            login_ok: true,
            email,
            password: usedPwd, // â¬…ï¸ diisi juga walau info gagal
            name: '-',
            gender: '-',
            tier: 'NEW',
            points: 0,
            phone: '-',
            city: '-',
            join_date: '-',
            age_days: 0,
            birthday: '-',
            verified_phone: false,
            visits: 0,
            fav_theater: '-',
            has_birthday_voucher: false
          });
        }

        const name  = (m.MBR_NM || '-');
        const tier  = (m.MBR_TIER_NM || 'NEW');
        const pts   = (m.MILEAGE_AMT ?? 0);
        const phone = (m.MOBILE_NO || '-');
        const city  = (m.ADDR_REGION_NM || '-');
        const vhp   = m.VERF_MOB_YN === '1' ? 'âœ”' : 'âœ–';

        console.log(
          `[${chalk.green(idxStr)}]`,
          chalk.green('OK'),
          chalk.white(email),
          chalk.gray('â†’'),
          chalk.cyan(name),
          chalk.gray('|'),
          `${tier}`,
          chalk.gray('â€¢'),
          `${pts}pts`,
          chalk.gray('â€¢'),
          `${phone}`,
          chalk.gray('â€¢'),
          `${city}`,
          chalk.gray('â€¢'),
          `V-HP:${vhp}`,
          chalk.gray(`(pwd ${usedPwd})`)
        );

        batchLines.push({ email, pwd: usedPwd, phone });

        if (m.VERF_MOB_YN === '1') {
          const key = norm(email);
          if (!alreadyDataFmt.has(key)) {
            try {
              await fs.appendFile(
                'data_format.txt',
                `${email.padEnd(EMAIL_W)} | ${usedPwd.padEnd(PWD_W)} | ${String(phone).padEnd(PHONE_W)} | ${String(DEFAULT_PIN).padEnd(PIN_W)}\n`,
                'utf-8'
              );
              alreadyDataFmt.add(key);
              console.log(chalk.blue(`â†’ Saved to data_format.txt (verified)`));
            } catch (e) {
              console.log(chalk.red(`â†’ Gagal tulis data_format.txt: ${e.message}`));
            }
          }
        }

        ok++;
      } else {
        const reason = reasonFromLoginError(attempt.res);
        failMap.set(reason, (failMap.get(reason) || 0) + 1);

        const sc  = attempt.res?.status_code ?? '-';
        const msg = String(attempt.res?.message || '').replace(/\s+/g,' ').trim();
        const short = msg.length > 120 ? msg.slice(0,119) + 'â€¦' : msg;

        console.log(
          `[${chalk.red(idxStr)}]`,
          chalk.red('FAIL'),
          chalk.white(acc.email),
          chalk.gray('â€”'),
          chalk.yellow(reason),
          chalk.gray(`(status ${sc}${short ? ` | ${short}` : ''})`)
        );

        if (isMemberNotFound(attempt.res)) {
          try { await doPurgeLocal(acc.email); } catch(e) { console.log(chalk.red(`â†’ Purge local failed: ${e.message}`)); }
        }

        fail++;
      }
    }));

    try { await flushAkunLoginBatch(batchLines); }
    catch (e) { console.log(chalk.red(`â†’ Gagal flush akunLogin.txt (session ${sess}): ${e.message}`)); }
  }

  // â”€â”€ 11) summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const dt = ((Date.now() - t0) / 1000).toFixed(1);
  const avg = (total ? (dt / total).toFixed(2) : '0.00');

  console.log('\n' + chalk.cyan('â•'.repeat(70)));
  console.log(
    chalk.cyan('[SUMMARY]'),
    chalk.green(`OK: ${ok}`),
    chalk.cyan('|'),
    chalk.red(`FAIL: ${fail}`),
    chalk.cyan('|'),
    chalk.white(`Processed: ${total}`),
    chalk.cyan('|'),
    chalk.white(`Time: ${dt}s (avg ${avg}s/account)`)
  );

  if (fail) {
    console.log(chalk.cyan('\nFailure breakdown:'));
    const sorted = [...failMap.entries()].sort((a,b)=>b[1]-a[1]);
    for (const [rsn, cnt] of sorted) console.log(' -', chalk.yellow(rsn), chalk.gray(`x${cnt}`));
  }

  console.log(chalk.gray('\n[âœ“] Selesai â€” tekan Enter untuk kembali ke menu.'));
  await inquirer.prompt([{ type:'input', name:'pause', message:'' }]);
}





/* =======================================================================
   CHECK TRANSACTIONS â€” single-file store (transactions.json)
   - Sumber akun: langsung dari account.json (email + password)
   - Tanpa prompt pilih akun â€” langsung proses (batch per 5 akun per sesi)
   - GET /membership/transactions (ETag per email, headers di-random per akun)
   - Enrich per transaksi: GET /membership/tickets/{sales_id} (ETag per sales_id, headers di-random per akun)
   - Start/End/Type fallback dari tickets bila kosong
   - Tabel ringkas + tabel detail (Normal/Disc/Paid/Pts)
   - Semua cache/etag/detail di transactions.json (no extra files)
   - UPDATE: Pakai bearer dari account.json dulu; jika invalid â†’ login
             dan HANYA memperbarui field bearer terkait (bearer, bearer_wrapped, bearer_updated_at)
   - UPDATE: Randomize HTTP headers per akun (UA & Accept-Language)
   - UPDATE: Fallback password dari ENV DEFAULT_PASSWORDS jika item.password salah/kosong
             (jika berhasil login dgn password berbeda â†’ HANYA update field password/password_updated_at)
   - Sangat penting: TIDAK menyentuh "generated_at" dan TIDAK menomori ulang "no".
                     Semua patch ke account.json dilakukan SEKTOR per-field di AKHIR saja.
   ======================================================================= */
async function checkTransactions() {
  console.clear();
  const tStart = Date.now();
  const delay = (ms)=>new Promise(r=>setTimeout(r,ms));

  console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.cyan('â•‘                      CHECK TRANSACTIONS                      â•‘'));
  console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));

  // ===== CONFIG =====
  const CONCURRENCY = 5;          // paralel akun per sesi
  const DETAIL_CONCURRENCY = 5;   // paralel detail tiket per akun
  const TXN_SAVE_LIMIT = 300;     // limit simpan per email di json
  const TXN_TIMEOUT_MS = 15000;

  // ===== util dasar =====
  const padN = (n,w) => String(n).padStart(w,'0');
  const norm = s => String(s || '').trim().toLowerCase();
  const fmtID = (val) => {
    if (val === '-' || val === null || val === undefined) return '-';
    const num = Number(val);
    if (!Number.isFinite(num)) return String(val);
    try { return num.toLocaleString('id-ID'); }
    catch { return String(Math.trunc(num)).replace(/\B(?=(\d{3})+(?!\d))/g, '.'); }
  };
  const deepPick = (obj, candidates) => {
    for (const key of candidates) {
      if (!key) continue;
      const path = String(key).split('.');
      let cur = obj, ok = true;
      for (const p of path) {
        if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
        else { ok = false; break; }
      }
      if (ok && cur !== undefined && cur !== null && !(typeof cur === 'string' && cur.trim() === '')) return cur;
    }
    return null;
  };
  const parseDateAny = (x) => {
    if (x === null || x === undefined) return null;
    if (typeof x === 'number') { const ms = x > 1e12 ? x : x * 1000; const d = new Date(ms); return isNaN(d)?null:d; }
    let s = String(x).trim(); if (!s) return null;
    if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(s)) s = s.replace(' ', 'T');
    if (/^\d{14}$/.test(s)) { const y=s.slice(0,4), m=s.slice(4,6), d=s.slice(6,8), H=s.slice(8,10), M=s.slice(10,12), S=s.slice(12,14); const dt=new Date(+y,+m-1,+d,+H,+M,+S); return isNaN(dt)?null:dt; }
    if (/^\d{8}$/.test(s))  { const y=s.slice(0,4), m=s.slice(4,6), d=s.slice(6,8); const dt=new Date(+y,+m-1,+d,0,0,0); return isNaN(dt)?null:dt; }
    const d = new Date(s); return isNaN(d)?null:d;
  };
  const toIsoLocal = (x) => {
    const d = parseDateAny(x); if (!d) return null;
    const pad = (n)=>String(n).padStart(2,'0');
    const y=d.getFullYear(), m=pad(d.getMonth()+1), day=pad(d.getDate());
    const H=pad(d.getHours()), M=pad(d.getMinutes()), S=pad(d.getSeconds());
    return `${y}-${m}-${day} ${H}:${M}:${S}`;
  };
  const isValidTime = (s) => typeof s === 'string' && /^\d{2}:\d{2}$/.test(s);
  const statusColor = (st) => {
    if (/SUCCESS/i.test(st)) return chalk.green(st);
    if (/PENDING/i.test(st)) return chalk.yellow(st);
    if (/CANCELLED|FAIL|UNKNOWN/i.test(st)) return chalk.red(st);
    return st;
  };
  const deriveType = (it, detail) => {
    if (it?.type) return it.type;
    if (detail && (detail.movie_format || detail.movie_duration || detail.auditorium_name)) return 'Movie';
    const ttl = String(it?.title || '').toLowerCase();
    if (/(popcorn|combo|drink|beverage|soda|nacho|hotdog|snack|f&b|conces|corn)/i.test(ttl)) return 'Food & Beverage';
    if (it?.amount === 0 && !(detail?.seat_labels?.length)) return 'Food & Beverage';
    return null;
  };

  // ===== random header helpers (aman) =====
  const choice = (arr)=>arr[Math.floor(Math.random()*arr.length)];
  const randomOkHttpUA = () => `okhttp/${choice(['4.9.3','4.10.0','4.11.0','4.12.0'])}`;
  const randomLang = () => choice([
    'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
    'id,en-US;q=0.9,en;q=0.8',
    'en-US,en;q=0.9,id;q=0.8',
    'id-ID,en;q=0.9'
  ]);
  const makeAccountHeaders = () => ({
    'accept': 'application/json, text/plain, */*',
    'accept-encoding': 'gzip',
    'accept-language': randomLang(),
    'user-agent': randomOkHttpUA(),
    'connection': 'Keep-Alive'
  });

  // ===== helper untuk bearer/password update â€” BATCH di akhir =====
  const wrapBearer3 = (token) => {
    const s = String(token || '');
    if (!s) return [];
    const partLen = Math.ceil(s.length / 3);
    return [ s.slice(0, partLen), s.slice(partLen, partLen*2), s.slice(partLen*2) ];
  };

  // Kumpulan patch yang akan diaplikasikan SEKALI di akhir:
  // pendingUpdates[email] = { bearer?, bearer_wrapped?, bearer_updated_at?,
  //                           password?, password_updated_at? }
  const pendingUpdates = Object.create(null);

  const queueBearerUpdate = (email, newToken) => {
    const e = String(email || '');
    if (!e || !newToken) return;
    if (!pendingUpdates[e]) pendingUpdates[e] = {};
    pendingUpdates[e].bearer = newToken;
    pendingUpdates[e].bearer_wrapped = wrapBearer3(newToken);
    pendingUpdates[e].bearer_updated_at = new Date().toISOString();
  };
  const queuePasswordUpdate = (email, newPwd) => {
    const e = String(email || '');
    if (!e || !newPwd) return;
    if (!pendingUpdates[e]) pendingUpdates[e] = {};
    pendingUpdates[e].password = newPwd;
    pendingUpdates[e].password_updated_at = new Date().toISOString();
  };

  // ===== HTTP helper (fetch + timeout) =====
  const httpGetJson = async (url, headers = {}) => {
    const ctrl = new AbortController();
    const id = setTimeout(()=>ctrl.abort(), TXN_TIMEOUT_MS);
    try {
      const res = await fetch(url, { headers, signal: ctrl.signal });
      clearTimeout(id);
      const status = res.status;
      const hdrs = Object.fromEntries([...res.headers.entries()].map(([k,v])=>[k.toLowerCase(), v]));
      let data = null;
      if (status !== 304) { try { data = await res.json(); } catch {} }
      return { status, headers: hdrs, data };
    } catch (e) {
      clearTimeout(id);
      return { status: 0, headers: {}, data: null, error: e?.message || String(e) };
    }
  };

  // ===== MUAT AKUN LANGSUNG DARI account.json =====
  let accountJson = { items: [] };
  try {
    const raw = await fs.readFile('account.json','utf-8');
    const j = JSON.parse(raw);
    if (j && Array.isArray(j.items)) accountJson = j;
  } catch {}

  const akunList = (accountJson.items || [])
    .filter(it => it && it.email && String(it.email).includes('@'))
    .map(it => ({ email: it.email, password: it.password || '' })); // jika kosong â†’ akan fallback ke ENV

  if (!akunList.length) {
    console.log(chalk.red('âŒ  Tidak ada akun valid di account.json (butuh email + setidaknya fallback password dari ENV).'));
    await delay(1500);
    return;
  }

  // Tampilkan preview daftar akun (tanpa prompt)
  {
    const TableCtor = await universalTable();
    const t = new TableCtor({ head:['No','Email'], colWidths:[6,58], wordWrap:true, style:{head:['yellow']} });
    akunList.forEach((a,i)=>t.push([padN(i+1,2), a.email]));
    console.log(t.toString());
    console.log(chalk.gray(`Total accounts: ${akunList.length}\n`));
  }

  // ===== store tunggal: transactions.json =====
  let store = {
    generated_at: new Date().toISOString(),
    meta: {
      transactions_etag: {},  // { email : etag }
      tickets_etag: {},       // { sales_id : etag }
      tickets_cache: {}       // { sales_id : raw payload of /tickets }
    },
    items: []
  };
  try {
    const raw = await fs.readFile('transactions.json','utf-8');
    const j = JSON.parse(raw);
    if (j && typeof j === 'object') store = { ...store, ...j,
      meta: { transactions_etag:{}, tickets_etag:{}, tickets_cache:{}, ...(j.meta || {}) },
      items: Array.isArray(j.items) ? j.items : []
    };
  } catch {}

  const upsertEmail = (email, payload) => {
    const idx = store.items.findIndex(x => x.email === email);
    if (idx >= 0) store.items[idx] = { ...store.items[idx], ...payload };
    else store.items.push(payload);
  };
  const getEmailRec = (email) => store.items.find(x => x.email === email) || null;

  // ===== API wrappers with ETag + RANDOM headers per akun =====
  const getTransactions = async (email, token, opts = { force:false }, accHeaders) => {
    const url = 'https://v2-api.cgv.id/api/membership/transactions';
    const baseHeaders = {
      'accept': 'application/json, text/plain, */*',
      'authorization': `Bearer ${token}`,
      'accept-encoding': 'gzip',
      'accept-language': accHeaders?.['accept-language'] || 'id-ID,id;q=0.9',
      'user-agent': accHeaders?.['user-agent'] || 'okhttp/4.10.0',
      'connection': 'Keep-Alive'
    };
    const et = store.meta.transactions_etag[email];
    const headers = (!opts.force && et) ? { ...baseHeaders, 'if-none-match': et } : baseHeaders;
    const res = await httpGetJson(url, headers);

    if (!opts.force && res.status === 304) return { items:null, fromCache:true };
    if (res.status !== 200 || !res.data)   return { items:[], fromCache:false, error:`HTTP ${res.status || 'ERR'}` };

    const eheader = res.headers?.etag || res.headers?.ETag;
    if (eheader) store.meta.transactions_etag[email] = eheader;

    let arr = deepPick(res.data, ['data']) || [];
    if (!Array.isArray(arr)) arr = [];
    const items = arr.map(parseTxnItem)
      .sort((a,b)=> (new Date(b.created_at||b.showtime_at||0)) - (new Date(a.created_at||a.showtime_at||0)));
    return { items, fromCache:false };
  };

  const parseTxnItem = (t) => {
    const id        = deepPick(t, ['sales_id','ORD_ID','ORDER_ID','TRAN_ID','ID']);
    const orderNo   = deepPick(t, ['sales_id','ORD_NO','ORDER_NO','BOOK_NO','BOOKING_NO']);
    const title     = deepPick(t, ['name','MOVIE_NM','MOV_TTL_NM','TTL_NM','TITLE_NM','GOODS_NM']);
    const theater   = deepPick(t, ['cinema_name','THEATER_NM','BRCH_NM']);
    const screen    = deepPick(t, ['audi_type','SCRN_NM','SCREEN_NM']);
    const type      = deepPick(t, ['type','ORD_TP_NM','CATEGORY']) || null;

    const movieDate = deepPick(t, ['movie_date']);
    const movieStart= deepPick(t, ['movie_start_time']);
    const movieEnd  = deepPick(t, ['movie_end_time']);
    const pickup    = deepPick(t, ['pickup_date','PICKUP_DY']) || null;
    const insurance = deepPick(t, ['insurance_id','INS_ID']) || null;

    const createdAt = deepPick(t, ['transaction_date_time','REG_DTTM','ORD_DTTM','transaction_date']);
    const amount    = deepPick(t, ['amount','PAY_AMT','TOT_PAY_AMT']);
    const tixCnt    = deepPick(t, ['qty','TICK_QTY','SEAT_CNT']);

    const rawStat   = deepPick(t, ['ORD_STAT_NM','STAT_NM','STATUS_NM','ORDER_STATUS','PAY_STAT_NM']);
    const isComplete= deepPick(t, ['is_complete']);

    let status = 'UNKNOWN';
    if (rawStat) {
      const s=String(rawStat).toLowerCase();
      if (/cancel|void|refund|batal|gagal|fail|chargeback/.test(s)) status = 'CANCELLED';
      else if (/success|paid|complete|berhasil|selesai|approved|settled/.test(s)) status = 'SUCCESS';
      else if (/pending|menunggu|await|process|processing|unpaid/.test(s)) status = 'PENDING';
    }
    if (status === 'UNKNOWN' && isComplete != null)
      status = Number(isComplete) === 1 ? 'SUCCESS' : 'PENDING';

    let showAt = null;
    if (movieDate && isValidTime(movieStart) && isValidTime(movieEnd)) showAt = `${movieDate} ${movieStart}â€“${movieEnd}`;
    else if (movieDate && isValidTime(movieStart)) showAt = `${movieDate} ${movieStart}`;

    return {
      id,
      order_no: orderNo || null,
      title: title || null,
      type: type || null,
      theater: theater || null,
      screen: screen || null,
      movie_date: movieDate || null,
      movie_start_time: isValidTime(movieStart) ? movieStart : null,
      movie_end_time:   isValidTime(movieEnd)   ? movieEnd   : null,
      showtime_at:      toIsoLocal(showAt),
      created_at:       toIsoLocal(createdAt),
      tickets: tixCnt == null ? null : Number(tixCnt),
      amount:  amount == null ? null : Number(amount),
      status,
      pickup_date: pickup,
      insurance_id: insurance
    };
  };

  const parseTicketDetail = (d) => {
    if (!d) return null;
    const payments = Array.isArray(d.payment) ? d.payment : [];
    const payNames = payments.map(p => p.payment_name).filter(Boolean).join(' + ') || null;
    const cfTotal  = payments.reduce((a,p)=>a + (Number(p.convenience_fee||0)), 0);
    const subTotals= payments.reduce((a,p)=>a + (Number(p.subtotal||0)), 0);

    const seats = Array.isArray(d.seats) ? d.seats : [];
    const seatList = seats.map(s => `${s.row_name||''}${s.number||''}`).filter(Boolean);

    return {
      movie_format: d.movie_format || null,
      movie_duration: Number(d.movie_duration || 0) || null,
      movie_censor_rating: d.movie_censor_rating || null,
      auditorium_name: d.auditorium_name || null,

      movie_date: d.movie_date || null,
      movie_start_time: d.movie_start_time || null,
      movie_end_time: d.movie_end_time || null,

      booking_code: d.booking_code || null,
      pass_key: d.pass_key || null,

      normal_price: d.sub_total_amount == null ? null : Number(d.sub_total_amount),
      discount_total: d.discount == null ? null : Number(d.discount),
      paid_total: d.total_amount == null ? null : Number(d.total_amount),
      point_reward: d.point_reward == null ? null : Number(d.point_reward),

      payment_names: payNames,
      payment_subtotal_sum: subTotals || null,
      payment_fee_sum: cfTotal || null,

      seat_labels: seatList.length ? seatList : null
    };
  };

  const getTicketDetail = async (salesId, token, accHeaders) => {
    const url = `https://v2-api.cgv.id/api/membership/tickets/${encodeURIComponent(salesId)}`;
    const baseHeaders = {
      'accept': 'application/json, text/plain, */*',
      'authorization': `Bearer ${token}`,
      'accept-encoding': 'gzip',
      'accept-language': accHeaders?.['accept-language'] || 'id-ID,id;q=0.9',
      'user-agent': accHeaders?.['user-agent'] || 'okhttp/4.10.0',
      'connection': 'Keep-Alive'
    };
    const et = store.meta.tickets_etag[salesId];
    const headers = et ? { ...baseHeaders, 'if-none-match': et } : baseHeaders;

    const res = await httpGetJson(url, headers);
    if (res.status === 304) {
      const cached = store.meta.tickets_cache[salesId];
      if (cached) return { ok:true, data: cached, fromCache:true };
      return { ok:false, error:'304 but no cache' };
    }
    if (res.status !== 200 || !res.data) return { ok:false, error:`HTTP ${res.status || 'ERR'}` };

    const eheader = res.headers?.etag || res.headers?.ETag;
    if (eheader) store.meta.tickets_etag[salesId] = eheader;

    const payload = res.data?.data || null;
    if (payload) store.meta.tickets_cache[salesId] = payload;
    return { ok:true, data: payload, fromCache:false };
  };

  // ===== bearer + login helpers =====
  const reasonFromLoginError = (res) => {
    const sc = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    if (typeof looksWrongPassword === 'function' && looksWrongPassword(res)) return 'Wrong password (all tried)';
    if (sc === 429 || /too many|rate limit/.test(msg))       return 'Rate limited (429)';
    if (sc === 404 || /member not found|not found/.test(msg))return 'Account not found';
    if (/non-json response/.test(msg))                       return 'Anti-bot/gateway (non-JSON)';
    if (/timeout|network|fetch fail|networkerror/.test(msg)) return 'Network error';
    if (sc >= 500)                                           return `Server error (${sc})`;
    if (sc && sc !== 200)                                    return `HTTP ${sc}`;
    return 'Unknown login error';
  };

  const getMemberInfoSafe = async (token, accHeaders) => {
    try {
      try { return await getMemberInfo(token, accHeaders); }
      catch { return await getMemberInfo(token); }
    } catch { return null; }
  };
  const getLoginAccountSafe = async (email, pwd, accHeaders) => {
    try {
      try { return await getLoginAccount(email, pwd, accHeaders); }
      catch { return await getLoginAccount(email, pwd); }
    } catch (e) { return { status_code: 0, message: e?.message || 'Login error' }; }
  };

  // ===== tabel ringkas per akun =====
  const Table = await universalTable();
  const resultTable = new Table({
    head:['No','Email','Name','Txns','LastAt','LastTitle','LastAmount','LastStatus'],
    wordWrap:true,
    style:{ head:['green'] }
  });

  // ===== buat map bearer/password dari account.json (untuk akses cepat) =====
  const bearerMap = new Map();
  const passMap   = new Map();
  for (const it of (accountJson.items || [])) {
    if (it?.email && it?.bearer)   bearerMap.set(norm(it.email), String(it.bearer));
    if (it?.email && it?.password) passMap.set(norm(it.email), String(it.password));
  }

  // ===== kandidat password default dari ENV =====
  const envPwdRaw = String(process.env.DEFAULT_PASSWORDS || '').trim();
  const envPwdList = envPwdRaw
    ? envPwdRaw.split(',').map(s=>s.trim()).filter(Boolean)
    : []; // jika ENV kosong, tidak pakai fallback

  const total = akunList.length;

  const processOne = async (idx, {email, password}) => {
    const accHeaders = makeAccountHeaders();

    process.stdout.write(chalk.gray(`Checking ${email} â€¦ `));

    // 0) Pakai bearer dari account.json â†’ validasi
    let token = bearerMap.get(norm(email)) || null;
    let name = '-';
    let needLogin = false;

    if (token) {
      try {
        const infoPing = await getMemberInfoSafe(token, accHeaders);
        const unauthorized = infoPing?.status_code === 401 || /unauth|expired|invalid/i.test(String(infoPing?.message||'')); 
        if (!infoPing?.RESULTS?.ds_mbrList || unauthorized) {
          needLogin = true;
        } else {
          name = infoPing.RESULTS.ds_mbrList.MBR_NM || '-';
        }
      } catch { needLogin = true; }
    } else {
      needLogin = true;
    }

    // 1) Login kalau bearer invalid/tidak ada
    let usedPwd = null;
    if (needLogin) {
      const candPwd = [];
      // password utama dari account.json
      if (password) candPwd.push(String(password).trim());
      // pastikan dari passMap (jika berbeda)
      const fromMap = passMap.get(norm(email));
      if (fromMap && fromMap !== password) candPwd.push(String(fromMap).trim());
      // tambah ENV defaults
      candPwd.push(...envPwdList);

      // unikkan
      const unique = [...new Set(candPwd.filter(Boolean))];

      let last = null;
      for (const pwd of unique) {
        try {
          last = await getLoginAccountSafe(email, pwd, accHeaders);
          if (last?.status_code === 200 && last?.token) {
            token = last.token;
            usedPwd = pwd;
            // antrekan update BEARER (hanya field bearer terkait)
            queueBearerUpdate(email, token);
            // jika pwd berbeda dengan account.json â†’ antrekan update password
            if (!password || password !== usedPwd) {
              queuePasswordUpdate(email, usedPwd);
            }
            break;
          }
          console.log(chalk.red(`[âœ—] Login gagal (${email}) pwd "${pwd}": ${last?.message || last?.status_code}`));
        } catch (e) {
          console.log(chalk.red(`[âœ—] Login exception (${email}) "${pwd}": ${e.message}`));
        }
        await delay(500);
      }
      if (!token) {
        const reason = reasonFromLoginError(last);
        console.log(chalk.red('FAIL'), chalk.white(email), chalk.gray('â€”'), chalk.yellow(reason));
        resultTable.push([idx+1, email, '-', '0', '-', '-', '-', 'LOGIN_FAIL']);
        upsertEmail(email, { email, login_ok:false, reason });
        return;
      }
      // ambil nama setelah login
      try {
        const info = await getMemberInfoSafe(token, accHeaders);
        name = info?.RESULTS?.ds_mbrList?.MBR_NM || '-';
      } catch {}
    }

    // 2) transactions (cache-aware)
    let items = [], fromCache = false, err = null;
    try {
      let trx = await getTransactions(email, token, { force:false }, accHeaders);
      fromCache = !!trx.fromCache;

      if (trx.fromCache) {
        const cached = getEmailRec(email)?.transactions_recent || [];
        const isEmpty = !Array.isArray(cached) || cached.every(it => !it || (!it.title && !it.amount && !it.created_at && !it.showtime_at && !it.id));
        if (isEmpty) {
          trx = await getTransactions(email, token, { force:true }, accHeaders);
          fromCache = false;
          items = Array.isArray(trx.items) ? trx.items : [];
        } else {
          items = cached;
        }
      } else {
        items = Array.isArray(trx.items) ? trx.items : [];
      }
      if (trx.error) err = trx.error;
    } catch (e) { err = e.message || String(e); }

    // 3) enrich tickets (pakai token yang sama + random headers)
    const withSid = items.filter(it => it.order_no || it.id);
    for (let i=0; i<withSid.length; i+=DETAIL_CONCURRENCY) {
      const chunk = withSid.slice(i, i+DETAIL_CONCURRENCY);
      await Promise.all(chunk.map(async it => {
        const sid = it.order_no || it.id;
        try {
          const det = await getTicketDetail(sid, token, accHeaders);
          if (det.ok) {
            const d = parseTicketDetail(det.data);
            it.detail = d;

            // fallback Start/End/Date/Audi/Type
            if (!it.movie_start_time && isValidTime(d.movie_start_time)) it.movie_start_time = d.movie_start_time;
            if (!it.movie_end_time   && isValidTime(d.movie_end_time))   it.movie_end_time   = d.movie_end_time;
            if (!it.movie_date && d.movie_date) it.movie_date = d.movie_date;
            if (!it.screen && d.auditorium_name) it.screen = d.auditorium_name;
            const derived = deriveType(it, d);
            if (!it.type && derived) it.type = derived;
          }
        } catch {}
      }));
    }

    // 4) ringkas untuk tabel atas
    const count = items.length;
    const last = items[0] || null;
    const lastAt = last?.created_at || last?.showtime_at || null;
    const lastTitle = last?.title || null;
    const lastAmt = (last?.detail?.paid_total != null) ? last.detail.paid_total : (last?.amount ?? null);
    const lastStatus = last?.status || null;

    console.log(chalk.green('OK'), chalk.white(email), chalk.gray(`â€¢ Txns:${count}${fromCache?' (cache)':''}`));

    resultTable.push([
      idx+1,
      email,
      name,
      String(count),
      lastAt || '-',
      lastTitle || '-',
      lastAmt==null ? '-' : fmtID(lastAmt),
      lastStatus ? statusColor(lastStatus) : '-'
    ]);

    // 5) simpan ke store tunggal
    upsertEmail(email, {
      email,
      login_ok: true,
      name,
      transactions_count: count,
      last_transaction_at: lastAt,
      last_transaction_title: lastTitle,
      last_transaction_amount_paid: last?.detail?.paid_total ?? null,
      last_transaction_amount_raw: last?.amount ?? null,
      last_transaction_status: lastStatus,
      transactions_recent: items.slice(0, TXN_SAVE_LIMIT)
    });

    // persist sementara per akun (tidak masalah menyentuh transactions.json bertahap)
    store.generated_at = new Date().toISOString();
    try { await fs.writeFile('transactions.json', JSON.stringify(store, null, 2), 'utf-8'); } catch {}
  };

  // ===== jalankan dalam batch (per sesi 5 akun) =====
  const totalSessions = Math.ceil(total / CONCURRENCY);
  for (let start = 0, sess = 1; start < total; start += CONCURRENCY, sess++) {
    const batch = akunList.slice(start, start + CONCURRENCY);
    const i1 = start + 1;
    const i2 = Math.min(start + CONCURRENCY, total);
    console.log(chalk.gray(`\n[Session ${sess}/${totalSessions}] Accounts ${i1}-${i2} â€¢ Per-account header randomization: ON`));
    await Promise.allSettled(batch.map((acc, k) => processOne(start + k, acc)));
  }

  // save store terakhir
  store.generated_at = new Date().toISOString();
  try { await fs.writeFile('transactions.json', JSON.stringify(store, null, 2), 'utf-8'); }
  catch (e) { console.log(chalk.red(`â†’ Gagal menulis transactions.json: ${e.message}`)); }

  // ===== tampilkan ringkas =====
  console.log('\n' + resultTable.toString());

  // ===== tampilkan DETAIL per akun (dari store yang baru) =====
  for (const rec of store.items) {
    if (!rec.login_ok) continue;
    const items = Array.isArray(rec.transactions_recent) ? rec.transactions_recent : [];
    console.log(chalk.cyan(`\nTransactions for ${rec.email} (${items.length} items):`));
    if (!items.length) { console.log(chalk.gray('  (no transactions)')); continue; }

    const Table2 = await universalTable();
    const t2 = new Table2({
      head:['#','BoughtAt','ShowDate','Start','End','Title','Type','Cinema','Audi','Qty','Normal','Disc','Paid','Pts','Status','SalesID'],
      wordWrap:true,
      style:{ head:['yellow'] }
    });

    items.forEach((it, i) => {
      const showDate = it.movie_date || (it.showtime_at ? (it.showtime_at.split(' ')[0]) : '-');
      const normal = it.detail?.normal_price;
      const disc   = it.detail?.discount_total;
      const paid   = it.detail?.paid_total ?? it.amount;
      const pts    = it.detail?.point_reward;

      t2.push([
        i+1,
        it.created_at || '-',
        showDate || '-',
        it.movie_start_time || '-',
        it.movie_end_time   || '-',
        it.title || '-',
        it.type  || '-',
        it.theater || '-',
        it.screen  || '-',
        it.tickets ?? '-',
        normal==null ? '-' : fmtID(normal),
        disc==null   ? '-' : fmtID(disc),
        paid==null   ? '-' : fmtID(paid),
        pts==null    ? '-' : fmtID(pts),
        it.status ? statusColor(it.status) : '-',
        it.order_no || it.id || '-'
      ]);
    });

    console.log(t2.toString());
  }

  // ===== APPLY PATCHES KE account.json (AKHIR SAJA) =====
  try {
    if (Object.keys(pendingUpdates).length) {
      // baca ulang account.json supaya minimize race
      const raw = await fs.readFile('account.json','utf-8');
      const j = JSON.parse(raw);
      if (Array.isArray(j.items)) {
        for (let i = 0; i < j.items.length; i++) {
          const it = j.items[i];
          if (!it || !it.email) continue;
          const upd = pendingUpdates[it.email];
          if (!upd) continue;

          // hanya set field yang ada di pending (jangan utak-atik yang lain)
          if (upd.bearer) {
            it.bearer = upd.bearer;
            it.bearer_wrapped = upd.bearer_wrapped || wrapBearer3(upd.bearer);
            it.bearer_updated_at = upd.bearer_updated_at || new Date().toISOString();
          }
          if (upd.password) {
            it.password = upd.password;
            it.password_updated_at = upd.password_updated_at || new Date().toISOString();
          }
          // penting: JANGAN menyentuh generated_at / no / field lain
          j.items[i] = it;
        }
        // tulis kembali â€” TANPA mengubah generated_at
        await fs.writeFile('account.json', JSON.stringify(j, null, 2), 'utf-8');
      }
    }
  } catch (e) {
    console.log(chalk.red(`â†’ Gagal update account.json (batch): ${e.message}`));
  }

  // ===== summary =====
  const dt = ((Date.now() - tStart) / 1000).toFixed(1);
  const avg = (total ? (dt / total).toFixed(2) : '0.00');
  console.log(chalk.cyan('\n' + 'â•'.repeat(70)));
  console.log(
    chalk.cyan('[INFO]'),
    chalk.white(`Accounts processed: ${total}`),
    chalk.cyan('|'),
    chalk.white(`Sessions: ${Math.ceil(total/CONCURRENCY)} (batch size ${CONCURRENCY})`),
    chalk.cyan('|'),
    chalk.white(`Time: ${dt}s (avg ${avg}s/account)`)
  );

  try {
    await inquirer.prompt([{ type:'input', name:'pause', message:'Tekan ENTER untuk kembaliâ€¦' }]);
  } catch {}
}








// ===== CHANGE PASSWORD (account.json only, pilih via range) =====
async function changePasswords() {
  console.clear();
  const chalk = (globalThis.chalk && globalThis.chalk.green) ? globalThis.chalk : (await import('chalk')).default;
  const fs = (globalThis.fs && globalThis.fs.readFile) ? globalThis.fs : (await import('fs/promises')).default ?? (await import('fs/promises'));
  const inquirer = (globalThis.inquirer && globalThis.inquirer.prompt) ? globalThis.inquirer : (await import('inquirer')).default;

  console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.cyan('â•‘                        CHANGE PASSWORD                       â•‘'));
  console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));

  const delay = (ms)=>new Promise(r=>setTimeout(r,ms));
  const padN = (n,w) => String(n).padStart(w,'0');
  const norm = (s)=>String(s||'').trim().toLowerCase();

  // ===== Helper wrap bearer â†’ 3 potong untuk tampilan rapi di account.json
  const wrapBearer3 = (token) => {
    const s = String(token || '');
    if (!s) return [];
    const partLen = Math.ceil(s.length / 3);
    return [ s.slice(0, partLen), s.slice(partLen, partLen*2), s.slice(partLen*2) ];
  };

  // ===== Random headers per akun (lebih natural)
  const randChoice = (arr) => arr[Math.floor(Math.random()*arr.length)];
  const randomOkHttpUA = () => {
    const vers = randChoice(['4.9.3','4.10.0','4.11.0','4.12.0']);
    return `okhttp/${vers}`;
  };
  const randomLang = () => randChoice([
    'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
    'id,en-US;q=0.9,en;q=0.8',
    'en-US,en;q=0.9,id;q=0.8',
    'id-ID,en;q=0.9'
  ]);
  const makeAccountHeaders = () => ({
    'accept': 'application/json, text/plain, */*',
    'accept-encoding': 'gzip',
    'accept-language': randomLang(),
    'user-agent': randomOkHttpUA(),
    'connection': 'Keep-Alive'
  });
  const mergeHeaders = (base, extra) => {
    const out = { ...(base || {}) };
    for (const k of Object.keys(extra || {})) out[k.toLowerCase()] = extra[k];
    return out;
  };

  // ===== Timeout fetch (pakai proxy agent kalau tersedia)
  const fetchWithTimeout = async (url, opts = {}, timeoutMs = 15000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const base = { ...opts, signal: ctrl.signal };
      // selipkan proxy agent jika ada di scope
      if (!base.agent) {
        try {
          if (typeof getRandomProxy === 'function') base.agent = getRandomProxy();
        } catch {}
      }
      return await fetch(url, base);
    } finally {
      clearTimeout(t);
    }
  };

  // ===== Login ulang pakai password baru (ambil bearer fresh)
  const fetchNewTokenAfterChange = async (email, newPwd, extraHeaders) => {
    const MAX_TRY = 5;
    let last = null, backoff = 1000;
    for (let i=1;i<=MAX_TRY;i++) {
      try {
        let res;
        try { res = await getLoginAccount(email, newPwd, undefined, makeAccountHeaders()['user-agent'], makeAccountHeaders()['accept-language']); }
        catch { res = await getLoginAccount(email, newPwd); }
        last = res;
        if (res?.status_code === 200 && res?.token) return { ok:true, token: res.token };
      } catch(e) {
        last = { message: e.message };
      }
      await delay(backoff);
      backoff = Math.min(6000, Math.floor(backoff * 1.6));
    }
    return { ok:false, reason: last?.message || 'Cannot obtain new bearer' };
  };

  // ===== CHANGE-PASSWORD endpoint (configurable via ENV)
  async function postChangePassword(token, old_password, new_password, accHeaders) {
    // dukung penyesuaian via ENV
    const url  = process.env.CHANGE_PASSWORD_URL || 'https://v2-api.cgv.id/api/change-password';
    const F_OLD = (process.env.CP_FIELD_OLD || 'old_password').trim();
    const F_NEW = (process.env.CP_FIELD_NEW || 'new_password').trim();
    const F_CNF = (process.env.CP_FIELD_CONFIRM || '').trim(); // kosong = tidak kirim confirm

    const fd = new FormData();
    fd.set(F_OLD, old_password);
    fd.set(F_NEW, new_password);
    if (F_CNF) fd.set(F_CNF, new_password);

    const baseHeaders = {
      'accept': 'application/json, text/plain, */*',
      'authorization': `Bearer ${token}`,
      'accept-encoding': 'gzip',
      'user-agent': (accHeaders && accHeaders['user-agent']) || 'okhttp/4.10.0',
      'connection': 'Keep-Alive',
      ...(accHeaders?.['accept-language'] ? { 'accept-language': accHeaders['accept-language'] } : {})
    };
    const headers = mergeHeaders(baseHeaders, accHeaders || {});

    const doOnce = async () => {
      const res = await fetchWithTimeout(url, { method:'POST', headers, body: fd }, 15000);
      let json = null, text = '';
      try { text = await res.text(); } catch {}
      try { json = text ? JSON.parse(text) : null; } catch {}
      return {
        httpOk: res.ok,
        status: json?.status,
        status_code: json?.status_code ?? res.status,
        message: json?.message || (res.ok ? 'OK' : `HTTP ${res.status}`),
        raw: text?.slice(0, 200)
      };
    };

    const MAX_RETRY = 6;
    let backoff = 1500;
    for (let i=1;i<=MAX_RETRY;i++) {
      const r = await doOnce().catch(e => ({ httpOk:false, status:false, status_code:0, message: e.message }));
      if (r.status === true && r.httpOk) return { ok:true, ...r }; // sukses
      if (/incorrect/i.test(String(r.message||''))) return { ok:false, ...r }; // wrong old pass â†’ jangan retry
      if (/unauth|invalid token|expired/.test(String(r.message||'')) || r.status_code === 401) {
        return { ok:false, ...r }; // token invalid â†’ caller login ulang
      }
      if (/rate|timeout|network|fetch|5\d\d|too many/i.test(String(r.message||'')) || r.httpOk === false) {
        if (i < MAX_RETRY) { await delay(backoff); backoff = Math.min(8000, backoff*1.6); continue; }
      }
      return { ok:false, ...r };
    }
    return { ok:false, message:'Unknown error' };
  }

  // ===== Error classifier login
  const reasonFromLoginError = (res) => {
    const sc = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    if (/invalid credential|invalid password|wrong password/.test(msg) || sc === 401) return 'Wrong password';
    if (sc === 429 || /too many|rate limit/.test(msg))      return 'Rate limited (429)';
    if (sc === 404 || /member not found|not found/.test(msg)) return 'Account not found';
    if (/timeout|network|fetch fail|networkerror|timed out/.test(msg)) return 'Network/Timeout';
    if (/non-json response/.test(msg))                      return 'Anti-bot/gateway (non-JSON)';
    if (sc >= 500)                                          return `Server error (${sc})`;
    if (sc && sc !== 200)                                   return `HTTP ${sc}`;
    return 'Unknown login error';
  };
  const isRetryable = (res) => {
    const sc = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    if (/invalid credential|invalid password|wrong password/.test(msg) || sc === 401) return false;
    return (
      sc === 429 ||
      (sc >= 500) ||
      /timeout|network|fetch fail|networkerror|timed out/.test(msg) ||
      /non-json response/.test(msg)
    );
  };

  // ===== MUAT akun dari account.json (email + password)
  let accountJson = { items: [] };
  try {
    const raw = await fs.readFile('account.json','utf-8');
    const j = JSON.parse(raw);
    if (j && Array.isArray(j.items)) accountJson = j;
  } catch {}

  // ===== AUTO-SKIP not_found (gabung notfound.json kalau ada)
  const NOTFOUND_FILE = 'notfound.json';
  const notFoundSet = new Set();
  try {
    const nfRaw = await fs.readFile(NOTFOUND_FILE, 'utf-8');
    const nf = JSON.parse(nfRaw);
    if (Array.isArray(nf)) {
      nf.forEach(r => {
        if (r && r.email) notFoundSet.add(String(r.email).trim().toLowerCase());
      });
    }
  } catch {/* ignore */}

  const isNotFoundFlag = (it) => {
    const st = String(it?.status || it?.account_status || '').toLowerCase();
    return it?.not_found === true || st === 'not_found' || notFoundSet.has(norm(it?.email));
  };

  // kumpulkan akun valid
  let akunList = (accountJson.items || [])
    .filter(it => it && it.email && it.password && !isNotFoundFlag(it))
    .map(it => ({ email: it.email, password: it.password, phone: it.phone, pin: it.pin }));

  const skippedNotFound = (accountJson.items || []).filter(it => it && it.email && isNotFoundFlag(it)).length;

  if (!akunList.length) {
    console.log(chalk.red('âŒ  Tidak ada akun valid di account.json (butuh email + password).'));
    if (skippedNotFound) console.log(chalk.gray(`(Semua tersaring: ${skippedNotFound} akun ditandai not_found)`));
    await delay(1200);
    return;
  }

  // ===== Baca bearer/password map
  const bearerMap = new Map();
  const passMap   = new Map();
  for (const it of (accountJson.items || [])) {
    if (it?.email && it?.bearer)   bearerMap.set(norm(it.email), String(it.bearer));
    if (it?.email && it?.password) passMap.set(norm(it.email), String(it.password));
  }

  // ===== Kandidat default dari ENV (fallback login)
  function readDefaultPasswordsFromEnv() {
    let raw = '';
    try { raw = process?.env?.DEFAULT_PASSWORDS || ''; } catch {}
    return String(raw || '')
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);
  }
  const envPwds = (() => {
    const env = readDefaultPasswordsFromEnv();
    return env.length ? env : ['Cgv123456','Iqra0704','Cegeve123456','Cgv123456789'];
  })();

  // ===== tampilkan tabel akun
  {
    const TableCtor = await universalTable();
    const t = new TableCtor({ head:['No','Email'], colWidths:[6,58], wordWrap:true, style:{head:['yellow']} });
    akunList.forEach((a,i)=>t.push([padN(i+1,2), a.email]));
    console.log(t.toString());
    const infoParts = [`Total accounts: ${akunList.length}`];
    if (skippedNotFound) infoParts.push(`skipped not_found: ${skippedNotFound}`);
    console.log(chalk.gray(infoParts.join(' | ') + '\n'));
  }

  // ===== parser range "1-5,8,12-14"
  const parsePickRange = (input, total) => {
    const res = new Set();
    const s = String(input || '').trim();
    if (!s) { for (let i=1;i<=total;i++) res.add(i); return [...res].sort((a,b)=>a-b).map(n=>n-1); }
    const parts = s.split(',').map(p=>p.trim()).filter(Boolean);
    for (const p of parts) {
      if (/^\d+$/.test(p)) {
        const n = Number(p); if (n>=1 && n<=total) res.add(n); continue;
      }
      const m = p.match(/^(\d+)\s*-\s*(\d+)$/);
      if (m) {
        let a = Number(m[1]), b = Number(m[2]); if (a>b) [a,b]=[b,a];
        for (let n=a;n<=b;n++) if (n>=1 && n<=total) res.add(n);
      }
    }
    return [...res].sort((a,b)=>a-b).map(n=>n-1);
  };

  const { pickstr } = await inquirer.prompt([{
    type: 'input',
    name: 'pickstr',
    message: 'Masukkan nomor akun (contoh: 1-5,8,12-14) atau kosong=ALL:',
    filter: s => String(s || '').trim()
  }]);

  let idxs = parsePickRange(pickstr, akunList.length);
  if (!idxs.length) {
    console.log(chalk.red('Tidak ada nomor yang valid.'));
    await delay(1200);
    return;
  }
  const selected = idxs.map(i => akunList[i]);

  // ------------------------------------------------------------------
  // ========== PASSWORD GENERATOR: human-ish & kuat ==========
  const WORDS_L = ['Solar','Crimson','Silver','Pixel','Turbo','Velvet','Neon','Quantum','Arctic','Zenith','Aero','Echo','Falcon','Nimbus','Nova','Orion','Titan','Vortex','Zephyr','Cosmic','Bambu','Sunda','Atlas','Kopi','Batik','Bulan','Samudra','Senja','Pelangi'];
  const WORDS_R = ['Mango','Drift','Tiger','Comet','Glacier','Harbor','Jelly','Lynx','Mocha','Noodle','Omega','Panda','Quill','Raven','Sushi','Tango','Umbra','Viper','Waffle','Kuda','Kenari','Merapi','Sagu','Roti','Angkasa','Payon','Kelapa','Berlian','Purnama'];
  const SYMS = ['!','@','#','$','%','&','*','?'];
  const randInt = (a,b)=>a+Math.floor(Math.random()*(b-a+1));
  const pick    = (a)=>a[Math.floor(Math.random()*a.length)];
  const shuffle = (s)=>s.split('').sort(()=>Math.random()-0.5).join('');

  const maybeLeet = (w) => {
    // ubah minor supaya natural (50% peluang)
    if (Math.random() < 0.5) return w;
    return w.replace(/a/gi, m => (Math.random()<0.4?'@':m))
            .replace(/i/gi, m => (Math.random()<0.3?'1':m))
            .replace(/o/gi, m => (Math.random()<0.3?'0':m));
  };

  function ensurePolicy(pwd) {
    const needUpper = !/[A-Z]/.test(pwd);
    const needLower = !/[a-z]/.test(pwd);
    const needDigit = !/\d/.test(pwd);
    const needSym   = !/[!@#$%&*?]/.test(pwd);
    let s = pwd;
    if (needUpper) s += String.fromCharCode(65 + Math.floor(Math.random()*26));
    if (needLower) s += String.fromCharCode(97 + Math.floor(Math.random()*26));
    if (needDigit) s += String(randInt(0,9));
    if (needSym)   s += pick(SYMS);
    // panjang 10â€“18
    if (s.length < 10) s += pick(SYMS) + String(randInt(10,99));
    if (s.length > 18) s = s.slice(0, 18);
    return shuffle(s);
  }

  function generateHumanishPassword() {
    const w1 = maybeLeet(pick(WORDS_L));
    const w2 = maybeLeet(pick(WORDS_R));
    const suffixNum = Math.random() < 0.6 ? String(randInt(10,99)) : String(randInt(100,999));
    const sep = Math.random() < 0.5 ? '-' : (Math.random()<0.5 ? '.' : '');
    const sym = pick(SYMS);
    let candidate = `${w1}${sep}${w2}${suffixNum}${sym}`;
    // 20% peluang tambah â€œmini tailâ€ agar variatif
    if (Math.random() < 0.2) candidate += String(randInt(1,9));
    return ensurePolicy(candidate);
  }

  // prompt mode password
  const { modePwd } = await inquirer.prompt([{
    type:'list',
    name:'modePwd',
    message:'Mode password:',
    choices: [
      { name:'Per-account unique (recommended)', value:'per' },
      { name:'Satu password untuk semua akun',  value:'one' }
    ]
  }]);

  let targetNewPwdFor; // function(email, oldFilePwd) -> newPwd

  if (modePwd === 'one') {
    const { ans } = await inquirer.prompt([{
      type:'input',
      name:'ans',
      message:'New password (Enter = auto-random catchy; ketik "n" untuk batal):',
      filter: s => String(s||'').trim()
    }]);
    if (!ans) {
      const auto = generateHumanishPassword();
      console.log(chalk.gray(`â†’ pakai auto-random: ${chalk.yellow(auto)}`));
      targetNewPwdFor = () => auto;
    } else if (ans.toLowerCase() === 'n') {
      console.log(chalk.yellow('dibatalkan.'));
      return;
    } else {
      let typed = ensurePolicy(ans);
      if (typed !== ans) {
        console.log(chalk.gray('â†’ menyesuaikan agar memenuhi policy (upper/lower/digit/symbol)â€¦'));
      }
      console.log(chalk.gray(`â†’ pakai: ${chalk.yellow(typed)}`));
      targetNewPwdFor = () => typed;
    }
  } else {
    // per-account: tiap akun auto-random berbeda
    targetNewPwdFor = () => generateHumanishPassword();
    console.log(chalk.gray('â†’ Per-account unique password akan dihasilkan otomatis.'));
  }
  // ------------------------------------------------------------------

  // ===== Tabel hasil
  const Table = await universalTable();
  const resultTable = new Table({
    head:['No','Email','Result','Message'],
    wordWrap:true,
    style:{ head:['green'] }
  });

  // ===== Patch queue (diterapkan sekali di AKHIR)
  const pendingUpdates = Object.create(null);
  const queuePasswordUpdate = (email, pwd) => {
    if (!email || !pwd) return;
    if (!pendingUpdates[email]) pendingUpdates[email] = {};
    pendingUpdates[email].password = pwd;
    pendingUpdates[email].password_updated_at = new Date().toISOString();
  };
  const queueBearerUpdate = (email, token) => {
    if (!email || !token) return;
    if (!pendingUpdates[email]) pendingUpdates[email] = {};
    pendingUpdates[email].bearer = token;
    pendingUpdates[email].bearer_wrapped = wrapBearer3(token);
    pendingUpdates[email].bearer_updated_at = new Date().toISOString();
  };

  // ===== Concurrency
  const CONCURRENCY = 5;
  const resultRows = new Array(selected.length);

  // ===== Login helper (fallback)
  const safeLoginForChange = async (email, filePwd, accHeaders) => {
    const fromJsonPwd = filePwd ? String(filePwd).trim() : '';
    const candidates = [];
    if (fromJsonPwd) candidates.push(fromJsonPwd);
    for (const fb of envPwds) if (!candidates.includes(fb)) candidates.push(fb);
    const uniqueCandidates = [...new Set(candidates.map(p => String(p).trim()).filter(Boolean))];

    const MAX_RETRY_PER_PWD = 12;
    const MAX_TOTAL_SECONDS = 180;
    const startTime = Date.now();

    let last = null;
    for (const pwd of uniqueCandidates) {
      let attempt = 0;
      let backoff = 2000;
      while (true) {
        if ((Date.now() - startTime)/1000 > MAX_TOTAL_SECONDS) break;
        attempt++;
        try {
          let res;
          try { res = await getLoginAccount(email, pwd); }
          catch { res = await getLoginAccount(email, pwd); }
          last = res;
          if (res?.status_code === 200 && res?.token) {
            return { ok:true, token:res.token, usedPwd:pwd };
          }
          const retriable = isRetryable(res);
          const msg = res?.message || res?.status_code;
          if (!retriable) {
            console.log(chalk.red(`[âœ—] Login gagal (${email}) attempt ${attempt} dengan password "${pwd}": ${msg}`));
            break;
          }
          console.log(chalk.yellow(`[â†»] Retry (${email}) attempt ${attempt} dengan password "${pwd}" karena: ${msg}`));
          if (attempt >= MAX_RETRY_PER_PWD) break;
          await delay(backoff);
          backoff = Math.min(backoff*1.5, 10000);
        } catch(e) {
          console.log(chalk.yellow(`[â†»] Retry (${email}) attempt ${attempt} dengan password "${pwd}" exception: ${e.message}`));
          if (attempt >= MAX_RETRY_PER_PWD) break;
          await delay(backoff);
          backoff = Math.min(backoff*1.5, 10000);
        }
      }
    }
    return { ok:false, reason: reasonFromLoginError(last), last };
  };

  // ===== Proses 1 akun (bisa paralel)
  const processOne = async (idxGlobal, acct) => {
    const { email } = acct;
    const filePwd = acct.password || '';
    const accHeaders = makeAccountHeaders(); // random headers per akun

    const newPwdTarget = targetNewPwdFor(email, filePwd);
    const sameAsOld = newPwdTarget === filePwd;

    process.stdout.write(chalk.gray(`Change password â†’ ${email} â€¦ `));

    // 1) COBA PAKAI BEARER DULU (tanpa login)
    const bearer = bearerMap.get(norm(email));
    let done = false;
    let successMsg = '';

    // kandidat old_password saat pakai bearer: filePwd â†’ ENV
    const bearerCandidates = [];
    if (filePwd) bearerCandidates.push(filePwd);
    for (const fb of envPwds) if (!bearerCandidates.includes(fb)) bearerCandidates.push(fb);

    if (bearer) {
      for (const oldPwd of bearerCandidates) {
        const tryCp = await postChangePassword(bearer, oldPwd, newPwdTarget, accHeaders);
        if (tryCp.ok) {
          successMsg = `[Bearer] ${tryCp.message || 'Password changed'}${sameAsOld ? ' (same-as-old in file)' : ''}`;
          console.log(chalk.green('OK'), chalk.gray(`â€” ${successMsg}`));
          resultRows[idxGlobal] = [idxGlobal+1, email, chalk.green('OK'), successMsg];

          if (newPwdTarget && newPwdTarget !== filePwd) queuePasswordUpdate(email, newPwdTarget);

          const relog = await fetchNewTokenAfterChange(email, newPwdTarget, accHeaders);
          if (relog.ok) {
            queueBearerUpdate(email, relog.token);
            console.log(chalk.gray('   â†³ bearer akan diperbarui di account.json (batch akhir)'));
          } else {
            console.log(chalk.yellow('   â†³ Gagal ambil bearer baru (password baru tetap akan disimpan di account.json)'));
          }

          done = true;
          break;
        }
        const msg = String(tryCp.message || '').toLowerCase();
        const tokenBad = /unauth|invalid token|expired/.test(msg) || tryCp.status_code === 401 || tryCp.httpOk === false;
        if (tokenBad) break;
        if (/incorrect/.test(msg)) continue;
      }
    }

    if (done) return;

    // 2) FALLBACK: login untuk dapat token & valid old password
    const login = await safeLoginForChange(email, filePwd, accHeaders);
    if (!login.ok) {
      console.log(chalk.red('LOGIN FAIL'), chalk.gray('â€”'), chalk.yellow(login.reason || 'Cannot login'));
      resultRows[idxGlobal] = [idxGlobal+1, email, chalk.red('FAIL'), `Login: ${login.reason || 'Cannot login'}`];
      return;
    }

    // 3) change-password pakai token hasil login (old = usedPwd)
    const cp = await postChangePassword(login.token, login.usedPwd, newPwdTarget, accHeaders);
    if (cp.ok) {
      const msg = `[Login] ${cp.message || 'Password changed'}${sameAsOld ? ' (same-as-old in file)' : ''}`;
      console.log(chalk.green('OK'), chalk.gray(`â€” ${msg}`));
      resultRows[idxGlobal] = [idxGlobal+1, email, chalk.green('OK'), msg];

      if (newPwdTarget && newPwdTarget !== filePwd) queuePasswordUpdate(email, newPwdTarget);

      const relog = await fetchNewTokenAfterChange(email, newPwdTarget, accHeaders);
      if (relog.ok) {
        queueBearerUpdate(email, relog.token);
        console.log(chalk.gray('   â†³ bearer akan diperbarui di account.json (batch akhir)'));
      } else {
        console.log(chalk.yellow('   â†³ Gagal ambil bearer baru (password baru tetap akan disimpan di account.json)'));
      }
    } else {
      console.log(chalk.red('FAIL'), chalk.gray(`â€” ${cp.message || 'Unknown error'}`));
      resultRows[idxGlobal] = [idxGlobal+1, email, chalk.red('FAIL'), cp.message || 'Unknown error'];
    }
  };

  // ===== Jalankan paralel per sesi 5 akun
  const totalSessions = Math.ceil(selected.length / CONCURRENCY);
  const t0 = Date.now();
  let ok = 0, fail = 0;

  for (let start = 0, batchNo = 1; start < selected.length; start += CONCURRENCY, batchNo++) {
    const batch = selected.slice(start, start + CONCURRENCY);
    const i1 = start + 1;
    const i2 = Math.min(start + CONCURRENCY, selected.length);
    console.log(chalk.gray(`\n[Session ${batchNo}/${totalSessions}] Processing accounts ${i1}-${i2} (batch size ${CONCURRENCY})`));

    await Promise.allSettled(batch.map((acc, i) => processOne(start + i, acc)));

    for (let i = start; i < Math.min(start + CONCURRENCY, selected.length); i++) {
      const row = resultRows[i];
      if (!row) continue;
      if (String(row[2]).includes('OK')) ok++; else fail++;
    }
  }

  // ===== Tampilkan tabel hasil
  for (let i = 0; i < resultRows.length; i++) {
    if (resultRows[i]) resultTable.push(resultRows[i]);
  }
  console.log('\n' + resultTable.toString());

  // ===== APPLY PATCHES ke account.json (akhir saja)
  try {
    if (Object.keys(pendingUpdates).length) {
      const raw = await fs.readFile('account.json','utf-8');
      const j = JSON.parse(raw || '{}');
      if (Array.isArray(j.items)) {
        for (let i = 0; i < j.items.length; i++) {
          const it = j.items[i];
          if (!it || !it.email) continue;
          const upd = pendingUpdates[it.email];
          if (!upd) continue;

          if (upd.password) {
            it.password = upd.password;
            it.password_updated_at = upd.password_updated_at || new Date().toISOString();
          }
          if (upd.bearer) {
            it.bearer = upd.bearer;
            it.bearer_wrapped = upd.bearer_wrapped || wrapBearer3(upd.bearer);
            it.bearer_updated_at = upd.bearer_updated_at || new Date().toISOString();
          }
          j.items[i] = it;
        }
        await fs.writeFile('account.json', JSON.stringify(j, null, 2), 'utf-8');
      }
    }
  } catch (e) {
    console.log(chalk.red(`â†’ Gagal update account.json (batch): ${e.message}`));
  }

  // ===== Summary
  const dt = ((Date.now() - t0)/1000).toFixed(1);
  console.log(chalk.cyan('\n' + 'â•'.repeat(70)));
  console.log(
    chalk.cyan('[INFO]'),
    chalk.green(`Changed: ${ok}`),
    chalk.cyan('|'),
    chalk.red(`Failed: ${fail}`),
    chalk.cyan('|'),
    chalk.white(`Total: ${selected.length}`),
    chalk.cyan('|'),
    chalk.white(`Time: ${dt}s (avg ${(selected.length? (dt/selected.length).toFixed(2):'0.00')}s/account)`)
  );

  // ===== Pause sebelum kembali ke menu
  try {
    let rlMod;
    try { rlMod = require('readline'); }
    catch {
      const mod = await import('node:readline');
      rlMod = mod.default || mod;
    }
    const rl = rlMod.createInterface({ input: process.stdin, output: process.stdout });
    await new Promise(resolve => rl.question(chalk.yellow('\nTekan ENTER untuk kembali ke menuâ€¦ '), () => { rl.close(); resolve(); }));
  } catch {
    console.log(chalk.yellow('\n(Lewati PAUSE: readline tidak tersedia)'));
  }
  for (let i = 5; i >= 1; i--) {
    process.stdout.write(chalk.gray(`Kembali ke menu dalam ${i}s   \r`));
    await delay(1000);
  }
  process.stdout.write(' '.repeat(40) + '\r');

  return;
}











// ================================================================
// AUTO REFRESH TOKEN â€” cek semua bearer, konfirmasi, refresh massal
// (progress rapi per akun, ringkasan profesional, & Pause to menu)
// ================================================================
async function autoRefreshTokens(options = {}) {
  const {
    skewSec = 60,                   // toleransi clock drift utk exp JWT
    verifyServer = true,            // verifikasi ke server utk token yg local OK/EXPIRED
    perLoginBackoffStart = 1500,    // backoff login awal
    maxRetryPerPwd = 10,            // retry per password
    maxTotalLoginSec = 150,         // batas total 1 akun
    concurrencyVerify = 8,          // verifikasi server concurrent (headers acak per akun)
    concurrencyRefresh = 8          // login refresh concurrent (headers acak per akun)
  } = options;

  // â”€â”€ util teks
  const normEmail = s => String(s||'').trim().toLowerCase();
  const clamp = (s, w) => {
    const str = String(s || '');
    if (str.length <= w) return str;
    return str.slice(0, Math.max(0, w - 3)) + '...';
  };
  const padR = (s, w) => {
    const str = String(s || '');
    return str.length >= w ? str : (str + ' '.repeat(w - str.length));
  };
  const col = {
    ok:    (t)=>chalk.green(t),
    warn:  (t)=>chalk.yellow(t),
    err:   (t)=>chalk.red(t),
    info:  (t)=>chalk.cyan(t),
    dim:   (t)=>chalk.gray(t),
    mag:   (t)=>chalk.magenta(t),
    white: (t)=>chalk.white(t),
  };

  // â”€â”€ Header RANDOM per akun (aman) â€” mirip listAccounts
  const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const randomOkHttpUA = () => {
    const vers = choice(['4.9.3','4.10.0','4.11.0','4.12.0']);
    return `okhttp/${vers}`;
  };
  const randomLang = () => choice([
    'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
    'id,en-US;q=0.9,en;q=0.8',
    'en-US,en;q=0.9,id;q=0.8',
    'id-ID,en;q=0.9'
  ]);
  const makeAccountHeaders = () => ({
    'accept': 'application/json, text/plain, */*',
    'accept-encoding': 'gzip',
    'accept-language': randomLang(),
    'user-agent': randomOkHttpUA(),
    'connection': 'Keep-Alive'
  });
  const mergeHeaders = (base, extra) => {
    const out = { ...(base || {}) };
    for (const k of Object.keys(extra || {})) out[k.toLowerCase()] = extra[k];
    return out;
  };

  // â”€â”€ bungkus bearer 3 bagian (readability di JSON)
  const wrapBearer3 = (token) => {
    const s = String(token || '');
    if (!s) return [];
    const partLen = Math.ceil(s.length / 3);
    return [ s.slice(0, partLen), s.slice(partLen, partLen*2), s.slice(partLen*2) ];
  };

  // â”€â”€ JWT local expiry check (hemat 1 ping)
  const isJwtExpiredLocal = (token) => {
    try {
      const parts = String(token || '').split('.');
      if (parts.length < 2) return false; // bukan JWT â†’ jangan asumsikan expired
      const b64 = parts[1].replace(/-/g, '+').replace(/_/g, '/');
      const pad = b64.length % 4 === 0 ? '' : '='.repeat(4 - (b64.length % 4));
      const json = Buffer.from(b64 + pad, 'base64').toString('utf8');
      const payload = JSON.parse(json);
      const exp = Number(payload?.exp);
      if (!Number.isFinite(exp)) return false;
      return (exp * 1000) <= (Date.now() + skewSec * 1000);
    } catch {
      return false;
    }
  };

  // ========== Anti-stuck helpers ==========
  const withTimeout = (promise, ms, label = 'Timeout') =>
    Promise.race([
      promise,
      new Promise((_, rej) => setTimeout(() => rej(new Error(label)), ms))
    ]);

  // â”€â”€ klasifikasi error login
  const isRetryable = (res) => {
    const sc  = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    if (/invalid credential|invalid password|wrong password/.test(msg) || sc === 401) return false;
    if (typeof looksWrongPassword === 'function' && looksWrongPassword(res)) return false;
    return sc === 429 || (sc >= 500) ||
           /timeout|network|fetch fail|networkerror|timed out/.test(msg) ||
           /non-json response/.test(msg);
  };
  const reasonFromLoginError = (res) => {
    const sc  = res?.status_code;
    const msg = String(res?.message || '').toLowerCase();
    if (typeof looksWrongPassword === 'function' && looksWrongPassword(res)) return 'Wrong password';
    if (/invalid credential|invalid password|wrong password/.test(msg) || sc === 401) return 'Wrong password';
    if (sc === 429 || /too many|rate limit/.test(msg))  return 'Rate limited (429)';
    if (sc === 404 || /member not found|not found/.test(msg)) return 'Account not found';
    if (/timeout|network|fetch fail|networkerror|timed out/.test(msg)) return 'Network/Timeout';
    if (/non-json response/.test(msg))                    return 'Anti-bot/gateway (non-JSON)';
    if (sc >= 500)                                        return `Server error (${sc})`;
    if (sc && sc !== 200)                                 return `HTTP ${sc}`;
    return 'Unknown login error';
  };

  // â”€â”€ SAFE WRAPPERS (dukung headers seperti di listAccounts)
  const getMemberInfoSafe = async (token, accHeaders) => {
    try {
      try {
        return await withTimeout(getMemberInfo(token, accHeaders), 20000, 'getMemberInfo timeout');
      } catch {
        return await withTimeout(getMemberInfo(token), 20000, 'getMemberInfo timeout');
      }
    } catch { return null; }
  };
  const getLoginAccountSafe = async (email, pwd, accHeaders) => {
    try {
      try {
        return await withTimeout(getLoginAccount(email, pwd, accHeaders), 20000, 'login timeout');
      } catch {
        return await withTimeout(getLoginAccount(email, pwd), 20000, 'login timeout');
      }
    } catch (e) {
      return { status_code: 0, message: e?.message || 'Login error' };
    }
  };

  // â”€â”€ ENV default passwords
  const parseEnvDefaultPasswords = () => {
    const raw = (process?.env?.DEFAULT_PASSWORDS || '').trim();
    if (!raw) return [];
    return raw.split(',').map(s => s.trim()).filter(Boolean);
  };

  // â”€â”€ LOGIN: login ulang utk token baru (tanpa ping info) â€” **dengan headers acak per akun & kandidat gabungan**
  async function issueNewBearer(email, candidates, accHeaders) {
    // kandidat FINAL: item.password (kalau ada) + ENV DEFAULT_PASSWORDS (tidak hardcode)
    const candidateList = [...new Set((candidates||[]).filter(Boolean).map(s=>String(s).trim()))];

    const startTime = Date.now();
    let last = null;

    for (const pwd of candidateList) {
      let attempt = 0;
      let backoff = perLoginBackoffStart;
      while (true) {
        if ((Date.now() - startTime)/1000 > maxTotalLoginSec) break;
        attempt++;
        try {
          const res = await getLoginAccountSafe(email, pwd, accHeaders);
          last = res;
          if (res?.status_code === 200 && res?.token) {
            return { ok:true, token: res.token, usedPwd: pwd };
          }
          if (!isRetryable(res) || attempt >= maxRetryPerPwd) break;
          await delay(backoff);
          backoff = Math.min(backoff * 1.5, 10_000);
        } catch {
          if (attempt >= maxRetryPerPwd) break;
          await delay(backoff);
          backoff = Math.min(backoff * 1.5, 10_000);
        }
      }
    }
    return { ok:false, reason: reasonFromLoginError(last) };
  }

  // â”€â”€ small pool executor
  async function runPool(idxs, limit, worker) {
    let cursor = 0, active = 0;
    return new Promise((resolve)=>{
      const next = () => {
        if (cursor >= idxs.length && active === 0) return resolve();
        while (active < limit && cursor < idxs.length) {
          const j = cursor++; active++;
          const i = idxs[j];
          worker(i).finally(()=>{ active--; next(); });
        }
      };
      next();
    });
  }

  // â”€â”€ helper prompt y/n & pause
  async function askYesNo(q) {
    const readline = await import('node:readline/promises');
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
    const ans = (await rl.question(q)).trim().toLowerCase();
    await rl.close();
    return ['y','ya','yes'].includes(ans);
  }
  async function pauseToMenu() {
    const readline = await import('node:readline/promises');
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
    await rl.question(col.dim('\nPress Enter to return to menuâ€¦ '));
    await rl.close();
  }

  // â”€â”€ Sumber data: HANYA dari account.json (tanpa akunLogin.txt)
  let accData = { generated_at: new Date().toISOString(), items: [] };
  try {
    const raw = await fs.readFile('account.json','utf-8');
    const j = JSON.parse(raw);
    if (j && Array.isArray(j.items)) accData = j;
  } catch {
    console.log(col.err('âŒ  account.json tidak ditemukan / rusak.'));
    await pauseToMenu();
    return;
  }
  const items = accData.items || [];
  if (!items.length) {
    console.log(col.err('âŒ  account.json kosong. Tidak ada yang dicek.'));
    await pauseToMenu();
    return;
  }

  // â”€â”€ muat daftar email "not found" dari notfound.json (kalau ada) â†’ untuk auto-skip
  const NOTFOUND_FILE = 'notfound.json';
  const notFoundSet = new Set();
  try {
    const nfRaw = await fs.readFile(NOTFOUND_FILE, 'utf-8');
    const nf = JSON.parse(nfRaw);
    if (Array.isArray(nf)) {
      nf.forEach(r => {
        if (r && r.email) notFoundSet.add(normEmail(r.email));
      });
    }
  } catch { /* silent if missing */ }

  // â”€â”€ fungsi penentu skip
  const shouldSkip = (it) => {
    const k = normEmail(it?.email || '');
    const flaggedInAccount =
      it?.not_found === true ||
      String(it?.account_status || '').toLowerCase() === 'not_found' ||
      String(it?.status || '').toLowerCase() === 'not_found';
    const flaggedInFile = notFoundSet.has(k);
    return flaggedInAccount || flaggedInFile;
  };

  // Header acak per akun (dipakai di phase verifikasi & refresh)
  const headerMap = new Map(); // email(lower) -> headers
  for (const it of items) {
    headerMap.set(normEmail(it.email || ''), makeAccountHeaders());
  }

  // Password candidates per akun: [item.password, ...ENV DEFAULT_PASSWORDS]
  const envPwds = parseEnvDefaultPasswords();
  const getPwdCandidates = (email) => {
    const it = items.find(x => normEmail(x.email) === normEmail(email));
    const fromItem = (it?.password || '').trim();
    const arr = [];
    if (fromItem) arr.push(fromItem);
    for (const p of envPwds) if (p && p !== fromItem) arr.push(p);
    return arr;
  };

  console.log(col.info('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(col.info('â•‘                     AUTO REFRESH TOKEN                       â•‘'));
  console.log(col.info('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
  console.log(col.dim(`Total akun       : ${items.length}`));
  console.log(col.dim(`Verify concur    : ${concurrencyVerify}  |  Refresh concur : ${concurrencyRefresh}`));
  console.log(col.dim(`Header per akun  : RANDOMIZED (okhttp/lang)\n`));

  // =============== PHASE 1 â€” CHECK TOKENS ======================
  const tCheckStart = Date.now();
  const EMAIL_W = 36;
  const resultByIdx = new Array(items.length);
  const toVerifyServer = [];
  const verifyKind = Object.create(null); // i -> 'fresh' | 'expired'

  // *** queue target refresh sejak dini (expired/missing langsung auto-refresh) ***
  const immediateTargets = [];

  let skippedCount = 0;

  console.log(col.info('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PHASE 1: CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));
  for (let i=0;i<items.length;i++) {
    const it = items[i];
    const email = it.email || '';
    const idxStr = `[${String(i+1).padStart(String(items.length).length,'0')}/${items.length}]`;
    const emailDisp = padR(clamp(email, EMAIL_W), EMAIL_W);

    // AUTO-SKIP: akun bertanda not_found (di file atau flag di item)
    if (shouldSkip(it)) {
      resultByIdx[i] = { status:'SKIPPED', email };
      skippedCount++;
      console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.dim('â”‚ SKIPPED')} ${col.dim('(not_found)')}`);
      continue;
    }

    const bearer = String(it.bearer || '');

    if (!bearer) {
      resultByIdx[i] = { status:'MISSING', email };
      immediateTargets.push(i); // auto refresh langsung
      console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.mag('â”‚ MISSING')} ${col.dim('â€” no bearer â†’ queued refresh')}`);
      continue;
    }

    const expiredLocal = isJwtExpiredLocal(bearer);

    if (expiredLocal) {
      // langsung refresh, tidak perlu verify server
      resultByIdx[i] = { status:'EXPIRED', email };
      immediateTargets.push(i);
      console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.warn('â”‚ EXPIRED (local)')} ${col.dim('â†’ queued refresh')}`);
      continue;
    }

    // tidak expired secara lokal â†’ opsional verify server
    if (verifyServer) {
      resultByIdx[i] = { status:'PENDING', email };
      verifyKind[i] = 'fresh';
      toVerifyServer.push(i);
      console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.dim('â”‚ local OK â†’ verify serverâ€¦')}`);
    } else {
      resultByIdx[i] = { status:'OK', email };
      console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.ok('â”‚ VALID')} ${col.dim('(local)')}`);
    }
  }

  await runPool(toVerifyServer, concurrencyVerify, async (i) => {
    const it = items[i];
    const email = it.email || '';
    const idxStr = `[${String(i+1).padStart(String(items.length).length,'0')}/${items.length}]`;
    const emailDisp = padR(clamp(email, EMAIL_W), EMAIL_W);
    const accHeaders = headerMap.get(normEmail(email)) || makeAccountHeaders();
    try {
      const info = await getMemberInfoSafe(String(it.bearer || ''), accHeaders);
      const msg = String(info?.message || '').toLowerCase();
      if (info?.RESULTS?.ds_mbrList) {
        resultByIdx[i] = { status:'OK', email, recovered: verifyKind[i] === 'expired' };
        const tail = verifyKind[i] === 'expired' ? col.dim('(server; local-exp)') : col.dim('(server)');
        console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.ok('â”‚ VALID')} ${tail}`);
      } else if (info?.status_code === 401 || /expired|invalid|unauthoriz/.test(msg)) {
        resultByIdx[i] = { status:'INVALID', email };
        immediateTargets.push(i); // invalid server â†’ auto refresh langsung
        console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.err('â”‚ INVALID')} ${col.dim('(server â†’ queued refresh)')}`);
      } else {
        resultByIdx[i] = { status:'UNKNOWN', email };
        console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.dim('â”‚ UNKNOWN')} ${col.dim(`(server ${info?.status_code ?? '???'})`)}`);
      }
    } catch {
      resultByIdx[i] = { status:'UNKNOWN', email };
      console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.dim('â”‚ UNKNOWN')} ${col.dim('(exception)')}`);
    }
  });
  const tCheckSecs = ((Date.now()-tCheckStart)/1000).toFixed(1);

  // rekap + â€œakun keberapaâ€
  const idxsBy = (status) => resultByIdx.map((r,idx)=>r?.status===status ? idx : -1).filter(x=>x>=0);
  const okIdxs        = idxsBy('OK');
  const invIdxs       = idxsBy('INVALID');
  const missIdxs      = idxsBy('MISSING');
  const unkIdxs       = idxsBy('UNKNOWN');
  const expIdxs       = idxsBy('EXPIRED');
  const skipIdxs      = idxsBy('SKIPPED');
  const recoveredIdxs = resultByIdx.map((r,idx)=>r?.status==='OK' && r.recovered ? idx : -1).filter(x=>x>=0);

  const toHuman = (arr) => arr.map(i=>i+1).join(', ') || '-';
  const listEmails = (arr, max=5) => {
    const names = arr.slice(0, max).map(i => items[i]?.email || '-');
    return names.join(', ') + (arr.length > max ? `, +${arr.length-max} lagi` : '');
  };

  console.log(col.info('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SUMMARY CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));
  console.log(`OK                : ${okIdxs.length}`, okIdxs.length ? col.dim(`(${listEmails(okIdxs)})`) : '');
  if (recoveredIdxs.length) {
    console.log(col.ok(`Recovered (server-valid, local-exp): ${recoveredIdxs.length}`),
      col.dim(`(akun ke ${toHuman(recoveredIdxs)})`));
  }
  console.log(col.warn(  `Expired (local)   : ${expIdxs.length}`), expIdxs.length ? col.dim(`(akun ke ${toHuman(expIdxs)})`) : '');
  console.log(col.err(   `Invalid (server)  : ${invIdxs.length}`), invIdxs.length ? col.dim(`(akun ke ${toHuman(invIdxs)})`) : '');
  console.log(col.mag(   `Missing bearer    : ${missIdxs.length}`), missIdxs.length ? col.dim(`(akun ke ${toHuman(missIdxs)})`) : '');
  if (unkIdxs.length) console.log(col.dim(`Unknown           : ${unkIdxs.length} (akun ke ${toHuman(unkIdxs)})`));
  if (skipIdxs.length) console.log(col.dim(`Skipped (not_found): ${skipIdxs.length} (akun ke ${toHuman(skipIdxs)})`));
  console.log(col.dim(`Check time        : ${tCheckSecs}s  |  Server verifies: ${toVerifyServer.length}\n`));
  console.log(col.info('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));

  // Target refresh otomatis:
  // - INVALID dari server
  // - MISSING bearer
  // - EXPIRED (local) (langsung, tanpa verify server)
  // (yang SKIPPED otomatis tidak dimasukkan)
  let finalTargets = [...new Set(immediateTargets)].filter(i => resultByIdx[i]?.status !== 'SKIPPED');
  let chosenRefreshConcurrency = concurrencyRefresh;

  if (!finalTargets.length) {
    console.log(col.ok('\nSemua token bearer VALID (atau hanya akun SKIPPED).'));
    const doRefreshAll = okIdxs.length ? await askYesNo(col.warn('Ingin refresh SEMUA token valid juga? (y/n) ')) : false;
    if (!doRefreshAll) { await pauseToMenu(); return; }
    // kalau refresh semua token valid â†’ concurrency 5 saja
    chosenRefreshConcurrency = 5;
    finalTargets = okIdxs;
  } else {
    console.log(col.info('\nAuto refresh akan dijalankan untuk token yang bermasalah (tanpa konfirmasi).'));
    console.log(
      `â†’ Target refresh: ${finalTargets.length} akun ` +
      `(Expired: ${expIdxs.length}, Invalid: ${invIdxs.length}, Missing: ${missIdxs.length}, Skipped: ${skipIdxs.length})`
    );
  }

  // =============== PHASE 2 â€” REFRESH ===========================
  console.log(col.info('\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PHASE 2: REFRESH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));
  console.log(col.dim(`Refresh concurrency in use : ${chosenRefreshConcurrency}`));
  const tRefreshStart = Date.now();
  let success = 0, fail = 0, done = 0;
  const failDetail = new Map(); // reason -> count

  await runPool(finalTargets, chosenRefreshConcurrency, async (i) => {
    const email = items[i]?.email || '-';
    const emailDisp = padR(clamp(email, EMAIL_W), EMAIL_W);
    const idxStr = `[${String(++done).padStart(String(finalTargets.length).length,'0')}/${finalTargets.length}]`;
    const accHeaders = headerMap.get(normEmail(email)) || makeAccountHeaders();

    // kandidat password: item.password â†’ ENV DEFAULT_PASSWORDS
    const pwdCandidates = getPwdCandidates(email);

    const t0 = Date.now();

    const { ok, token, reason, usedPwd } = await issueNewBearer(email, pwdCandidates, accHeaders);
    const took = ((Date.now()-t0)/1000).toFixed(1) + 's';
    if (!ok || !token) {
      fail++;
      const rsn = reason || 'Login gagal';
      failDetail.set(rsn, (failDetail.get(rsn)||0)+1);
      console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.err('âœ— Failed')} ${col.dim(`â€” ${rsn} (${took})`)}`);
      return;
    }

    // update hanya 3 kolom bearer (in-memory), dan password bila berubah
    const it = items[i];

    // bearer trio
    it.bearer = token;
    it.bearer_wrapped = wrapBearer3(token);
    it.bearer_updated_at = new Date().toISOString();

    // password jika sukses dengan pwd berbeda
    if (usedPwd && String(usedPwd) !== String(it.password || '')) {
      it.password = String(usedPwd);
      it.password_updated_at = new Date().toISOString();
    }

    success++;
    console.log(`${col.dim(idxStr)} ${col.white(emailDisp)} ${col.ok('âœ“ Updated')} ${col.dim(`(${took})`)}`);
  });

  // TULIS SEKALI DI AKHIR â€” NON-DESTRUCTIVE:
  // - Tidak mengubah generated_at
  // - Tidak menomori ulang / mengubah field "no"
  // - Hanya menyimpan perubahan pada field yang diubah di memory
  try {
    await fs.writeFile('account.json', JSON.stringify(accData, null, 2), 'utf-8');
    console.log(col.info('\naccount.json diperbarui (hanya bearer-trio & password bila berubah). `generated_at` & nomor `no` TETAP.'));
  } catch(e) {
    console.log(col.err(`Gagal menyimpan account.json: ${e.message}`));
  }
  const tRefreshSecs = ((Date.now()-tRefreshStart)/1000).toFixed(1);
  const rate = finalTargets.length ? (finalTargets.length / Number(tRefreshSecs)).toFixed(2) : '0.00';
  console.log(col.info('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));

  // =============== SUMMARY =====================================
  console.log(col.info('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SUMMARY â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
  console.log(col.dim (`Skipped (not_found): ${skippedCount}`));
  console.log(col.ok  (`Refreshed OK      : ${success}`));
  console.log(col.err (`Refreshed FAIL    : ${fail}`));
  if (fail) {
    console.log(col.info('\nFailure breakdown:'));
    [...failDetail.entries()].sort((a,b)=>b[1]-a[1]).forEach(([rsn,cnt])=>{
      console.log(' -', chalk.yellow(rsn), col.dim(`x${cnt}`));
    });
  }
  console.log(col.dim(`Check phase     : ${tCheckSecs}s  |  Refresh phase : ${tRefreshSecs}s  |  Thruput: ${rate} acc/s`));
  console.log(col.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));

  // Pause (biar ga auto-close) â†’ balik ke menu saat Enter
  await pauseToMenu();
}






// ================================================================
// AUTO REDEEM CODES (CGV)
// - Tampilkan tabel akun (visits, Popcorn 1st, Combo Solo, 3rd Visit, Flat10k) â€” kolom dipisah
// - Pisahkan tabel: (1) Punya voucher aktif, (2) Tidak punya
// - Pilih akun (range/list) â€” urutan sesuai input user (bukan sorted)
// - Default 1 akun : 1 kode (opsi kustom n kode/akun)
// - Redeem POST /api/membership/coupons/register (multipart)
// - Cek detail GET /api/membership/coupons/{code}
// - Pakai bearer, fallback login jika perlu
// - Perbaiki detail log sukses/invalid (alasan lengkap)
// - Fix: pauseToMenu undefined (fallback)
// - TABEL AUTO-FIT: lebar kolom dihitung dinamis (no hardcoded widths)
// - SKIP KODE VALID: baca/append valid_kode.txt (skip + bersihkan dari file kode)
// - LOG INVALID/ERROR: append ke invalid_kode.txt (email, kode, alasan, dll.)
// - (Baru) AUTO WATCH: jika stok habis, pantau file code.txt/codes.txt
//   dan lanjut otomatis ketika ada kode baru (tanpa konfirmasi). Otomatis buka file.
//   Logging detail: start watch, heartbeat, jumlah kode baru terdeteksi.
//   Saat stok habis di tengah proses â†’ fast watch 10ms.
// - (Baru) Cleanup file kode pakai snapshot TERBARU (bukan hanya snapshot awal).
// - (Baru) TABEL: tambah "Last Movie" + highlight hari-ini; sorting Visits desc.
// - (Baru) Kolom "Flat10k Has/Used" + aturan redeem: jika Has=YES â†’ blok, tawarkan override.
// - (Baru) Live fetch transaksi & voucher (fallback ke account.json jika perlu).
// - (Update) AUTO BATCH SIZE: mulai 10, fallback ke 5 jika rate limit tinggi
// - (Update) ANTI-STUCK: timeout, heartbeat, intelligent retry
// - (Update) TIER COLUMN: tambah kolom tier dari member info
// - (Update) FIX LOGIC: voucher detection & visits calculation sesuai referensi
// - (Update) 401 handler: auto re-login & retry 1x; jika tetap 401 â†’ kode TIDAK dihapus dari file.
//
// *** UPDATE: Live fetch DINONAKTIFKAN default (pakai data account.json agar cepat) ***
//
// *** NEW UPDATE (requested):
// - Jangan pakai akunLogin.txt lagi. Password ambil dari field `password` di account.json.
//   Jika login gagal, coba fallback password dari ENV: DEFAULT_PASSWORDS=Cgv123456,Iqra0704,Cegeve123456,Cgv123456789
// - Jika login sukses dengan password berbeda â†’ update field `password` + `password_updated_at`.
// - Jika bearer expired/invalid â†’ login ulang, lalu HANYA update 3 field: `bearer`, `bearer_wrapped`, `bearer_updated_at` (+ `login_ok`).
// - Semua update KE account.json dilakukan DI AKHIR proses (batch), tanpa regenerate struktur lainnya.
//
// *** NEW UPDATE (this commit):
// - Input target akun bisa: nomor urut tabel (range/list), EMAIL, dan NOMOR HP (field `phone` di account.json).
//   Contoh input: `1-3, 7, iqra1@gmail.com, iqra2@gmail.com, 085342445959,082296813933`
//   Urutan proses mengikuti urutan input user (tanpa sort).
// - Tabel akun menampilkan kolom "Phone" (nomor hp) selain Email.
//
// *** NEW UPDATE (JSON LOG + DEDUP):
// - Deduplicate akun berdasarkan phone/email/username â†’ 1 akun unik = 1 key (1 akun = 1 jatah mapping kode).
// - Tambah log_reedem.json (NDJSON) untuk semua attempt (sukses / invalid / error).
// - Tambah tsel_10k.json (NDJSON) khusus sukses Telkomsel 10K.
// - Sebelum proses, cek dari log HARI INI kalau akun sudah pernah redeem TSEL10K, prompt konfirmasi (boleh skip).
//
// ================================================================

import { devNull } from 'node:os';
import { getEnvironmentData } from 'node:worker_threads';

// ================================================================
async function autoRedeemCgvCodes(options = {}) {
  const {
    baseURL = 'https://v2-api.cgv.id',
    codeFile = 'code.txt',
    validCodeFile = 'valid_kode.txt',     // daftar kode yang sudah valid
    invalidCodeFile = 'invalid_kode.txt', // log invalid/error redeem
    logRedeemFile = 'log_reedem.json',    // NDJSON log semua percobaan redeem
    tsel10kLogFile = 'tsel_10k.json',     // NDJSON khusus sukses Telkomsel 10K
    throttleMs = 900,           // jeda antar request (rate limit friendly)
    maxRetry429 = 3,            // retry untuk 429
    verifyBearerBefore = true,  // ping getMemberInfo utk validasi bearer
    watchPollMs = 1000,         // interval polling kode baru saat habis (default)
    maxProcessTimeoutMs = 30000, // timeout per akun untuk anti-stuck
    // ==== NEW: matikan/live fetch ====
    useLiveFetch = false        // default: false (hanya baca account.json biar cepat)
  } = options;

  // ====== ENV CONFIG: AUTO CODE MAPPING ======
  const AUTO_CODE_MAPPING = process.env.AUTO_CODE_MAPPING === 'true'; // true = skip prompt
  const AUTO_CODE_PER_ACCOUNT = parseInt(process.env.AUTO_CODE_PER_ACCOUNT || '1', 10); // default 1
  const AUTO_CONFIRM_REDEEM_CONTINUE = process.env.AUTO_CONFIRM_REDEEM_CONTINUE === 'true'; // true = skip confirm

  // ====== INTELLIGENT BATCH SIZE & RATE LIMIT DETECTION ======
  let currentBatchSize = 10; // mulai dengan 10
  let batchDelayMs = 800;     // delay antar batch
  let rateLimitCount = 0;     // counter rate limit dalam session ini
  const MAX_RATE_LIMITS_BEFORE_FALLBACK = 3;

  // ----------- fallback modules (tidak mengganggu yg sdh ada) -----------
  const chalk = (globalThis.chalk && globalThis.chalk.green) ? globalThis.chalk : (await import('chalk')).default;
  const fs = (globalThis.fs && globalThis.fs.readFile) ? globalThis.fs : (await import('fs/promises'));
  const inquirer = (globalThis.inquirer && globalThis.inquirer.prompt) ? globalThis.inquirer : (await import('inquirer')).default;

  if (typeof globalThis.delay !== 'function') {
    globalThis.delay = (ms)=> new Promise(r=>setTimeout(r, ms));
  }
  if (typeof globalThis.pauseToMenu !== 'function') {
    globalThis.pauseToMenu = async function () {
      try { await inquirer.prompt([{ type: 'input', name: '_', message: 'Tekan Enter untuk kembali...' }]); }
      catch {}
    };
  }

  const col = {
    ok:      (t)=>chalk.green(t),
    warn:    (t)=>chalk.yellow(t),
    err:     (t)=>chalk.red(t),
    info:    (t)=>chalk.cyan(t),
    cyan:    (t)=>chalk.cyan(t),
    dim:     (t)=>chalk.gray(t),
    gray:    (t)=>chalk.gray(t),
    mag:     (t)=>chalk.magenta(t),
    green:   (t)=>chalk.green(t),
    red:     (t)=>chalk.red(t),
    yellow:  (t)=>chalk.yellow(t),
    magenta: (t)=>chalk.magenta(t),
    white:   (t)=>chalk.white(t),
  };

  // ===== GLOBAL /quit WATCHER (untuk stop menunggu kode baru) =====
  let quitRequested = false;
  function initQuitListenerOnce() {
    if (initQuitListenerOnce._done) return;
    initQuitListenerOnce._done = true;
    try {
      const stdin = process.stdin;
      if (!stdin || !stdin.isTTY) return;

      stdin.setEncoding('utf8');
      stdin.on('data', (chunk) => {
        const s = String(chunk || '').trim();
        if (!s) return;
        if (s.toLowerCase() === '/quit') {
          quitRequested = true;
          console.log(col.warn('\nâ¹ Perintah /quit diterima â€” berhenti menunggu kode baru.\n'));
        }
      });
      stdin.resume();

      console.log(col.dim('\n[Hint] Saat menunggu kode baru, Anda bisa ketik /quit lalu Enter untuk membatalkan watch kode.\n'));
    } catch {}
  }


  // ================== UI PROSES (banner, section, step) ==================
  function makeProcessUI() {
    const stripAnsiLocal = (s)=>String(s).replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, '');
    function print(line='') { console.log(line); }
    function header(title, subtitle) {
      const w = 38;
      const center = (txt)=> {
        const pad = Math.max(0, Math.floor((w - stripAnsiLocal(txt).length) / 2));
        return 'â•‘' + ' '.repeat(pad) + txt + ' '.repeat(Math.max(0, w - stripAnsiLocal(txt).length - pad)) + 'â•‘';
      };
      print(col.info('â•”' + 'â•'.repeat(w) + 'â•—'));
      print(col.info(center(title)));
      if (subtitle) print(col.info(center(subtitle)));
      print(col.info('â•š' + 'â•'.repeat(w) + 'â•\n'));
    }
    function section(name) {
      const line = `â”Œâ”€ ${name} ${'â”€'.repeat(Math.max(0, 64 - name.length))}`;
      print(col.mag(line));
    }
    function done() { print(col.mag('â””' + 'â”€'.repeat(68))); }
    function step(idx, total, text) {
      print(`${col.dim(`[${idx}/${total}]`)} ${text}`);
    }
    function info(text){ print(col.dim(text)); }
    function ok(text){ print(col.ok(text)); }
    function warn(text){ print(col.warn(text)); }
    function err(text){ print(col.err(text)); }
    return { header, section, done, step, info, ok, warn, err };
  }
  const ui = makeProcessUI();
  ui.header('CGV Account Tools', 'by Iqra Ganteng');
  ui.section('Auto Redeem Codes (CGV)');
  ui.info('Menyiapkan modul & fallbackâ€¦');
  ui.done();

  const YES = col.ok('YES');
  const NO  = col.err('NO');

  // ---------- helpers ----------
  function yn(b) { return b ? YES : NO; }

  const TODAY_YMD = (()=>{
    const d = new Date();
    const pad = (n)=> String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  })();

  function toYMD(x) {
    if (!x) return '';
    if (typeof x === 'string') {
      if (/^\d{4}-\d{2}-\d{2}$/.test(x)) return x;
      const t = Date.parse(x);
      if (!Number.isNaN(t)) {
        const d = new Date(t);
        const pad = (n)=> String(n).padStart(2,'0');
        return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
      }
      return '';
    }
    const d = new Date(x);
    if (Number.isNaN(+d)) return '';
    const pad = (n)=> String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  }
  function isTodayYMD(s) {
    const y = toYMD(s);
    return y && y === TODAY_YMD;
  }

  // ====== ACCOUNT KEY + TSEL10K DETECTOR ======
  let tselTodayByAccountKey = new Map();

  function getAccountKey(acc) {
    if (!acc || typeof acc !== 'object') return null;
    return (
      acc.phone ||
      acc.msisdn ||
      acc.nohp ||
      acc.hp ||
      acc.memberPhone ||
      acc.mobile ||
      acc.tel ||
      acc.email ||
      acc.username ||
      null
    );
  }

  function isTsel10kCode(code) {
    if (!code) return false;
    const up = String(code).toUpperCase().trim();
    return up.startsWith('TSEL10K');
  }

  // ========== ANTI-STUCK HELPERS ==========
  const withTimeout = (promise, ms, label = 'Timeout') =>
    Promise.race([
      promise,
      new Promise((_, rej) => setTimeout(() => rej(new Error(label)), ms))
    ]);

  const fetchWithTimeout = async (url, opts, timeoutMs = 15000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      return await fetch(url, { ...opts, signal: ctrl.signal });
    } finally {
      clearTimeout(t);
    }
  };

  // =============== ENV HELPERS (DEFAULT_PASSWORDS) ===============
  function readDefaultPasswordsFromEnv() {
    let raw = '';
    try { raw = process?.env?.DEFAULT_PASSWORDS || ''; } catch {}
    if (!raw) {
      try {
        const v = getEnvironmentData?.('DEFAULT_PASSWORDS');
        if (typeof v === 'string') raw = v;
      } catch {}
    }
    return String(raw || '')
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);
  }
  const DEFAULT_PASSWORDS = readDefaultPasswordsFromEnv();

  // ========== ACCOUNT MUTATION QUEUE (DISIMPAN & DITULIS DI AKHIR) ==========
  const pendingUpdates = new Map(); // email -> partial fields
  function queueAccountUpdate(email, patch) {
    const key = String(email || '').toLowerCase();
    if (!key) return;
    const cur = pendingUpdates.get(key) || {};
    pendingUpdates.set(key, { ...cur, ...patch });
  }

  function wrapBearerParts(token) {
    const s = String(token || '');
    if (!s) return [];
    const n = Math.ceil(s.length / 3);
    return [s.slice(0, n), s.slice(n, n * 2), s.slice(n * 2)];
  }

  // ========== VOUCHER HELPERS FROM REFERENCE (listAccounts) ==========
  const deepPick = (obj, candidates) => {
    for (const key of candidates) {
      if (!key) continue;
      const path = String(key).split('.');
      let cur = obj, ok = true;
      for (const p of path) {
        if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
        else { ok = false; break; }
      }
      if (!ok) continue;
      if (cur !== undefined && cur !== null && !(typeof cur === 'string' && cur.trim() === '')) return cur;
    }
    return null;
  };

  const parseDateAny = (x) => {
    if (x === null || x === undefined) return null;
    if (typeof x === 'number') {
      const ms = x > 1e12 ? x : x * 1000;
      const d = new Date(ms); return isNaN(d) ? null : d;
    }
    const s = String(x).trim(); if (!s) return null;
    if (/^\d{14}$/.test(s)) {
      const y=s.slice(0,4), m=s.slice(4,6), d=s.slice(6,8), H=s.slice(8,10), M=s.slice(10,12), S=s.slice(12,14);
      const dt = new Date(Number(y), Number(m)-1, Number(d), Number(H), Number(M), Number(S));
      return isNaN(dt) ? null : dt;
    }
    if (/^\d{8}$/.test(s))  {
      const y=s.slice(0,4), m=s.slice(4,6), d=s.slice(6,8);
      const dt = new Date(Number(y), Number(m)-1, Number(d), 0,0,0);
      return isNaN(dt) ? null : dt;
    }
    const d = new Date(s); return isNaN(d) ? null : d;
  };

  const toIsoLocal = (x) => {
    const d = parseDateAny(x); if (!d) return null;
    const pad = (n) => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  };

  const adjustEndInclusive = (rawVal) => {
    if (rawVal == null) return null;
    const s = String(rawVal).trim();
    const d = parseDateAny(rawVal);
    if (!d) return null;
    const isDayOnly = /^\d{8}$/.test(s) || /^\d{4}-\d{2}-\d{2}$/.test(s);
    const isMidnight = d.getHours()===0 && d.getMinutes()===0 && d.getSeconds()===0;
    if (isDayOnly || isMidnight) {
      const adj = new Date(d);
      adj.setHours(23,59,59,999);
      return adj;
    }
    return d;
  };

  const computeStatus = (v) => {
    const useYN  = deepPick(v, ['USE_YN','use_yn','USED_YN','USE_YN_CD','USE_YN_NM','use_yn']);
    const usedAt = deepPick(v, ['USE_DTTM','REDM_DTTM','REDEEM_DTTM','REDEEM_DT','USE_DT','used_at']);
    const rawTxt = deepPick(v, ['CPN_STAT_NM','STAT_NM','STATUS_NM','CPN_STAT_TXT','STAT_TXT','GFTCERT_STAT_NM','STATUS','CPN_USE_STAT','CPN_STAT_CD_NM','status']);
    const startRaw = deepPick(v, [
      'PUB_STR_DTTM','PUB_START_DTTM','VALID_START_DTTM','VALID_BGNG_DTTM','VLD_BGNG_DTTM','USE_STR_DTTM',
      'DSC_AVL_FR_DY','ISSUE_DY','REG_DTTM','START_DY','VALID_FR_DT','VALID_STRT_DT','VALID_FR_DY','VLD_FR_DY','BEGIN_DTTM','APPL_FR_DT','GFCERT_REG_DT',
      'start_at','valid_from'
    ]);
    const endRaw = deepPick(v, [
      'PUB_END_DTTM','VALID_END_DTTM','VALID_TO_DTTM','VLD_END_DTTM','USE_END_DTTM',
      'DSC_AVL_TO_DY','EXP_DY','EXPR_DTTM','EXPR_DY','EXPIRE_DY','END_DY','VALID_TO_DT','VALID_TO_DY','VLD_TO_DY','END_DTTM','APPL_TO_DT',
      'end_at','valid_to'
    ]);
    const start = parseDateAny(startRaw);
    const end   = adjustEndInclusive(endRaw);
    const useStr = useYN == null ? '' : String(useYN).trim().toUpperCase();
    const used = ['1','Y','YES','USED','T','TRUE'].includes(useStr) || (usedAt !== null && String(usedAt).trim() !== '');
    if (used) return { label: 'USED', startRaw, endRaw, rawTxt, endAdj: end };
    if (end && new Date() > end)   return { label: 'EXPIRED', startRaw, endRaw, rawTxt, endAdj: end };
    if (start && new Date() < start) return { label: 'NOT_YET_VALID', startRaw, endRaw, rawTxt, endAdj: end };
    return { label: 'ACTIVE', startRaw, endRaw, rawTxt, endAdj: end };
  };

  const normalizeVoucher = (v, kind) => {
    const name = deepPick(v, ['DSC_NM','GFTCERT_NM','CPN_NM','GFT_NM','TTL_NM','TITLE_NM','PROMO_NM','name']) || '-';
    const st = computeStatus(v);
    const endAdj  = st.endAdj || null;
    const isActiveUnused = st.label === 'ACTIVE';
    const isExpiredBool = st.label === 'EXPIRED';
    return {
      kind, name,
      status: st.label,
      is_expired: isExpiredBool,
      is_active_unused: !!isActiveUnused,
      end_at: endAdj ? toIsoLocal(endAdj) : toIsoLocal(st.endRaw),
      valid_to: endAdj ? toIsoLocal(endAdj) : toIsoLocal(st.endRaw),
    };
  };

  // Helper nama voucher (dari referensi)
  const is1stPopVoucherName = (nm) => {
    const s = String(nm || '').toLowerCase();
    return /(^|\b)1st\b.*visit.*popcorn/.test(s)
        || /first\b.*visit.*popcorn/.test(s)
        || /visit\s*ke[- ]?1.*popcorn/.test(s);
  };

  const parseTxnSimple = (t) => {
    const title   = deepPick(t, ['name','MOVIE_NM','MOV_TTL_NM','TTL_NM','TITLE_NM','GOODS_NM']) || '';
    const type    = deepPick(t, ['type','ORD_TP_NM','CATEGORY']) || '';
    const amount  = Number(deepPick(t, ['amount','PAY_AMT','TOT_PAY_AMT']) ?? 0);
    const rawStat = deepPick(t, ['ORD_STAT_NM','STAT_NM','STATUS_NM','ORDER_STATUS','PAY_STAT_NM']);
    let status = 'UNKNOWN';
    if (rawStat) {
      const s=String(rawStat).toLowerCase();
      if (/cancel|void|refund|batal|gagal|fail|chargeback/.test(s)) status='CANCELLED';
      else if (/success|paid|complete|berhasil|selesai|approved|settled/.test(s)) status='SUCCESS';
      else if (/pending|menunggu|await|process|processing|unpaid/.test(s)) status='PENDING';
    }
    const created_at = toIsoLocal(deepPick(t, ['transaction_date_time','REG_DTTM','ORD_DTTM','transaction_date']));
    return { title, type, amount, status, created_at };
  };

  // Detector 1st Visit Popcorn yang benar
  const detectPopcorn1stVisitStatus = (vouchers, txnsRaw) => {
    const hasActive = (vouchers || []).some(v =>
      is1stPopVoucherName(v.name) && v.is_active_unused === true && v.is_expired === false
    );
    let usedBefore = false;
    for (const it of (txnsRaw || [])) {
      const p = parseTxnSimple(it);
      if (p.status !== 'SUCCESS') continue;
      if (/popcorn/i.test(p.title) && p.amount === 0) {
        usedBefore = true;
        break;
      }
    }
    const status = hasActive ? 'YES' : (usedBefore ? 'USED' : 'NO');
    return { status, has_active: hasActive, used_before: usedBefore };
  };

  // Detector Combo Solo yang benar
  const detectComboSoloStatus = (vouchers, txnsRaw) => {
    const re = /combo\s*solo/i;
    const hasActive = (vouchers || []).some(v => re.test(String(v.name || '')) && v.is_active_unused === true);
    let usedBefore = false;
    for (const it of (txnsRaw || [])) {
      const p = parseTxnSimple(it);
      if (p.status !== 'SUCCESS') continue;
      if (re.test(p.title)) {
        usedBefore = true;
        break;
      }
    }
    const status = hasActive && usedBefore ? 'YES+USED'
                 : hasActive               ? 'YES'
                 : usedBefore              ? 'USED'
                 : 'NO';
    return { status, has_active: hasActive, used_before: usedBefore };
  };

  // Detector Telkomsel 10K Flat (nama voucher)
  const detectTelkomsel10KStatus = (vouchers) => {
    const hasActive = (vouchers || []).some(v => {
      const name = String(v.name || '').toLowerCase();
      return /telkomsel.*10k.*flat/i.test(name) && v.is_active_unused === true && v.is_expired === false;
    });
    return { has_active: hasActive };
  };

  // ======== RAW READERS FROM ACCOUNT OBJECT (NO LIVE) ========
  function listAllAccVouchers(acc) {
    const arr = [];
    if (Array.isArray(acc?.voucher_details_active)) arr.push(...acc.voucher_details_active);
    if (Array.isArray(acc?.voucher_details))        arr.push(...acc.voucher_details);
    return arr;
  }

  function hasTelkomsel10KFromAcc(acc) {
    const all = listAllAccVouchers(acc);
    return all.some(v => /telkomsel/i.test(String(v?.name||'')) && /(10k|flat\s*price|flatprice)/i.test(String(v?.name||'')) && (String(v?.status||'').toUpperCase() === 'ACTIVE') && (v?.is_active_unused !== false));
  }
  function telkomsel10KUsedFromAcc(acc) {
    // pakai counter jika ada, atau dari voucher used_at
    if (Number(acc?.tsel10k_used_times || 0) > 0) return true;
    const all = listAllAccVouchers(acc);
    return all.some(v => /telkomsel/i.test(String(v?.name||'')) && (v?.used_at != null && String(v.used_at).trim() !== ''));
  }

  function popRaw(acc) {
    return {
      has: acc?._pop?.has_active === true
        || acc?.popcorn_1st_visit_has_active === true
        || acc?.pop_has === true,
      usedBefore: acc?._pop?.used_before === true
        || acc?.popcorn_1st_visit_used_before === true
        || (Number(acc?.popcorn_1st_visit_used_times||0) > 0)
        || acc?.pop_used_before === true,
      status: String(acc?._pop?.status || acc?.popcorn_1st_visit_status || acc?.pop_status || '').toUpperCase() || (acc?.popcorn_1st_visit_has_active ? 'YES' : (Number(acc?.popcorn_1st_visit_used_times||0)>0 ? 'USED' : 'NO'))
    };
  }
  function comboRaw(acc) {
    return {
      has: acc?._combo?.has_active === true
        || acc?.combo_solo_has_active === true
        || acc?.combo_has === true,
      usedBefore: acc?._combo?.used_before === true
        || acc?.combo_solo_used_before === true
        || (Number(acc?.combo_solo_used_times||0) > 0)
        || acc?.combo_used_before === true,
      status: String(acc?._combo?.status || acc?.combo_solo_status || acc?.combo_status || '').toUpperCase() || (acc?.combo_solo_has_active ? 'YES' : (Number(acc?.combo_solo_used_times||0)>0 ? 'USED' : 'NO'))
    };
  }
  // NEW: third visit (B1G1)
  function thirdRaw(acc) {
    const hasAct = acc?.third_visit_b1g1_has_active === true;
    const usedTimes = Number(acc?.third_visit_b1g1_used_times || 0);
    const usedBefore = usedTimes > 0 || acc?.third_visit_b1g1_used_before === true;
    const status = String(acc?.third_visit_b1g1_status || '').toUpperCase() || (hasAct ? 'YES' : (usedBefore ? 'USED' : 'NO'));
    return { has: !!hasAct, usedBefore, status };
  }
  function flatRaw(acc) {
    // prefer explicit fields; else scan voucher_details(_active)
    const has = acc?._flat?.has_active === true
      || acc?.flat10k_has === true
      || hasTelkomsel10KFromAcc(acc);
    const usedBefore = acc?._flat?.used_before === true
      || acc?.flat10k_used === true
      || telkomsel10KUsedFromAcc(acc);
    return { has, usedBefore };
  }

  function hasAnyActiveVoucher(acc) {
    const a = Number(acc?._voucher_active_count ?? acc?.voucher_count_active ?? acc?.voucher_count ?? 0) > 0;
    const p = popRaw(acc).has;
    const c = comboRaw(acc).has;
    const t = thirdRaw(acc).has;
    const f = flatRaw(acc).has;
    return (a || p || c || t || f);
  }

  // ========= ANSI & TABLE FIT UTILS =========
  function stripAnsi(str) {
    return String(str).replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, '');
  }
  function visibleLen(s){ return stripAnsi(String(s ?? '')).length; }

  function padLeftAnsi(s, w) {
    const raw = String(s ?? '');
    const len = visibleLen(raw);
    if (len >= w) return raw;
    return ' '.repeat(w - len) + raw;
  }
  function padRightAnsi(s, w) {
    const raw = String(s ?? '');
    const len = visibleLen(raw);
    return len >= w ? raw : (raw + ' '.repeat(w - len));
  }
  function padCenterAnsi(s, w) {
    const raw = String(s ?? '');
    const len = visibleLen(raw);
    if (len >= w) return raw;
    const left = Math.floor((w - len) / 2);
    const right = w - len - left;
    return ' '.repeat(left) + raw + ' '.repeat(right);
  }

  function ellipsize(s, w) {
    const raw = String(s ?? '');
    const len = raw.length;
    if (w <= 0) return '';
    if (len <= w) return raw;
    if (w === 1) return 'â€¦';
    return raw.slice(0, Math.max(0, w - 1)) + 'â€¦';
  }

  function borderLine(widths, left, mid, right) {
    const cells = widths.map(w => 'â”€'.repeat(w + 2));
    return left + cells.join(mid) + right;
  }

  function totalTableWidth(widths) {
    const n = widths.length;
    return 1 + widths.reduce((a,w)=>a+(w+2),0) + (n-1) + 1;
  }

  function shrinkToFit(widths, headers, rows, elasticIdxs, termW) {
    let w = widths.slice();
    let total = totalTableWidth(w);
    if (total <= termW) return w;
    const minW = w.map((_,i)=>Math.max(visibleLen(headers[i]), 3));
    let over = total - termW;
    function totalPotential() {
      return elasticIdxs.reduce((a,i)=> a + Math.max(0, w[i] - minW[i]), 0);
    }
    let guard = 200000;
    while (over > 0 && totalPotential() > 0 && guard-- > 0) {
      for (const i of elasticIdxs) {
        if (over <= 0) break;
        if (w[i] > minW[i]) { w[i] -= 1; over -= 1; }
      }
    }
    return w;
  }

  function fmtDate(s) {
    const y = toYMD(s);
    return y || '-';
  }

  // ===== API helpers (live fetch) â€“ DI BIARKAN, tapi tidak dipakai saat useLiveFetch=false =====
  async function safeFetchJson(url, bearer) {
    try {
      const res = await fetch(url, {
        method: 'GET',
        headers: {
          accept: 'application/json, text/plain, */*',
          authorization: `Bearer ${bearer}`,
          'user-agent': 'okhttp/4.10.0',
          'accept-encoding': 'gzip',
        }
      });
      let json = null;
      try { json = await res.json(); } catch {}
      return { status: res.status, json };
    } catch (e) {
      return { status: -1, json: null, error: e };
    }
  }

  function pickDateField(it) {
    return it?.transaction_date || it?.created_at || it?.order_at || it?.booking_at || it?.paid_at || it?.date || it?.updated_at || null;
  }

  async function tryFetchTxnHistoryHTTP(bearer) {
    const paths = [
      '/api/booking/histories?per_page=50&page=1',
      '/api/membership/bookings/histories?per_page=50&page=1',
      '/api/membership/orders/histories?per_page=50&page=1',
      '/api/orders/histories?per_page=50&page=1',
      '/api/membership/transactions?per_page=50&page=1'
    ];
    for (const p of paths) {
      const { status, json } = await safeFetchJson(`${baseURL}${p}`, bearer).catch(() => ({ status: -1, json: null }));
      if (status !== 200 || !json) continue;
      const arr = Array.isArray(json?.data) ? json.data
                : Array.isArray(json?.RESULTS) ? json.RESULTS
                : Array.isArray(json?.items) ? json.items
                : Array.isArray(json?.history) ? json.history
                : null;
      if (!arr) continue;

      let visits = 0;
      let latest = '';
      for (const it of arr) {
        const d = pickDateField(it);
        if (d) {
          const y = toYMD(d);
          if (y) {
            visits += 1;
            if (!latest || y > latest) latest = y;
          }
        }
      }
      if (!visits) visits = arr.length || 0;

      return { ok: true, visits, last_date: latest || '' };
    }
    return { ok: false };
  }

  function detectVoucherFlags(vouchers) {
    let pop = { has:false, usedBefore:false, status:'-' };
    let combo = { has:false, usedBefore:false, status:'-' };
    let flat = { has:false, used:false };
    let activeCount = 0;

    const getAllVoucherText = (v) => {
      const names = [
        v.DSC_NM, v.GFTCERT_NM, v.CPN_NM, v.PROMO_NM, v.TITLE_NM,
        v.name, v.title, v.type, v.kind
      ].map(s => String(s || '')).join(' ');
      const notes = String(v.ON_CUST_NOTY_CONT || v.DSC_DTL || v.REMARK || '');
      return `${names} ${notes}`.toLowerCase();
    };

    const isVoucherUsed = (v) => {
      const useYN = String(v.USE_YN || v.use_yn || v.USED_YN || v.USE_YN_CD || v.USE_YN_NM || '').trim().toUpperCase();
      const usedAt = v.USE_DTTM || v.REDM_DTTM || v.REDEEM_DTTM || v.REDEEM_DT || v.USE_DT;
      if (['1','Y','YES','USED','T','TRUE'].includes(useYN)) return true;
      if (usedAt != null && String(usedAt).trim() !== '') return true;
      const status = String(v.status || v.state || v.usage_status || v.coupon_status || '').toLowerCase();
      return status.includes('used') || status.includes('redeem') || status.includes('closed') || v.used === true;
    };

    const isVoucherActive = (v) => {
      const status = String(v.status || v.state || v.usage_status || v.coupon_status || '').toLowerCase();
      return status.includes('active') || status.includes('available') || status === '' || status === 'ok' || !isVoucherUsed(v);
    };

    for (const v of vouchers || []) {
      const allText = getAllVoucherText(v);
      const used = isVoucherUsed(v);
      const active = isVoucherActive(v);

      if (active) activeCount++;

      if (/(^|\b)1st\b.*visit/.test(allText) && /(popcorn|salty)/.test(allText)) {
        pop.has = pop.has || active;
        pop.usedBefore = pop.usedBefore || used;
        pop.status = (v.status || v.state || 'OK').toString().toUpperCase();
      }
      else if (/combo\s*solo/.test(allText)) {
        combo.has = combo.has || active;
        combo.usedBefore = combo.usedBefore || used;
        combo.status = (v.status || v.state || 'OK').toString().toUpperCase();
      }
      else if (/telkomsel/.test(allText) && /(10k|flat\s*price|flatprice)/.test(allText)) {
        flat.has = flat.has || active;
        flat.used = flat.used || used;
      }
    }
    return { pop, combo, flat, activeCount };
  }

  async function tryFetchVoucherListHTTP(bearer) {
    const paths = [
      '/api/membership/coupons',
      '/api/membership/vouchers',
      '/api/coupons',
    ];
    for (const p of paths) {
      const { status, json } = await safeFetchJson(`${baseURL}${p}`, bearer).catch(() => ({ status: -1, json: null }));
      if (status !== 200 || !json) continue;
      const arr = Array.isArray(json?.data) ? json.data
                : Array.isArray(json?.vouchers) ? json.vouchers
                : Array.isArray(json?.items) ? json.items
                : Array.isArray(json?.RESULTS) ? json.RESULTS
                : null;
      if (!arr) continue;
      return { ok: true, list: arr };
    }
    return { ok: false, list: [] };
  }

  // (BARU) Safe getMemberInfo dengan timeout
  const getMemberInfoSafe = async (token) => {
    try {
      if (typeof getMemberInfo === 'function') {
        return await withTimeout(getMemberInfo(token), 20000, 'getMemberInfo timeout');
      }
      const res = await fetchWithTimeout(`${baseURL}/api/membership/info`, {
        method: 'GET',
        headers: {
          'accept': 'application/json, text/plain, */*',
          'authorization': `Bearer ${token}`,
          'user-agent': 'okhttp/4.10.0',
          'accept-encoding': 'gzip',
        }
      }, 15000);
      if (res.ok) {
        const json = await res.json();
        return json;
      }
      return null;
    } catch {
      return null;
    }
  };

  // (BARU) Safe getLoginAccount dengan timeout
  const getLoginAccountSafe = async (email, pwd) => {
    try {
      if (typeof getLoginAccount === 'function') {
        return await withTimeout(getLoginAccount(email, pwd), 20000, 'login timeout');
      }
      return { status_code: 0, message: 'getLoginAccount function not available' };
    } catch (e) {
      return { status_code: 0, message: e?.message || 'Login error' };
    }
  };

  // ==== ENSURE BEARER: GUNAKAN account.json + ENV DEFAULT_PASSWORDS (TANPA akunLogin.txt) ====
  async function ensureBearerForEmail(email, bearer0, accObjRef=null) {
    // 1) jika ada bearer & tidak perlu verifikasi â†’ pakai saja
    if (bearer0 && !verifyBearerBefore) return { ok:true, bearer: bearer0, source: 'account.json' };

    // 2) jika ada bearer & diverifikasi â†’ cek
    if (bearer0 && verifyBearerBefore) {
      try {
        const info = await getMemberInfoSafe(String(bearer0));
        const msg = String(info?.message || '').toLowerCase();
        if (info?.RESULTS?.ds_mbrList) return { ok:true, bearer: bearer0, source: 'account.json' };
        if (info?.status_code !== 401 && !/expired|invalid|unauthoriz/.test(msg)) {
          return { ok:true, bearer: bearer0, source: 'account.json(?)' };
        }
        // jatuh ke login ulang
      } catch {}
    }

    // 3) login ulang: prioritas password dari account.json, kalau gagal coba ENV DEFAULT_PASSWORDS
    const emailNorm = String(email || '').trim().toLowerCase();
    const currentPwd = String(accObjRef?.password || '').trim();

    const candidates = [];
    if (currentPwd) candidates.push(currentPwd);
    for (const p of DEFAULT_PASSWORDS) {
      if (p && p !== currentPwd) candidates.push(p);
    }

    if (!candidates.length) {
      return { ok:false, reason: 'Tidak ada password kandidat (cek field password di account.json atau ENV DEFAULT_PASSWORDS)' };
    }

    let lastErr = null;
    for (const pwdTry of candidates) {
      const res = await getLoginAccountSafe(emailNorm, pwdTry);
      if (res?.status_code === 200 && res?.token) {
        // Sukses â†’ queue update: bearer & login_ok
        const nowISO = new Date().toISOString();
        const wrapped = wrapBearerParts(res.token);
        queueAccountUpdate(emailNorm, {
          bearer: res.token,
          bearer_wrapped: wrapped,
          bearer_updated_at: nowISO,
          login_ok: true
        });

        // Jika password yang berhasil â‰  yang tersimpan â†’ update password fields
        if (pwdTry !== currentPwd) {
          queueAccountUpdate(emailNorm, {
            password: pwdTry,
            password_updated_at: nowISO
          });
        }

        return { ok:true, bearer: res.token, source: 'login' };
      }
      lastErr = res?.message || `Login gagal (${res?.status_code || '???'})`;
      // lanjut coba kandidat berikutnya
    }
    return { ok:false, reason: lastErr || 'Login gagal semua kandidat' };
  }

  async function enrichAccountLive(acc, timeoutMs = maxProcessTimeoutMs) {
    const email = String(acc?.email || 'unknown');
    const heartbeat = setInterval(() => {
      ui.info(`â³ Masih memproses ${email}...`);
    }, timeoutMs / 2);

    try {
      return await withTimeout(_enrichAccountLiveInternal(acc), timeoutMs, `enrichAccount timeout for ${email}`);
    } finally {
      clearInterval(heartbeat);
    }
  }

  async function _enrichAccountLiveInternal(acc) {
    let ensured = { ok:false };
    const result = { ...acc };
    const flags = { bearer:false, txn:false, vouchers:false, reason:'' };

    try {
      ensured = await ensureBearerForEmail(acc.email, acc.bearer, acc);
    } catch (e) {
      flags.reason = String(e?.message || e || '');
    }
    if (!ensured.ok) {
      result._enrich = { ...flags, bearer:false, reason: flags.reason || 'Bearer/Login gagal' };
      result._enrichOk = false;
      return result;
    }

    result._bearer = ensured.bearer;
    flags.bearer = true;

    // 2) MEMBER INFO
    try {
      const info = await getMemberInfoSafe(result._bearer);
      if (info?.RESULTS?.ds_mbrList) {
        const m = info.RESULTS.ds_mbrList;
        result._visits = Number(m.TOT_VISIT_FOR_UI ?? 0);
        result._tier = m.MBR_GRD_NM || m.MBR_TIER_NM || 'NEW';
        result._memberInfo = m;
        flags.member = true;
      }
    } catch {}

    // 3) TXN
    try {
      let stat = null;
      if (typeof fetchTxnHistory === 'function') {
        const s = await fetchTxnHistory(result._bearer);
        if (s && typeof s === 'object') stat = { visits: Number(s.visits||0), last_date: s.last_date || s.last || '' };
      } else {
        const t = await tryFetchTxnHistoryHTTP(result._bearer);
        if (t.ok) stat = t;
      }
      if (stat) {
        if (!result._visits) result._visits = Number(stat.visits || 0);
        result._lastMovieDate = toYMD(stat.last_date || '');
        result._lastIsToday = isTodayYMD(result._lastMovieDate);
        flags.txn = true;
      }
    } catch {}

    // 4) VOUCHER LIST
    try {
      let list = null;
      if (typeof fetchVoucherList === 'function') {
        const arr = await fetchVoucherList(result._bearer);
        if (Array.isArray(arr)) list = arr;
      } else {
        const v = await tryFetchVoucherListHTTP(result._bearer);
        if (v.ok) list = v.list;
      }

      if (list) {
        const coupons = Array.isArray(list) ? list : [];
        const vouchersAll = coupons.map(v => normalizeVoucher(v, 'coupon')).filter(Boolean);
        const vouchersActive = vouchersAll.filter(v => v.is_active_unused === true);

        const txnsRaw = [];
        try {
          const txR = await tryFetchTxnHistoryHTTP(result._bearer);
          if (txR.ok) txnsRaw.push(...txR.data);
        } catch {}

        const popStatus = detectPopcorn1stVisitStatus(vouchersAll, txnsRaw);
        const comboStatus = detectComboSoloStatus(vouchersAll, txnsRaw);
        const flatStatus = detectTelkomsel10KStatus(vouchersAll);

        result._pop   = popStatus;
        result._combo = comboStatus;
        result._flat  = flatStatus;
        result._voucher_active_count = vouchersActive.length;
        result._vouchers_all = vouchersAll;
        flags.vouchers = true;
      }
    } catch {}

    result._enrich = flags;
    result._enrichOk = flags.bearer && (flags.member || flags.txn || flags.vouchers);
    return result;
  }

  function decodeRateRemain(res) {
    try {
      const remain = res.headers?.get?.('x-ratelimit-remaining') ?? res.headers?.['x-ratelimit-remaining'];
      const limit  = res.headers?.get?.('x-ratelimit-limit') ?? res.headers?.['x-ratelimit-limit'];
      return { remain: remain != null ? String(remain) : '?', limit: limit != null ? String(limit) : '?' };
    } catch { return { remain: '?', limit: '?' }; }
  }

  // Helper: Deteksi apakah voucher butuh PIN
  function needsPin(code) {
    const normalized = String(code || '').trim().toUpperCase();
    // Voucher yang dimulai dengan A atau E (dari purchase/redeem di website) butuh PIN
    // Telkomsel, voucher tier gold (E002...), dan voucher promo lain (MORE...) tidak butuh PIN
    if (/^E\d{15}$/i.test(normalized)) return false; // E002592000496023 (tier gold) - tidak butuh PIN
    if (/^MORE/i.test(normalized)) return false;     // MOREKPEQDSST100K - tidak butuh PIN
    if (/^TSEL|^10KT/i.test(normalized)) return false; // 10KTSELKBNQVNW4 (Telkomsel) - tidak butuh PIN

    // A042522000080987 (purchase dari website) - butuh PIN
    // A032580000036815 (redeem dari vouchers) - butuh PIN
    if (/^A\d{15}$/i.test(normalized)) return true;

    return false;
  }

  async function postRedeem(bearer, code, pin = null) {
    const requiresPin = needsPin(code);

    // Pilih endpoint berdasarkan apakah butuh PIN
    const url = requiresPin
      ? `${baseURL}/api/membership/vouchers/register`   // untuk voucher dengan PIN
      : `${baseURL}/api/membership/coupons/register`;   // untuk voucher tanpa PIN

    const FD = globalThis.FormData || (await import('form-data')).default;
    const fd = new FD();

    if (requiresPin) {
      fd.append('voucher_number', code);
      if (pin) {
        fd.append('voucher_pin', String(pin));
      }
    } else {
      fd.append('coupon_number', code);
    }

    let tryCount = 0, backoff = 1500;
    while (true) {
      tryCount++;
      const res = await fetchWithTimeout(url, {
        method: 'POST',
        headers: {
          'accept': 'application/json, text/plain, */*',
          'authorization': `Bearer ${bearer}`,
          'accept-encoding': 'gzip',
          'user-agent': 'okhttp/4.10.0'
        },
        body: fd
      }, 15000);
      const rate = decodeRateRemain(res);
      let json;
      try { json = await res.json(); } catch { json = null; }

      if (res.status === 200 && (json?.status_code === 200 || json?.status === 'success')) {
        return { ok:true, data: json, rate, requiresPin };
      }

      // Handle PIN-related errors
      if (json?.message === 'PIN_NO does not match.' || json?.message?.includes('PIN')) {
        return { ok:false, reason:'PIN tidak cocok', rate, code:422, body: json, requiresPin, needRetryWithPin: true };
      }

      if (res.status === 422 || json?.status_code === 422) {
        const reason = json?.message || 'Invalid Coupon';
        return { ok:false, reason, rate, code:422, body: json, requiresPin };
      }
      if (res.status === 401) {
        return { ok:false, reason:'Unauthorized (401)', rate, code:401, body: json, requiresPin };
      }
      if (res.status === 429 && tryCount <= maxRetry429) {
        rateLimitCount++;
        await delay(backoff); backoff = Math.min(backoff * 1.6, 10_000);
        continue;
      }
      return { ok:false, reason: `HTTP ${res.status}`, rate, code: res.status, body: json, requiresPin };
    }
  }

  async function getCouponDetail(bearer, code) {
    const url = `${baseURL}/api/membership/coupons/${encodeURIComponent(code)}`;
    const res = await fetchWithTimeout(url, {
      method: 'GET',
      headers: {
        'accept': 'application/json, text/plain, */*',
        'authorization': `Bearer ${bearer}`,
        'accept-encoding': 'gzip',
        'user-agent': 'okhttp/4.10.0'
      }
    }, 15000);
    let json = null;
    try { json = await res.json(); } catch {}
    if (res.status === 200 && (json?.status_code === 200 || json?.status === 'success')) return { ok:true, data: json?.data };
    return { ok:false, code: res.status, data: json };
  }

  function explainFailure(respObj) {
    const j = respObj?.body || {};
    const msg = j?.message || j?.error || j?.msg || j?.data?.message || j?.data?.result?.message;
    const reasons = [];

    if (msg) reasons.push(String(msg));

    const errs = j?.errors || j?.data?.errors || j?.data?.result?.errors;
    if (errs && typeof errs === 'object') {
      const parts = [];
      for (const [k,v] of Object.entries(errs)) {
        const arr = Array.isArray(v) ? v : [v];
        parts.push(`${k}: ${arr.map(x=>String(x)).join('; ')}`);
      }
      if (parts.length) reasons.push(parts.join(' | '));
    }

    if (!reasons.length && j) {
      try { reasons.push(JSON.stringify(j).slice(0, 300)); } catch {}
    }

    const reasonStr = reasons.join(' | ');
    const codeVal = respObj?.code ?? '???';
    return { reasonStr, code: codeVal };
  }

  // ---------- WATCHER KODE ----------
  async function waitForMoreCodes({ path, validSet, seenCodes, processedValidSet, processedInvalidSet, pollMs }) {
    initQuitListenerOnce();

    const start = Date.now();
    let ticks = 0;
    console.log(col.mag(`\nâ³ Kehabisan kode. Pantau file: ${path}`));
    console.log(col.dim(`   â€¢ Interval cek: ${Math.max(10, pollMs)} ms`));
    console.log(col.dim('   â€¢ Silakan tambahkan kode ke file lalu simpan (Ctrl+S).'));
    console.log(col.dim('   â€¢ Kriteria terdeteksi: baris baru, bukan duplikat, belum ada di valid_kode.txt, dan belum pernah dicoba.'));
    openFileInEditor(path);

    while (true) {
      // Kalau user sudah ketik /quit â†’ hentikan watch
      if (quitRequested) {
        console.log(col.warn('\nâ¹ Watch kode dibatalkan oleh user (/quit).'));
        return [];
      }

      await delay(Math.max(10, pollMs));
      ticks++;

      const nowList = await readCodesFromFile(path) || [];
      const newCandidates = [];
      for (const c of nowList) {
        if (!c) continue;
        if (seenCodes.has(c)) continue;
        if (validSet.has(c)) continue;
        if (processedValidSet.has(c)) continue;
        if (processedInvalidSet.has(c)) continue;
        newCandidates.push(c);
      }

      if (newCandidates.length) {
        newCandidates.forEach(c => seenCodes.add(c));
        console.log(col.ok(`â†’ Ditemukan ${newCandidates.length} kode baru di ${path}. Lanjut prosesâ€¦\n`));
        return { codes: newCandidates, isBatch: true }; // return object with batch flag
      }

      // Hapus spam console - hanya log saat pertama kali watch
      // if (ticks % Math.max(1, Math.round(10 * 1000 / Math.max(10, pollMs))) === 0) {
      //   const waited = Math.round((Date.now() - start) / 1000);
      //   console.log(col.dim(`   (menunggu kode baruâ€¦ ${waited}s)`));
      // }
    }
  }


  // ---------- load data ----------
  ui.section('Memuat Akun');
  let accData;
  try {
    const raw = await fs.readFile('account.json','utf-8');
    accData = JSON.parse(raw);
  } catch {
    console.log(col.err('âŒ account.json tidak ditemukan / rusak.'));
    await pauseToMenu();
    return;
  }
  const itemsRaw = Array.isArray(accData?.items) ? accData.items : [];
  if (!itemsRaw.length) {
    console.log(col.warn('âš ï¸  account.json kosong. Tidak ada akun.'));
    await pauseToMenu();
    return;
  }

  // ===== (BARU) AUTO-SKIP NOT FOUND (gabung account.json & notfound.json) =====
  const NOTFOUND_FILE = 'notfound.json';
  const notFoundSet = new Set();
  try {
    const nfRaw = await fs.readFile(NOTFOUND_FILE, 'utf-8');
    const nf = JSON.parse(nfRaw);
    if (Array.isArray(nf)) {
      nf.forEach(r => {
        if (r && r.email) notFoundSet.add(String(r.email).trim().toLowerCase());
      });
    }
  } catch { /* silent if missing */ }

  const shouldSkip = (it) => {
    if (!it || !it.email) return true;
    const k = String(it.email).trim().toLowerCase();
    const flaggedInAccount =
      it.not_found === true ||
      String(it.account_status || '').toLowerCase() === 'not_found' ||
      String(it.status || '').toLowerCase() === 'not_found';
    const flaggedInFile = notFoundSet.has(k);
    return flaggedInAccount || flaggedInFile;
  };

  // HANYA proses akun yang tidak "not_found"
  const items = itemsRaw.filter(it => it && it.email && !shouldSkip(it));
  const skippedCount = itemsRaw.length - items.length;

  // Buat lookup cepat by email untuk referensi update akhir (tetap dari itemsRaw)
  const itemByEmail = new Map(itemsRaw.map(it => [String(it?.email || '').toLowerCase(), it]));
  ui.info(`account.json terbaca. Total akun: ${itemsRaw.length} | skipped (not_found): ${skippedCount} | to process: ${items.length}`);
  if (!items.length) {
    console.log(col.warn('Semua akun tersaring (not_found). Tidak ada yang diproses.'));
    await pauseToMenu();
    return;
  }
  ui.done();

  // ---------- AUTO BATCH SIZE (INFO) ----------
  ui.section('Pengaturan Scan');
  if (!useLiveFetch) {
    ui.info('ğŸ”Œ Live fetch: OFF (pakai data account.json agar cepat)');
  } else {
    let enrichBatchSize = currentBatchSize;
    let bdMs = batchDelayMs;
    ui.info(`ğŸš€ Auto-start: ${enrichBatchSize} akun/batch, delay: ${bdMs}ms`);
    ui.info(`ğŸ“Š Smart fallback: jika rate limit > ${MAX_RATE_LIMITS_BEFORE_FALLBACK}, turun ke 5 akun/batch + delay 1200ms`);
  }
  ui.done();

  // ---------- ENRICH (NO LIVE): pakai data account.json ----------
  const enriched = [];
  if (!useLiveFetch) {
    ui.section('Ambil Data (account.json)');
    // Konversi ringan untuk akun yang DIPROSES (sudah di-skip not_found)
    for (const it of items) {
      const res = { ...it };

      // Visits & tier & last movie
      res._visits = Number(it.visits || 0);
      res._tier = it.tier || 'NEW';
      const last = it.last_movie_date || it.last_txn_date || null;
      res._lastMovieDate = toYMD(last);
      res._lastIsToday = isTodayYMD(res._lastMovieDate);

      // Voucher counts
      const all = listAllAccVouchers(it);
      const normalized = all.map(v => normalizeVoucher(v, 'coupon'));
      const activeCount = normalized.filter(v => v.is_active_unused === true && v.is_expired === false).length;
      res._voucher_active_count = Number(it.voucher_count_active || activeCount || 0);
      res._vouchers_all = normalized;

      // Flags (pop/combo/third/flat) berdasarkan field account.json
      res._pop = {
        has_active: it.popcorn_1st_visit_has_active === true,
        used_before: it.popcorn_1st_visit_used_before === true || Number(it.popcorn_1st_visit_used_times||0)>0,
        status: String(it.popcorn_1st_visit_status || '').toUpperCase() || (it.popcorn_1st_visit_has_active ? 'YES' : (Number(it.popcorn_1st_visit_used_times||0)>0 ? 'USED' : 'NO'))
      };
      res._combo = {
        has_active: it.combo_solo_has_active === true,
        used_before: it.combo_solo_used_before === true || Number(it.combo_solo_used_times||0)>0,
        status: String(it.combo_solo_status || '').toUpperCase() || (it.combo_solo_has_active ? 'YES' : (Number(it.combo_solo_used_times||0)>0 ? 'USED' : 'NO'))
      };
      res._third = {
        has_active: it.third_visit_b1g1_has_active === true,
        used_before: it.third_visit_b1g1_used_before === true || Number(it.third_visit_b1g1_used_times||0)>0,
        status: String(it.third_visit_b1g1_status || '').toUpperCase() || (it.third_visit_b1g1_has_active ? 'YES' : (Number(it.third_visit_b1g1_used_times||0)>0 ? 'USED' : 'NO'))
      };
      res._flat = {
        has_active: it.flat10k_has === true || hasTelkomsel10KFromAcc(it),
        used_before: it.flat10k_used === true || telkomsel10KUsedFromAcc(it)
      };

      res._enrich = { bearer: !!it.bearer, txn: false, vouchers: true };
      res._enrichOk = true;

      enriched.push(res);
    }
    ui.ok(`Selesai load dari account.json. (tanpa live fetch)`);
    ui.done();
  } else {
    // ======== (MODE LAMA â€“ LIVE FETCH) ========
    ui.section('Ambil Data Live (transaksi & voucher)');
    const totalEnrich = items.length;
    let scanOK = 0, scanPartial = 0, scanFail = 0;
    let counter = 0;

    function badge(flags, acc) {
      const t = flags?.txn ? 'txnâœ“' : 'txnâ€“';
      const vCount = Number(acc?._voucher_active_count ?? acc?.voucher_count_active ?? 0);
      const v = flags?.vouchers ? `vchâœ“(${vCount})` : 'vchâ€“';
      const fHas = flatRaw(acc).has ? 'Fâœ“' : 'Fâ€“';
      return col.dim(`[${t} ${v} ${fHas}]`);
    }

    for (let start = 0; start < totalEnrich; start += currentBatchSize) {
      if (rateLimitCount >= MAX_RATE_LIMITS_BEFORE_FALLBACK && currentBatchSize > 5) {
        console.log(col.warn(`âš ï¸  Rate limit detected (${rateLimitCount}x) â†’ fallback to 5 akun/batch, delay 1200ms`));
        currentBatchSize = 5;
        batchDelayMs = 1200;
        start = Math.floor(start / currentBatchSize) * currentBatchSize;
      }

      const batch = items.slice(start, start + currentBatchSize);
      const batchNo = Math.floor(start/currentBatchSize) + 1;
      const batchInfo = currentBatchSize === 10 ? 'ğŸš€ FAST' : 'ğŸ›¡ï¸  SAFE';
      console.log(col.info(`\nâ”€â”€ Batch ${batchNo} â€¢ Akun ${start+1}â€“${start+batch.length} ${batchInfo} â€¢ RateLimit: ${rateLimitCount} â”€â”€`));

      const results = await Promise.all(batch.map(async (it) => {
        const pos = ++counter;
        const email = String(it.email || '-');
        const prefix = `${col.dim(`[${pos}/${totalEnrich}]`)} ${col.white(email)} `;
        try {
          const withLive = await enrichAccountLive({ ...it }, maxProcessTimeoutMs);
          const f = withLive?._enrich || {};
          if (!f.bearer) {
            scanFail++;
            console.log(prefix + col.err('âœ— FAIL') + ' ' + col.dim('(login/bearer)'));
          } else if (withLive._enrichOk) {
            scanOK++;
            console.log(prefix + col.ok('âœ“ OK') + ' ' + badge(f, withLive));
          } else {
            scanPartial++;
            console.log(prefix + col.warn('â–³ PARTIAL') + ' ' + badge(f, withLive));
          }
          return withLive;
        } catch (e) {
          scanFail++;
          const reason = e?.message?.includes('timeout') ? 'TIMEOUT' : 'ERROR';
          console.log(prefix + col.err(`âœ— ${reason}`) + ' ' + col.dim(String(e?.message || e || 'error')));
          return it;
        }
      }));

      enriched.push(...results);
      if (start + currentBatchSize < totalEnrich) await delay(batchDelayMs);
    }

    ui.ok(`Selesai ambil data live. (${col.ok(`OK: ${scanOK}`)} â€¢ ${col.warn(`PARTIAL: ${scanPartial}`)} â€¢ ${col.err(`FAIL: ${scanFail}`)} â€¢ RateLimit: ${rateLimitCount})`);
    ui.done();
  }

  // ---------- TABEL (split) ----------
  ui.section('Tabel Akun');
  function drawAccountsTable(items, titleNote='') {
    const itemsSorted = items.slice().sort((a,b) => (Number(b._visits ?? b.visits ?? 0)) - (Number(a._visits ?? a.visits ?? 0)));

    const headers = [
      'No', 'Email', 'Phone', 'Tier', 'Visits', 'Last Movie',
      'Popcorn Active', 'Popcorn Ever Used', 'Popcorn Status',
      'Combo Active', 'Combo Ever Used', 'Combo Status',
      '3rd Active', '3rd Ever Used', '3rd Status',
      'Flat10k Has', 'Flat10k Used',
      'Active Vouchers'
    ];

    const rows = itemsSorted.map(it => {
      const p = popRaw(it);
      const c = comboRaw(it);
      const t = thirdRaw(it);
      const f = flatRaw(it);

      const visitsRaw = Number(it._visits ?? it.visits ?? 0);
      const tierName = it._tier || it.tier || 'NEW';
      const last = it._lastMovieDate || it.last_movie_date || it.last_movie || '-';
      const lastY = fmtDate(last);
      const isToday = lastY !== '-' && (it._lastIsToday === true || isTodayYMD(lastY));

      let visitsTxt = String(visitsRaw);
      if (isToday) visitsTxt = col.ok(visitsTxt);
      else if (visitsRaw === 0) visitsTxt = col.err(visitsTxt);

      let lastTxt = '-';
      if (lastY === '-') {
        lastTxt = '-';
      } else if (isToday) {
        lastTxt = `${lastY} ${col.ok('(Transaksi hari ini)')}`;
      } else if (!isToday && visitsRaw === 0) {
        lastTxt = `${col.err(lastY)} ${col.err('(Belum transaksi hari ini)')}`;
      } else {
        lastTxt = `${lastY} ${col.dim('(Belum transaksi hari ini)')}`;
      }

      // Color tier
      let tierColored = tierName;
      const tierLow = String(tierName).toLowerCase();
      if (/gold/.test(tierLow)) tierColored = col.warn(tierName);
      else if (/vip|platinum|diamond/.test(tierLow)) tierColored = col.mag(tierName);
      else if (/classic|new/.test(tierLow)) tierColored = col.dim(tierName);

      return [
        String(it.no ?? ''),
        String(it.email || '-'),
        String(it.phone || '-'),
        tierColored,
        visitsTxt,
        lastTxt,
        yn(p.has),
        yn(p.usedBefore),
        p.status || '-',
        yn(c.has),
        yn(c.usedBefore),
        c.status || '-',
        yn(t.has),
        yn(t.usedBefore),
        t.status || '-',
        yn(f.has),
        yn(f.usedBefore),
        String(it._voucher_active_count ?? it.voucher_count_active ?? it.voucher_count ?? 0),
      ];
    });

    let widths = headers.map((h, i) => {
      let w = visibleLen(h);
      for (const r of rows) {
        const cell = r[i] ?? '';
        const len = visibleLen(cell);
        if (len > w) w = len;
      }
      return w;
    });

    const termW = Math.max(40, (process && process.stdout && process.stdout.columns) ? process.stdout.columns : 120);

    const idx = (name)=> headers.indexOf(name);
    const idxEmail = idx('Email');
    const idxPhone = idx('Phone');
    const idxTier  = idx('Tier');
    const idxLast  = idx('Last Movie');
    const idxStatus = [idx('Popcorn Status'), idx('Combo Status'), idx('3rd Status')].filter(i=>i>=0);
    const elasticIdxs = [...idxStatus, idxEmail, idxPhone, idxTier, idxLast].filter(i=>i>=0);

    widths = shrinkToFit(widths, headers, rows, elasticIdxs, termW);

    console.log(col.info('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
    console.log(col.info('â•‘                    AUTO REDEEM CODES (CGV)                   â•‘'));
    console.log(col.info('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
    if (titleNote) console.log(col.mag(`> ${titleNote}\n`));

    console.log(col.dim('Keterangan:'));
    console.log(col.dim('â€¢ Popcorn/Combo/3rd: status program & apakah pernah digunakan'));
    console.log(col.dim('â€¢ Flat10k Has/Used: status voucher tiket 10k flat price'));
    console.log(col.dim('â€¢ Last Movie: YYYY-MM-DD (+ label hari ini / belum)'));
    console.log(col.dim('â€¢ Warna: Hijau = transaksi hari ini; Merah = belum & visits=0.\n'));

    console.log(borderLine(widths, 'â”Œ', 'â”¬', 'â”'));

    const headerAlign = [
      'right','left','left','left','right','left',
      'center','center','left',
      'center','center','left',
      'center','center','left',
      'center','center',
      'right'
    ];

    let headerLine = 'â”‚';
    headers.forEach((h, i) => {
      const wi = widths[i];
      const a = headerAlign[i] || 'left';
      let cell = h;
      if (a === 'right')      cell = padLeftAnsi(cell, wi);
      else if (a === 'center')cell = padCenterAnsi(cell, wi);
      else                    cell = padRightAnsi(cell, wi);
      headerLine += ' ' + cell + ' â”‚';
    });
    console.log(headerLine);

    console.log(borderLine(widths, 'â”œ', 'â”¼', 'â”¤'));

    const rowAlign = [
      'right','left','left','left','right','left',
      'center','center','left',
      'center','center','left',
      'center','center','left',
      'center','center',
      'right'
    ];

    rows.forEach((r, idxRow) => {
      let line = 'â”‚';
      r.forEach((cell, i) => {
        let txt = String(cell ?? '');
        if ([idx('Email'), idx('Phone'), idx('Tier'), idx('Last Movie'), idx('Popcorn Status'), idx('Combo Status'), idx('3rd Status')].includes(i)) {
          const wi = widths[i];
          if (visibleLen(txt) > wi) txt = ellipsize(stripAnsi(txt), wi);
        }
        const a = rowAlign[i] || 'left';
        const wi = widths[i];
        if (a === 'right')      txt = padLeftAnsi(txt, wi);
        else if (a === 'center')txt = padCenterAnsi(txt, wi);
        else                    txt = padRightAnsi(txt, wi);

        line += ' ' + txt + ' â”‚';
      });
      console.log(line);
      if (idxRow < rows.length - 1) console.log(borderLine(widths, 'â”œ', 'â”¼', 'â”¤'));
      else                          console.log(borderLine(widths, 'â””', 'â”´', 'â”˜') + '\n');
    });

    if (rows.length === 0) {
      console.log(borderLine(widths, 'â””', 'â”´', 'â”˜') + '\n');
    }
  }

  // ===== INVALID/ERROR LOG HELPERS =====
  function ts() {
    const d = new Date();
    const pad = (n)=> String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }
  async function appendInvalidEntry(path, entry) {
    const line = `${entry.email || '-'} | ${entry.code || '-'} | ${String(entry.reason || '').replace(/\s+/g,' ').trim()}\n`;
    try {
      await fs.appendFile(path, line, 'utf-8');
    } catch (e) {
      console.log(col.warn(`âš ï¸  Gagal menulis ke ${path}: ${String(e && e.message || e)}`));
    }
  }

  // ===== AUTO SAVE SUCCESS ACCOUNT =====
  async function appendSuccessAccount(path, acc) {
    const identifier = acc.phone || acc.email || '-';
    const line = `${identifier}\n`;
    try {
      await fs.appendFile(path, line, 'utf-8');
    } catch (e) {
      console.log(col.warn(`âš ï¸  Gagal menulis ke ${path}: ${String(e && e.message || e)}`));
    }
  }

  // ===== JSON LOG (log_reedem.json & tsel_10k.json) =====
  async function appendJsonLine(path, obj) {
    try {
      await fs.appendFile(path, JSON.stringify(obj) + '\n', 'utf-8');
    } catch (e) {
      console.log(col.warn(`âš ï¸  Gagal menulis ke ${path}: ${String(e && e.message || e)}`));
    }
  }

  async function loadJsonLines(path) {
    try {
      const raw = await fs.readFile(path, 'utf-8');
      return raw
        .split(/\r?\n/)
        .map(s => s.trim())
        .filter(Boolean)
        .map(line => {
          try { return JSON.parse(line); } catch { return null; }
        })
        .filter(Boolean);
    } catch {
      return [];
    }
  }

  async function logRedeemAttempt({ account, accountKey, code, ok, statusLabel, message, httpStatus, isTsel10kExplicit }) {
    const email = account?.email || account?.username || null;
    const phone = account?.phone || account?.msisdn || account?.nohp || null;
    const isTsel = !!isTsel10kExplicit || isTsel10kCode(code);

    const entry = {
      ts: new Date().toISOString(),
      ymd: TODAY_YMD,
      accountKey,
      email,
      phone,
      code,
      result: ok ? 'SUCCESS' : 'ERROR',
      status: statusLabel,
      message,
      httpStatus: httpStatus ?? null,
      isTsel10k: isTsel
    };

    await appendJsonLine(logRedeemFile, entry);

    if (ok && isTsel) {
      const tselEntry = {
        ts: entry.ts,
        ymd: entry.ymd,
        accountKey,
        email,
        phone,
        code,
        message
      };
      await appendJsonLine(tsel10kLogFile, tselEntry);
    }
  }

  // ===== Selection & file helpers =====
  function parseSelectionNumbers(input, maxNo) {
    const toks = String(input||'').split(/[,\s]+/).filter(Boolean);
    const out = [];
    const seen = new Set();
    function push(n) {
      if (n>=1 && n<=maxNo && !seen.has(n)) {
        out.push(n); seen.add(n);
      }
    }
    for (const tk of toks) {
      if (/^\d+$/.test(tk)) {
        push(Number(tk));
      } else if (/^\d+\-\d+$/.test(tk)) {
        const [a,b] = tk.split('-').map(Number);
        const lo = Math.min(a,b), hi = Math.max(a,b);
        for (let i=lo;i<=hi;i++) push(i);
      }
    }
    return out; // tidak di-sort!
  }

  const normalizePhone = (s) => String(s||'').replace(/[^\d]/g,'').replace(/^0+/, '0'); // keep leading zero

  function buildIndexMaps(items) {
    const byNo = new Map();
    const byEmail = new Map();
    const byPhone = new Map();
    items.forEach((it, idx) => {
      const no = Number(it.no || 0);
      if (no > 0 && !byNo.has(no)) byNo.set(no, idx);
      const em = String(it.email || '').toLowerCase();
      if (em && !byEmail.has(em)) byEmail.set(em, idx);
      const ph = normalizePhone(it.phone);
      if (ph && !byPhone.has(ph)) byPhone.set(ph, idx);
    });
    return { byNo, byEmail, byPhone };
  }

  function parseSelectionMixed(input, items) {
    const tokens = String(input||'').split(/[,\s]+/).map(t=>t.trim()).filter(Boolean);
    const { byNo, byEmail, byPhone } = buildIndexMaps(items);
    const chosen = [];
    const seenIdx = new Set();

    const pushIdx = (idx) => {
      if (idx==null || idx<0) return;
      if (!seenIdx.has(idx)) { chosen.push(idx); seenIdx.add(idx); }
    };

    for (const tk of tokens) {
      // range numbers, e.g., 5-12
      if (/^\d+\-\d+$/.test(tk)) {
        const [a,b] = tk.split('-').map(Number);
        const lo = Math.min(a,b), hi = Math.max(a,b);
        for (let n=lo;n<=hi;n++) {
          const idx = byNo.get(n);
          if (idx!=null) pushIdx(idx);
        }
        continue;
      }

      // email token
      if (/@/.test(tk)) {
        const idx = byEmail.get(tk.toLowerCase());
        if (idx!=null) { pushIdx(idx); continue; }
      }

      // pure digits => could be table no or phone
      if (/^\d+$/.test(tk)) {
        const n = Number(tk);
        if (byNo.has(n)) { pushIdx(byNo.get(n)); continue; }
        const idx = byPhone.get(normalizePhone(tk));
        if (idx!=null) { pushIdx(idx); continue; }
      }

      // fallback: treat as phone (with symbols)
      const asPhone = normalizePhone(tk);
      if (asPhone) {
        const idx = byPhone.get(asPhone);
        if (idx!=null) { pushIdx(idx); continue; }
      }
    }
    return chosen;
  }

  async function readCodesFromFile(path) {
    try {
      const raw = await fs.readFile(path, 'utf-8');
      return raw.split(/\r?\n/).map(s=>s.trim()).filter(s => s && !s.startsWith('#'));
    } catch {
      return null;
    }
  }

  async function readValidCodesSet(path) {
    try {
      const raw = await fs.readFile(path, 'utf-8');
      const list = raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      return new Set(list);
    } catch {
      return new Set();
    }
  }
  async function appendValidCode(path, validSet, code) {
    if (validSet.has(code)) return;
    try {
      await fs.appendFile(path, code + '\n', 'utf-8');
      validSet.add(code);
    } catch (e) {
      console.log(col.warn(`âš ï¸  Gagal menulis ke ${path}: ${String(e && e.message || e)}`));
    }
  }

  async function removeCodesFromFileNow(activePath, codesToRemove) {
    if (!codesToRemove || !codesToRemove.length) return;
    const latest = await readCodesFromFile(activePath) || [];
    const rm = new Set(codesToRemove.filter(Boolean));
    const remaining = latest.filter(c => c && !rm.has(c));
    try {
      await fs.writeFile(activePath, (remaining.length ? remaining.join('\n') + '\n' : ''), 'utf-8');
    } catch (e) {
      console.log(col.warn(`âš ï¸  Gagal menulis ulang ${activePath}: ${String(e?.message||e)}`));
    }
  }

  async function rewriteCodeFileAfterProcessing(activePath, removeSet) {
    const latest = await readCodesFromFile(activePath) || [];
    const remaining = latest.filter(c => c && !removeSet.has(c));
    try {
      await fs.writeFile(activePath, (remaining.length ? remaining.join('\n') + '\n' : ''), 'utf-8');
    } catch (e) {
      console.log(col.warn(`âš ï¸  Gagal menulis ulang ${activePath}: ${String(e?.message||e)}`));
    }
  }

  const openedFiles = new Set();
  let spawnCmd = null;
  try { const cp = await import('node:child_process'); spawnCmd = cp.spawn; } catch {}
  function openFileInEditor(path) {
    if (!spawnCmd) return;
    if (openedFiles.has(path)) return;
    openedFiles.add(path);
    try {
      const platform = process.platform;
      let cmd, args;
      if (platform === 'win32') { cmd = 'cmd'; args = ['/c','start','', path]; }
      else if (platform === 'darwin') { cmd = 'open'; args = [path]; }
      else { cmd = 'xdg-open'; args = [path]; }
      const child = spawnCmd(cmd, args, { stdio: 'ignore', detached: true });
      child.unref();
      console.log(col.dim(`   â†³ Membuka file: ${path} (silakan paste kode & Ctrl+S)`));
    } catch (e) {
      console.log(col.warn(`âš ï¸  Gagal membuka file ${path}: ${String(e?.message||e)}`));
    }
  }

  // ---------- tampilkan tabel (dipisah) ----------
  const withVch = enriched.filter(hasAnyActiveVoucher);
  const noVch   = enriched.filter(it => !hasAnyActiveVoucher(it));

  if (withVch.length) drawAccountsTable(withVch, 'Akun dengan Voucher Aktif');
  if (noVch.length)   drawAccountsTable(noVch,   'Akun tanpa Voucher Aktif');
  ui.done();

  // ---------- pilih akun ----------
  ui.section('Pilih Akun Target');
  const maxNo = Math.max(...enriched.map(x=>x.no||0));

  // ========== FILE-BASED SELECTION WITH MONITORING ==========
  const REDEEM_FILE = 'redeem-tsel.txt';
  const REDEEM_HISTORY_FILE = 'redeem-tsel-riwayat.txt';
  const AKUNTSEL_FILE = 'akuntsel-10k.txt';
  const MONITORING_INTERVAL = parseInt(process.env.AUTO_ACCOUNT_MONITORING_INTERVAL || '1', 10);

  // Auto-create required files if not exist
  async function ensureRequiredFiles() {
    const filesToCreate = [
      { path: REDEEM_FILE, content: '# AUTO REDEEM TSEL 10K - Account List\n# Format: Email atau Nomor Telepon, 1 per baris\n# Duplikat akan otomatis terdeteksi dan difilter\n\n' },
      { path: REDEEM_HISTORY_FILE, content: '# REDEEM HISTORY - DO NOT EDIT\n# Format: email/phone|date|status\n\n' },
      { path: AKUNTSEL_FILE, content: '# AKUN SUKSES REDEEM TSEL 10K\n# Auto-saved dari redeem sukses\n\n' }
    ];

    for (const file of filesToCreate) {
      const exists = await fs.access(file.path).then(() => true).catch(() => false);
      if (!exists) {
        await fs.writeFile(file.path, file.content, 'utf-8');
        console.log(col.gray(`âœ“ Created ${file.path}`));
      }
    }
  }

  // Ensure files exist before starting
  await ensureRequiredFiles();

  // Helper: open file in editor (non-blocking)
  async function openRedeemFileInEditor(filePath) {
    const { spawn } = await import('child_process');
    const os = await import('os');

    const platform = os.platform();
    let command;
    let args = [filePath];

    if (platform === 'win32') {
      command = 'notepad';
    } else if (platform === 'darwin') {
      command = 'open';
      args = ['-a', 'TextEdit', filePath];
    } else {
      command = 'xdg-open';
    }

    try {
      console.log(col.cyan(`ğŸ“‚ Membuka ${filePath} dengan ${command}...`));
      console.log(col.gray(`ğŸ’¡ Tambahkan akun ke file & Save (Ctrl+S), monitoring realtime!\n`));

      spawn(command, args, {
        detached: true,
        stdio: 'ignore',
        shell: true
      }).unref();

      await new Promise(r => setTimeout(r, 500));
    } catch (err) {
      console.log(col.warn(`âš ï¸  Gagal buka editor: ${err.message}`));
    }
  }

  let selStr = '';
  let useFileMode = false;

  // Check if file exists and has content
  const fileExists = await fs.access(REDEEM_FILE).then(() => true).catch(() => false);
  const fileContent = fileExists ? await fs.readFile(REDEEM_FILE, 'utf-8').catch(() => '') : '';
  const lines = fileContent.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));

    if (lines.length > 0) {
      console.log(col.cyan(`ğŸ“‚ Terdeteksi file ${REDEEM_FILE} dengan ${lines.length} akun`));
      const { mode } = await inquirer.prompt([{
        type: 'list',
        name: 'mode',
        message: 'Pilih mode input akun:',
        choices: [
          { name: `ğŸ¤– Auto dari file (${REDEEM_FILE})`, value: 'file' },
          { name: 'âœ‹ Manual input', value: 'manual' }
        ]
      }]);

      if (mode === 'file') {
        useFileMode = true;
        selStr = lines.join(',');
        console.log(col.gray(`ğŸ“„ Memproses ${lines.length} akun dari file...`));
      }
  } else if (MONITORING_INTERVAL > 0) {
    // File tidak ada atau kosong â†’ monitoring mode
    if (!fileExists) {
      console.log(col.warn(`âš ï¸  File ${REDEEM_FILE} tidak ditemukan`));
    } else {
      console.log(col.warn(`âš ï¸  File ${REDEEM_FILE} kosong`));
    }
    console.log(col.cyan(`ğŸ”„ Mode Monitoring: Cek file setiap ${MONITORING_INTERVAL} detik\n`));

    await openRedeemFileInEditor(REDEEM_FILE);

    console.log(col.cyan(`â³ Monitoring dimulai... (tekan Ctrl+C untuk batal)\n`));

    while (!useFileMode) {
      await new Promise(r => setTimeout(r, MONITORING_INTERVAL * 1000));

      const content = await fs.readFile(REDEEM_FILE, 'utf-8').catch(() => '');
      const newLines = content.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));

      if (newLines.length > 0) {
        console.log(col.gray(`ğŸ“„ Terdeteksi ${newLines.length} akun baru!`));
        useFileMode = true;
        selStr = newLines.join(',');
        console.log(col.green(`âœ… Auto-select dari monitoring!`));
        break;
      } else {
        console.log(col.gray(`â³ File masih kosong... (cek lagi dalam ${MONITORING_INTERVAL}s)`));
      }
    }
  }

  if (!useFileMode) {
    const { selStrInput } = await inquirer.prompt([{
      type: 'input',
      name: 'selStrInput',
      message: 'Pilih akun: No tabel (ex: 1-10,12), atau EMAIL, atau NOMOR HP. Campur boleh. Pisahkan dengan koma/spasi: ',
    }]);
    selStr = selStrInput;
  }

  // Backcompat: kalau user hanya isi angka/range, tetap jalan seperti sebelumnya
  const selectedIdxs = parseSelectionMixed(selStr, enriched);
  if (!selectedIdxs.length) {
    console.log(col.warn('Tidak ada akun terpilih (cek input: no/email/phone).'));
    await pauseToMenu();
    return;
  }

  // Deduplicate akun berdasarkan nomor HP / email / username (1 key = 1 akun unik)
  const selectedAccounts = [];
  const seenAccountKeys = new Set();
  for (const idx of selectedIdxs) {
    const acc = enriched[idx];
    const key = getAccountKey(acc) || String(acc.email || '').toLowerCase() || `idx_${idx}`;
    if (!key) continue;
    if (seenAccountKeys.has(key)) continue;
    seenAccountKeys.add(key);
    selectedAccounts.push({ idx, acc, accountKey: String(key) });
  }

  if (!selectedAccounts.length) {
    console.log(col.warn('Tidak ada akun unik setelah deduplicate (cek input: no/email/phone).'));
    await pauseToMenu();
    return;
  }

  ui.info(`Terpilih dari input: ${selectedIdxs.length} baris â†’ ${selectedAccounts.length} akun unik (berdasarkan no HP/email).`);
  ui.done();

  // ---------- muat history TSEL 10K dari log (hari ini saja) ----------
  const logEntries = await loadJsonLines(logRedeemFile);
  const tselEntries = await loadJsonLines(tsel10kLogFile);

  tselTodayByAccountKey = new Map();
  const considerPrevLog = (entry) => {
    if (!entry) return;
    const ymd = entry.ymd || entry.date || (entry.ts || '').slice(0, 10);
    if (ymd !== TODAY_YMD) return;
    const key = entry.accountKey || entry.phone || entry.email;
    if (!key) return;
    const isTsel = entry.isTsel10k || isTsel10kCode(entry.code);
    if (!isTsel) return;
    if (entry.result && entry.result !== 'SUCCESS') return;
    if (!tselTodayByAccountKey.has(String(key))) {
      tselTodayByAccountKey.set(String(key), entry);
    }
  };

  logEntries.forEach(considerPrevLog);
  tselEntries.forEach(considerPrevLog);

  if (tselTodayByAccountKey.size) {
    ui.info(`Dari log ditemukan ${tselTodayByAccountKey.size} akun yg sudah redeem TSEL10K hari ini.`);
    ui.done();
  }

  // ---------- baca codes ----------
  ui.section('Membaca Stok Kode');
  let activeCodePath = codeFile;
  let allInputCodesRaw = await readCodesFromFile(codeFile);
  if (!allInputCodesRaw) {
    allInputCodesRaw = await readCodesFromFile('codes.txt');
    if (!allInputCodesRaw) {
      console.log(col.err(`âŒ File kode tidak ditemukan: ${codeFile} (atau "codes.txt")`));
      await pauseToMenu();
      return;
    }
    activeCodePath = 'codes.txt';
  }

  const validSet = await readValidCodesSet(validCodeFile);

  const seenCodes = new Set();
  const skippedAlreadyValid = [];
  const codesFiltered = [];
  for (const c of allInputCodesRaw) {
    if (seenCodes.has(c)) continue;
    seenCodes.add(c);
    if (validSet.has(c)) skippedAlreadyValid.push(c);
    else codesFiltered.push(c);
  }
  if (skippedAlreadyValid.length) {
    await removeCodesFromFileNow(activeCodePath, skippedAlreadyValid);
  }
  let codes = codesFiltered.slice();
  let depletedOnce = false;

  console.log(col.dim(`Ditemukan ${allInputCodesRaw.length} baris dari file input (${activeCodePath}).`));
  if (skippedAlreadyValid.length) {
    console.log(col.dim(`Lewati & bersihkan ${skippedAlreadyValid.length} kode (sudah ada di ${validCodeFile}).`));
  }
  console.log(col.dim(`Siap diproses: ${codes.length} kode.`));
  ui.done();

  // ---------- mode mapping ----------
  ui.section('Pemetaan Kode â†’ Akun');

  let perAccount = 1;

  if (AUTO_CODE_MAPPING) {
    // Skip prompt, use ENV config
    perAccount = AUTO_CODE_PER_ACCOUNT;
    console.log(col.dim(`âœ“ Auto mode: ${perAccount} kode per akun (dari ENV)`));
  } else {
    // Ask user
    const { modeMap } = await inquirer.prompt([{
      type: 'list',
      name: 'modeMap',
      message: 'Pemetaan kode â†’ akun?',
      choices: [
        '1 akun : 1 kode (default, aman)',
        'Kustom â€” tentukan jumlah kode per akun'
      ]
    }]);

    if (modeMap.startsWith('Kustom')) {
      const { n } = await inquirer.prompt([{
        type: 'number',
        name: 'n',
        message: `Berapa kode per akun?`,
        validate: (v)=> Number.isInteger(v) && v>0 ? true : 'Masukkan bilangan bulat > 0'
      }]);
      perAccount = n;
    }
  }

  const successTarget = perAccount;
  const need = successTarget * selectedAccounts.length;

  if (codes.length < need) {
    console.log(col.warn(`âš ï¸  Stok kode kurang: butuh ${need}, tersedia ${codes.length}.`));
    if (AUTO_CONFIRM_REDEEM_CONTINUE) {
      console.log(col.info('âœ“ Auto-confirm: Lanjut dengan stok tersedia (AUTO_CONFIRM_REDEEM_CONTINUE=true)'));
    } else {
      const { cont } = await inquirer.prompt([{
        type: 'confirm', name: 'cont',
        message: 'Lanjutkan memakai sebanyak yang tersedia (sisanya dipantau otomatis saat habis)?', default: true
      }]);
      if (!cont) { await pauseToMenu(); return; }
    }
  }
  console.log(col.dim(`(Auto-watch aktif: jika stok habis, file "${activeCodePath}" akan dibuka & dipantau tiap ${watchPollMs}ms; habis di tengah proses â†’ 10ms)`));
  ui.done();

  // ---------- PROSES ----------
  ui.section('Proses Redeem');
  console.log(col.info('\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ REDEEM PROCESS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));
  let okCnt=0, invalidCnt=0, errCnt=0;
  const detailsOK = [];
  const detailsFail = [];

  const processedValid = [];
  const processedInvalid = [];
  const processedValidSet = new Set();
  const processedInvalidSet = new Set();
  const processedAccountsSuccess = new Set(); // Track sukses redeem accounts

  // Batch tracking for summary
  let currentBatchCodes = [];
  let currentBatchSuccess = [];
  let currentBatchInvalid = [];
  let currentBatchErrors = [];
  let batchSuccessCount = 0;
  let batchInvalidCount = 0;
  let batchErrorCount = 0;

  const printBatchSummary = () => {
    if (currentBatchCodes.length === 0) return;

    console.log(col.cyan('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
    console.log(col.cyan('â•‘              ğŸ“Š BATCH SUMMARY (Kode Baru)                     â•‘'));
    console.log(col.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
    console.log(col.dim(`  Total kode diproses: ${currentBatchCodes.length}`));

    if (batchSuccessCount > 0) {
      console.log(col.green(`\n  âœ“ Berhasil (${batchSuccessCount}):`))
      currentBatchSuccess.forEach(item => {
        console.log(col.green(`    â€¢ ${item.code} â†’ ${item.info}`));
      });
    }

    if (batchInvalidCount > 0) {
      console.log(col.red(`\n  âœ— Invalid (${batchInvalidCount}):`))
      currentBatchInvalid.forEach(item => {
        console.log(col.red(`    â€¢ ${item.code} â†’ ${item.reason}`));
      });
    }

    if (batchErrorCount > 0) {
      console.log(col.yellow(`\n  âš  Error (${batchErrorCount}):`))
      currentBatchErrors.forEach(item => {
        console.log(col.yellow(`    â€¢ ${item.code} â†’ ${item.reason}`));
      });
    }

    console.log(col.dim('\n' + 'â”€'.repeat(68) + '\n'));

    // Reset batch tracking
    currentBatchCodes = [];
    currentBatchSuccess = [];
    currentBatchInvalid = [];
    currentBatchErrors = [];
    batchSuccessCount = 0;
    batchInvalidCount = 0;
    batchErrorCount = 0;
  };

  const ensureCodesAvailable = async () => {
    if (codes.length > 0) return true;

    // Print summary of previous batch before getting new codes
    if (currentBatchCodes.length > 0) {
      printBatchSummary();
    }

    const fresh = await waitForMoreCodes({
      path: activeCodePath,
      validSet,
      seenCodes,
      processedValidSet,
      processedInvalidSet,
      pollMs: (depletedOnce ? 10 : watchPollMs)
    });
    depletedOnce = true;
    if (quitRequested) return false;
    if (fresh && (fresh.codes || fresh.length)) {
      const newCodes = fresh.codes || fresh;
      codes.push(...newCodes);

      // Start new batch tracking
      if (fresh.isBatch) {
        currentBatchCodes = [...newCodes];
        batchSuccessCount = 0;
        batchInvalidCount = 0;
        batchErrorCount = 0;
      }

      return true;
    }
    return false;
  };

  const takeOneCode = async () => {
    if (codes.length === 0) {
      const ok = await ensureCodesAvailable();
      if (!ok) return null;
    }
    return codes.shift() ?? null;
  };

  // ğŸ” Loop akun â€” bisa diputus dengan /quit
  outerRedeemLoop:
  for (let pos=0; pos<selectedIdxs.length; pos++) {
    if (quitRequested) {
      console.log(col.warn('\nâ¹ Proses redeem dihentikan oleh user (/quit) sebelum akun berikutnya.'));
      break;
    }

    const i = selectedIdxs[pos];
    const acc = enriched[i];
    const emailDisp = String(acc.email || '-');
    const emailKey  = String(acc.email || '').toLowerCase();
    const prefix    = `${col.dim(`[${pos+1}/${selectedIdxs.length}]`)} ${col.white(emailDisp)}`;

    let ensure = await ensureBearerForEmail(acc.email, acc._bearer || acc.bearer, itemByEmail.get(emailKey));
    if (!ensure.ok) {
      console.log(`${prefix} ${col.err('âœ—')} ${col.dim(`â€” ${ensure.reason || 'Cannot get bearer'}`)}`);
      errCnt++;
      continue;
    }
    let bearer = ensure.bearer;

    // === KONFIRMASI jika sudah punya TELKOMSEL 10K FLATPRICE aktif ===
    const flat = flatRaw(acc);
    if (flat.has) {
      const { allow } = await inquirer.prompt([{
        type: 'confirm',
        name: 'allow',
        default: false,
        message: `Akun ${emailDisp} sudah memiliki voucher TELKOMSEL 10K FLATPRICE aktif. Tetap redeem kode baru untuk akun ini?`
      }]);
      if (!allow) {
        console.log(`${prefix} ${col.warn('â€¢')} ${col.dim('â€” dilewati (Flat10k sudah ada)')}`);
        continue;
      }
    }

    let successCount = 0;

    while (successCount < successTarget) {
      // Jika user ketik /quit di tengah-tengah redeem â†’ stop semua
      if (quitRequested) {
        console.log(col.warn('\nâ¹ Proses redeem dihentikan oleh user (/quit).'));
        break outerRedeemLoop;
      }

      const code = await takeOneCode();
      if (!code) {
        // Di sini, yang bikin null biasanya karena /quit atau benar-benar tidak ada kode baru
        console.log(`${prefix} ${col.warn('â€¢')} ${col.dim('â€” watch kode dihentikan (/quit atau tidak ada kode baru)')}`);
        break outerRedeemLoop;
      }

      // Helper untuk 1 attempt (supaya bisa dipakai saat retry 401 atau retry PIN)
      const attempt = async (pinCode = null) => {
        const t0 = Date.now();
        const r = await postRedeem(bearer, code, pinCode);
        const took = ((Date.now()-t0)/1000).toFixed(1)+'s';
        const rateNote = r?.rate ? col.dim(`(remain ${r.rate.remain ?? '?'}/${r.rate.limit ?? '?'})`) : '';
        return { r, took, rateNote };
      };

      let { r, took, rateNote } = await attempt();

      // === Handle PIN requirement ===
      if (r.requiresPin && r.needRetryWithPin) {
        // Voucher butuh PIN - langsung minta PIN tanpa check dulu
        process.stdout.write(`${prefix} ${col.warn('âš ')} ${col.dim(code)} ${col.yellow('â€” butuh PIN')} ${rateNote}\n`);

        let pinAttempts = 0;
        const maxPinAttempts = 3;

        while (pinAttempts < maxPinAttempts) {
          const { pin } = await inquirer.prompt([{
            type: 'input',
            name: 'pin',
            message: `Masukkan PIN untuk voucher ${code} (atau ketik "skip" untuk lewati):`,
            validate: (input) => {
              const s = String(input || '').trim();
              if (s.toLowerCase() === 'skip') return true;
              if (/^\d+$/.test(s)) return true;
              return 'PIN harus berupa angka atau ketik "skip"';
            }
          }]);

          if (String(pin).toLowerCase() === 'skip') {
            process.stdout.write(`${prefix} ${col.warn('â€¢')} ${col.dim(`â€” ${code} dilewati (tidak ada PIN)`)}\n`);
            await removeCodesFromFileNow(activeCodePath, [code]);
            break;
          }

          ({ r, took, rateNote } = await attempt(pin));

          if (r.ok) {
            break; // PIN benar, keluar dari loop
          } else if (r.needRetryWithPin) {
            pinAttempts++;
            // Tampilkan response dari API
            const apiResponse = r.reason || r.message || 'PIN tidak valid';
            process.stdout.write(`${prefix} ${col.err('âœ—')} ${col.dim(`PIN salah (${pinAttempts}/${maxPinAttempts})`)}\n`);
            process.stdout.write(col.dim(`   â†³ Response: ${apiResponse}\n`));
            if (pinAttempts >= maxPinAttempts) {
              process.stdout.write(`${prefix} ${col.err('âœ—')} ${col.dim(`â€” ${code} gagal (max PIN attempts)`)}\n`);
              await appendInvalidEntry(invalidCodeFile, {
                email: acc.email,
                code: code,
                reason: `PIN salah (${maxPinAttempts} attempts)`
              });
              await removeCodesFromFileNow(activeCodePath, [code]);
            }
          } else {
            // Error lain, keluar
            break;
          }
        }
      }

      // === Auto re-login & retry once on 401 ===
      if (r.code === 401) {
        const relog = await ensureBearerForEmail(acc.email, null, itemByEmail.get(emailKey));
        if (relog.ok) {
          bearer = relog.bearer;
          ({ r, took, rateNote } = await attempt());
        }
      }

      if (r.ok) {
        okCnt++;
        batchSuccessCount++; // Track batch success
        processedValid.push(code);
        processedValidSet.add(code);
        const pinInfo = r.requiresPin ? col.cyan('[with PIN]') : '';
        process.stdout.write(`${prefix} ${col.ok('âœ“ Redeemed')} ${col.dim(code)} ${pinInfo} ${rateNote} ${col.dim(`(${took})`)}\n`);

        await appendValidCode(validCodeFile, validSet, code);
        await removeCodesFromFileNow(activeCodePath, [code]);
        await appendSuccessAccount('akuntsel-10k.txt', acc);

        // Get voucher detail untuk batch summary
        const g = await getCouponDetail(bearer, code);
        let voucherInfo = code; // Default: tampilkan code aja
        if (g.ok) {
          const d = g.data || {};
          const vName = d.name || '-';
          const vKind = d.kind || d.type || 'coupon';
          const vValidTo = d.expired_date || d.valid_to || d.end_at || '-';
          voucherInfo = `${vName} [${vKind}] (Exp: ${vValidTo})`;

          const desc = d.description ? String(d.description).replace(/\s+/g,' ').slice(0,180) : '-';
          detailsOK.push({
            email: acc.email,
            code,
            name: vName,
            kind: vKind,
            valid_from: d.start_date || d.valid_from || d.start_at || '-',
            valid_to: vValidTo,
            desc
          });
          process.stdout.write(col.dim(`   â†³ Success: ${vName} [${vKind}] | Valid: ${d.start_date || d.valid_from || '-'} â†’ ${vValidTo}\n`));
          if (desc && desc !== '-') process.stdout.write(col.dim(`      Note : ${desc}\n`));
        } else {
          process.stdout.write(col.dim(`   â†³ detail fetch gagal (HTTP ${g.code || '???'})\n`));
        }

        // Track detail untuk batch summary (tanpa email/nomor)
        currentBatchSuccess.push({ code, info: voucherInfo });

        successCount++;

        // Track account success for cleanup
        if (successCount >= successTarget) {
          const identifier = acc.phone || acc.email;
          processedAccountsSuccess.add(identifier);
        }

        if (successCount >= successTarget) break;

      } else if (r.code === 422) {
        invalidCnt++;
        batchInvalidCount++; // Track batch invalid
        const { reasonStr, code:codeHttp } = explainFailure(r);

        // Check if "Already personalized" - need to verify if it's ours or someone else's
        const isAlreadyPersonalized = /already\s+personalized/i.test(reasonStr || '');
        let finalReasonStr = reasonStr || 'Invalid Coupon';

        if (isAlreadyPersonalized) {
          // Check voucher to see if it's in our account
          process.stdout.write(`${prefix} ${col.warn('âš™ï¸ Checking voucher...')} ${col.dim('(verifying ownership)')}\n`);

          try {
            // Direct API call ke membership/info untuk ambil gift vouchers
            const memberInfoUrl = `${baseURL}/api/membership/info`;
            const FD = globalThis.FormData || (await import('form-data')).default;
            const fd = new FD();
            const boundary = `----WebKitFormBoundary${Math.random().toString(36).slice(2)}`;

            const memberInfoRes = await fetch(memberInfoUrl, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${bearer}`,
                'content-type': `multipart/form-data; boundary=${boundary}`
              },
              body: fd
            });

            const memberInfoJson = await memberInfoRes.json();
            const giftList = Array.isArray(memberInfoJson?.RESULTS?.ds_GFT_LIST) ? memberInfoJson.RESULTS.ds_GFT_LIST : [];

            // Search for this voucher code in gift list
            const foundInOurAccount = giftList.some(v => {
              // Gift voucher code bisa di GFTCERT_NO atau DSC_CD
              const vCode = String(v?.GFTCERT_NO || v?.DSC_CD || '').trim().toUpperCase();
              const searchCode = String(code).trim().toUpperCase();
              return vCode === searchCode;
            });

            if (foundInOurAccount) {
              finalReasonStr = 'Already personalized (sudah ada di akun kita)';
              process.stdout.write(col.info(`   â†³ âœ… Voucher sudah ada di akun kita (${acc.email})\n`));
            } else {
              finalReasonStr = 'Already personalized (sudah dipakai akun lain)';
              process.stdout.write(col.warn(`   â†³ âš ï¸  Voucher sudah dipakai di akun lain\n`));
            }
          } catch (e) {
            // Jika check gagal, tetap pakai message original
            finalReasonStr = 'Already personalized (gagal verify ownership)';
            process.stdout.write(col.dim(`   â†³ âš ï¸  Gagal check ownership: ${e.message}\n`));
          }
        }

        // Untuk "Already personalized", tampilkan akun
        let displayReason = finalReasonStr;
        if (isAlreadyPersonalized && finalReasonStr.includes('sudah ada di akun kita')) {
          displayReason = `${finalReasonStr} â†’ ${acc.email || acc.phone || 'unknown'}`;
        }
        currentBatchInvalid.push({ code, reason: displayReason }); // Track detail
        processedInvalid.push(code);
        processedInvalidSet.add(code);
        process.stdout.write(`${prefix} ${col.err('âœ— Invalid')} ${col.dim(code)} ${rateNote} ${col.dim(`(${took})`)}\n`);
        process.stdout.write(col.dim(`   â†³ Reason: ${finalReasonStr} | code=${codeHttp}\n`));
        detailsFail.push({ email: acc.email, code, http: codeHttp, reason: finalReasonStr });

        await appendInvalidEntry(invalidCodeFile, {
          email: acc.email,
          code,
          reason: stripAnsi(finalReasonStr)
        });
        await removeCodesFromFileNow(activeCodePath, [code]);

      } else if (r.code === 401) {
        // Setelah retry tetap 401 â†’ anggap ERROR, tapi JANGAN hapus kode dari file
        errCnt++;
        batchErrorCount++; // Track batch error
        const { reasonStr, code:codeHttp } = explainFailure(r);
        currentBatchErrors.push({ code, reason: reasonStr || 'Unauthorized (after retry)' }); // Track detail
        process.stdout.write(`${prefix} ${col.err('âœ— 401 Unauthorized (after retry)')} ${col.dim(code)} ${rateNote} ${col.dim(`(${took})`)}\n`);
        if (reasonStr) process.stdout.write(col.dim(`   â†³ Reason: ${reasonStr} | code=${codeHttp}; kode dipertahankan di file.\n`));
        detailsFail.push({ email: acc.email, code, http: codeHttp, reason: reasonStr || 'Unauthorized (after retry)' });

        await appendInvalidEntry(invalidCodeFile, {
          email: acc.email,
          code,
          reason: stripAnsi(reasonStr || 'Unauthorized (after retry)')
        });
        // jangan remove kode

      } else {
        errCnt++;
        batchErrorCount++; // Track batch error
        const { reasonStr, code:codeHttp } = explainFailure(r);
        currentBatchErrors.push({ code, reason: reasonStr || r.reason || 'Error' }); // Track detail
        processedInvalid.push(code);
        processedInvalidSet.add(code);
        process.stdout.write(`${prefix} ${col.err(`âœ— ${r.reason||'Error'}`)} ${col.dim(code)} ${rateNote} ${col.dim(`(${took})`)}\n`);
        if (reasonStr) process.stdout.write(col.dim(`   â†³ Reason: ${reasonStr} | code=${codeHttp}\n`));
        detailsFail.push({ email: acc.email, code, http: codeHttp, reason: reasonStr || r.reason || 'Error' });

        await appendInvalidEntry(invalidCodeFile, {
          email: acc.email,
          code,
          reason: stripAnsi(reasonStr || r.reason || 'Error')
        });
        await removeCodesFromFileNow(activeCodePath, [code]);
      }

      await delay(throttleMs);
    }
  }
  console.log(col.info('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));
  ui.done();

  // ---------- CLEANUP & SAVE redeem-tsel.txt ----------
  if (useFileMode && processedAccountsSuccess.size > 0) {
    try {
      // Remove processed accounts from redeem-tsel.txt
      const currentContent = await fs.readFile(REDEEM_FILE, 'utf-8').catch(() => '');
      const currentLines = currentContent.split('\n');
      const remaining = currentLines.filter(line => {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('#')) return true;
        return !processedAccountsSuccess.has(trimmed);
      });

      await fs.writeFile(REDEEM_FILE, remaining.join('\n'), 'utf-8');
      console.log(col.cyan(`\nâœ‚ï¸  Dihapus dari ${REDEEM_FILE}: ${processedAccountsSuccess.size} akun (sukses redeem)`));
      console.log(col.green(`âœ“ Sudah disimpan ke akuntsel-10k.txt: ${processedAccountsSuccess.size} akun (auto-saved saat sukses)\n`));
    } catch (err) {
      console.log(col.warn(`âš ï¸  Cleanup ${REDEEM_FILE} gagal: ${err.message}`));
    }
  }


  // ---------- CLEANUP code.txt / codes.txt ----------
  try {
    const removeSet = new Set([...processedValid, ...processedInvalid, ...skippedAlreadyValid]);
    await rewriteCodeFileAfterProcessing(activeCodePath, removeSet);
  } catch (e) {
    console.log(col.warn(`âš ï¸  Cleanup ${activeCodePath} gagal: ${String(e?.message||e)}`));
  }

  // ---------- SUMMARY ----------
  ui.section('Summary');
  console.log(col.info('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SUMMARY â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
  console.log(col.ok(`Redeemed OK   : ${okCnt}`));
  console.log(col.err(`Invalid (422) : ${invalidCnt}`));
  console.log(col.warn(`Errors        : ${errCnt}`));
  try {
    const totalValid = Array.from((await readValidCodesSet(validCodeFile))).length;
    console.log(col.dim(`(Total kode sudah valid di ${validCodeFile}: ${totalValid})`));
  } catch {}

  if (detailsOK.length) {
    console.log(col.dim('\nDetail voucher yang berhasil:'));
    for (const d of detailsOK) {
      console.log(` - ${chalk.white(d.email)} â†’ ${chalk.green(d.code)} | ${d.name} [${d.kind}] | Valid: ${d.valid_from} â†’ ${d.valid_to}`);
      if (d.desc && d.desc !== '-') console.log(col.dim(`   Note : ${d.desc}`));
    }
  }

  if (detailsFail.length) {
    console.log(col.dim('\nDetail yang gagal/invalid:'));
    for (const f of detailsFail) {
      console.log(` - ${chalk.white(f.email)} â†’ ${chalk.red(f.code)} | ${chalk.yellow(`Reason: ${f.reason}`)} | HTTP ${f.http}`);
    }
    console.log(col.dim(`\n(Ringkasan invalid disimpan ke ${invalidCodeFile} sebagai "email | kode | alasan")`));
  }
  console.log(col.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
  ui.done();

  // ---------- FINAL: TULIS UPDATE KE account.json (HANYA FIELD TERKAIT) ----------
  ui.section('Update account.json (bearer/password only)');
  try {
    const nowMapSize = pendingUpdates.size;
    if (nowMapSize > 0) {
      let mutCount = 0;
      const itemsNew = itemsRaw.map(orig => {
        const key = String(orig?.email || '').toLowerCase();
        const patch = pendingUpdates.get(key);
        if (!patch) return orig;
        mutCount++;
        // Jangan regenerate. Hanya merge field yg diizinkan.
        const merged = { ...orig };
        if ('bearer' in patch) merged.bearer = patch.bearer;
        if ('bearer_wrapped' in patch) merged.bearer_wrapped = patch.bearer_wrapped;
        if ('bearer_updated_at' in patch) merged.bearer_updated_at = patch.bearer_updated_at;
        if ('login_ok' in patch) merged.login_ok = patch.login_ok;

        if ('password' in patch) merged.password = patch.password;
        if ('password_updated_at' in patch) merged.password_updated_at = patch.password_updated_at;

        return merged;
      });

      // Tulis kembali accData dengan items yang sudah di-merge
      const accOut = { ...accData, items: itemsNew };
      await fs.writeFile('account.json', JSON.stringify(accOut, null, 2), 'utf-8');
      console.log(col.ok(`âœ“ account.json diupdate (records: ${mutCount}; fields: bearer/password).`));
    } else {
      console.log(col.dim('Tidak ada perubahan bearer/password untuk disimpan.'));
    }
  } catch (e) {
    console.log(col.warn(`âš ï¸  Gagal update account.json: ${String(e?.message||e)}`));
  }
  ui.done();

  await pauseToMenu();
}











/* ================================================================
   6. ---------- MENU, LOOP & RUN --------------------------------
   Ganti recursion dengan loop, fixed bug mainMenu()
   ================================================================ */
/* ================================================================ */
async function mainMenu() {
  while (true) {
    console.clear();
    console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
    console.log(chalk.cyan('â•‘           CGV Account Tools          â•‘'));
    console.log(chalk.cyan('â•‘            by Iqra Ganteng           â•‘'));
    console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));

    // â”€â”€ menu utama â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const { menuChoice } = await inquirer.prompt([{
      type : 'list',
      name : 'menuChoice',
      message : 'Select option:',
      choices : [
        'List Accounts',  
        'Auto Create Account',
        'Auto Order',
        'Auto Order F&B',
        'Auto Refresh Tokens',
        'Auto Redeem Codes (CGV)',
        'Auto Login (from data.txt)',
        'Update Profiles',
        'Check Vouchers',
        'Check Transactions',
        'Change Password',
        'Delete Accounts',
        'Xtrap Code Voucher Tsel-10K',
        'Exit'
      ]
    }]);

    // â”€â”€ handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (menuChoice === 'Auto Create Account') {
      const { mode } = await inquirer.prompt([{
        type : 'list',
        name : 'mode',
        message : 'Choose method:',
        choices : [
          'Automatic (temp-mail)',
          'Manual (Gmail prefix)',
          'Manual (email.txt)'          // â† opsi baru
        ]
      }]);

      let runMode = 'auto';
      if (mode.startsWith('Automatic')) {
        runMode = 'auto';
      } else if (mode.includes('Gmail prefix')) {
        runMode = 'gmail';
      } else if (mode.includes('email.txt')) {
        runMode = 'emailtxt';          // â† trigger flow email.txt
      }

      await autoCreateAccount(runMode);

    } else if (menuChoice === 'Auto Order') {
      await autoOrder();

    } else if (menuChoice === 'Auto Order F&B') {
      await autoOrderFnb();             // â† F&B (NEW!)

    } else if (menuChoice === 'List Accounts') {
      await listAccounts();

    } else if (menuChoice === 'Auto Refresh Tokens') {
      await autoRefreshTokens();

    } else if (menuChoice === 'Auto Redeem Codes (CGV)') {
      await autoRedeemCgvCodes();

    } else if (menuChoice === 'Auto Login (from data.txt)') {
      await autoLoginFromDataFile();

    } else if (menuChoice === 'Update Profiles') {
      await updateRandomProfile();

    } else if (menuChoice === 'Check Vouchers') {
      await checkVouchers();

    } else if (menuChoice === 'Check Transactions') {
      await checkTransactions();

    } else if (menuChoice === 'Change Password') {
      await changePasswords();

    } else if (menuChoice === 'Delete Accounts') {
      await deleteAccounts();
    
    } else if (menuChoice === 'Xtrap Code Voucher Tsel-10K') {
      await XtrapCodeVoucher();

    } else {                           // Exit
      console.log(chalk.cyan('Bye!'));
      process.exit(0);
    }

    console.log(chalk.gray('\n[!] Returning to menu in 5s...'));
    await delay(5000);
  }
}

/* -------------------- RUN --------------------------------------- */
mainMenu();
